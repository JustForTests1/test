 /* QCHINTM - INTERPRETER MODULE                                      */00010000
 /*********************************************************************/00020000
 /* MODULE NAME  : QCHINTM      INTERPRETER MODULE                    */00030000
 /* APPLICATION  : CHIS                                               */00050000
 /* INPUT        : SPA,RUL,SYV,STR                                    */00100000
 /* PROCESSING   : THE DRIVER MODULE READS QCHSRUL AND QCHSSTR        */00121000
 /*                FOR THE INTERPRETER                                */00121000
 /*                THE INTERPRETER EXECUTES THE STATEMENTS AND        */00121000
 /*                MODIFIES THE TABLES,SCREENS & USERVARIABLES        */00121000
 /*                DEPENDING ON THE RULECODE                          */00121000
 /*                NOTE:                                              */00121000
 /*                 1.)NOT ALL TABLES ARE IN ACCESS FOR THE INTERPRT. */00121000
 /*                    (LOOKUP IN FIND_STRUCTURE PROC)                */00121000
 /*                 2.)NUMBERS OF USERVARS LIMITED TO 2000            */00121000
 /*                 3.)USERVARIABLES ARE ACCESSIBLE BY THE COMMON     */00121000
 /*                    PRINT MODULE                                   */00121000
 /*                 4.)IT IS POSSIBLE TO CALL INTERPRETER SUBSEQUENTLY*/00121000
 /*                    WITH DIFFERENT RULES / ALL USERVARIABLES WILL  */00121000
 /*                    BE KEPT DURING ONE TRANSACTION STEP            */00121000
 /* OUTPUT       : MODIFIED TABLE STRUCTURES & USERVARIABLES          */00126000
 /* AUTHOR       : G.STROBL                                           */00140000
 /* DATE         : 87/03/31                                           */00160000
 /* PARAMETERS   : NONE                                               */00180000
 /* HISTORY                                                           */
 /*  88-04-12 SG : RULLINE SCAN UP TO POS 60 CORRECTED                */
 /*  88-04-11 GF : STATUS END PILOT TEST                              */
 /*********************************************************************/00240000
 /*>>> PROCESSED BY MACRO HDRPAGE1 <<<*/
 %INCLUDE QCH##PAD;
 %INCLUDE QCH##EPS;
1QCHINTM :
   PROC ($$USPAPTR) REORDER;
   #MODIDENT(QCHINTM);
   %DCL DRIVER_VECTOR CHAR;
   %DRIVER_VECTOR = 'SP.DRIVER_VECTOR';
   %ACT DRIVER_VECTOR NORESCAN;
   %INCLUDE QCHDEPS;
   %DEACT DRIVER_VECTOR;
   CALL SP.DEBUG_EXIT ('INTM START');
   /*---
   ---*/
1/********************************************************************/
 /****     THE DECLARATION OF THE SDTM PROVIDED USER SPA AREAS    ****/
 /********************************************************************/
0  DCL 1 SP BASED ($$USPAPTR), %INCLUDE QCHSPAS ; ;
0  DCL 1 SPA BASED ($$USPAPTR) LIKE SP;

   DCL 1 SPP    BASED(SP.PTRP1),
         % INCLUDE QCHPTRS ; ;

   DCL  1 SP2 BASED(SPP.PTRP2),
        %INCLUDE QCHPTR2; ;

1/********************************************************************/
 /****                   MODULE  IDENTIFICATION                   ****/
 /********************************************************************/
0  %DCL COMPILETIME BUILTIN;
   %DCL $$COMPDATE CHAR;
   %$$COMPDATE = '''' !! COMPILETIME !! '''';
   DCL 1 $$MODID_BLOCK,
         3 $$FILL1    CHAR(4)  INIT('*** '),
         3 $$MOD_NAME CHAR(8)  INIT('QCHINTM '),
         3 $$FILL2    CHAR(2)  INIT('  '),
         3 $$COM_DATE CHAR(18) INIT($$COMPDATE),
         3 $$FILL3    CHAR(4)  INIT(' ***');
1/********************************************************************/
 /****   DECLARATIONS OF PARAMETERS PASSED AND ASSOCIATED AREAS   ****/
 /********************************************************************/
0  DCL $$USPAPTR POINTER;
   DCL  $XTVTAB   POINTER            EXTERNAL        ;
1/********************************************************************/
 /****    FILES AND PREPROCESSOR FIELDS                           ****/
 /********************************************************************/
 DCL SYSPRINT FILE PRINT;
 DCL DATUM CHAR (6);
-DCL VERS CHAR(35);
1/*******************************************************************/
 /*  DECLARE BUILTIN FUNCTIONS (SORTED ALPHABETICALLY)              */
 /*******************************************************************/
-DCL(ADD     ,
     ADDR    ,
     ALL     ,
     ANY     ,
     DATE    ,
     DECIMAL ,
     DIM     ,
     DIVIDE  ,
     INDEX   ,
     MAX     ,
     MULTIPLY,
     NULL    ,
     PLIDUMP ,
     PLISRTA ,
     REPEAT  ,
     ROUND   ,
     SUBSTR  ,
     TIME    ,
     VERIFY  ) BUILTIN;
1/*******************************************************************/
 /*  DECLARE MAXIMUM VALUES FOR SEVERAL VARIABLES                   */
 /*******************************************************************/
0/********   MAXIMUM LENGTH OF A DATABASE FIELD IN THE RULES   ******/
 /********   EXAMPLE: CCO.IOPUCTY                              ******/
 DCL DBNAME_LENGTH                BIN FIXED(15) INIT(8);
0/********   MAXIMUM LENGTH OF THE RULEFIELD IN THE TABLE      ******/
 /********   QCHSTRULS                                         ******/
 DCL MAXRULELENGTH                BIN FIXED(15) INIT(60);
0/********   MAXIMUM NUMBER OF USERVARIABLES FOR A PROCESSING  ******/
 /********   STEP (MAY INCLUDE SEVERAL RULE NAMES)             ******/
 DCL MAXVARIABLES                 BIN FIXED(15) INIT(2000);
0/********   MAXIMUM NUMBER OF DATABASEVARIABLES FOR A         ******/
 /********   PROCESSING STEP (MAY INCLUDE SEVERAL RULE NAMES)  ******/
 DCL MAXDBVARIABLES               BIN FIXED(15) INIT(5000);
0/********   MAXIMUM NUMBER OF TOKENS IN A RULE SET            ******/
 DCL MAXTOKENS                    BIN FIXED(15) INIT(3000);
0/********   MAXIMUM LENGTH FOR A CHARACTER-CONSTANT           ******/
 DCL MAX_CHARACTER_FIELD_LENGTH   BIN FIXED(15) INIT(256);
0/********   MAXIMUM LENGTH FOR A NUMERIC CONSTANT             ******/
 DCL MAX_CONSTANT_LENGTH          BIN FIXED(15) INIT(15);
0/********  MAXIMUM LENGTH FOR THE NAME OF A DATABASE-VARIABLE  *****/
 /********   THIS NUMBER IS THE SUM OF:                         *****/
 /********   - DATABASE NAME  (MAXIMUM OF 8 CHARACTERS)         *****/
 /********   - POINT          (1 CHARACTER)                     *****/
 /********   - FIELD NAME     (MAXIMUM OF 8 CHARACTERS)         *****/
 DCL MAX_DBVARIABLENAME_LENGTH    BIN FIXED(15) INIT(17);
0/********  MAXIMUM NESTING LEVEL OF PARENTHESIS                *****/
 DCL MAX_PARENTHESIS_NESTING      BIN FIXED(15) INIT(2);
0/********  MAXIMUM NUMBER OF TOKENS  (SHOULD BE ENOUGH         *****/
 /********  FOR A SINGLE RULE SET OF 250 RULES)                 *****/
 DCL MAX_TOKENS                   BIN FIXED(15) INIT(999);
0/********  MAXIMUM NUMBER OF TOKENS IN A SINGLE EXPRESSION     *****/
 /********  EXAMPLE: A=B*C-D/E*F+G...;                          *****/
 DCL MAX_TOKENS_IN_EXPRESSION     BIN FIXED(15) INIT(30);
0/********  MAXIMUM NUMBER OF CHARACTERS A USERVARIABLE'S NAME  *****/
 /********  IS MADE OF  (E.G. MYUSVNAM)                         *****/
 DCL MAX_USERVARIABLENAME_LENGTH  BIN FIXED(15) INIT(8);
0/********  MAXIMUM NUMBER OF CHARACTERS A VARIABLE'S NAME      *****/
 /********  IS MADE OF  (IS IN FACT CURRENTLY THE SAME          *****/
 /********  LENGTH AS A DATABASE-VARIABLENAME, BUT MAYBE        *****/
 /********  IN SOME TIME THERE IS A REQUIREMENT TO HAVE         *****/
 /********  LONGER USERVARIABLE-NAMES)                          *****/
 DCL MAX_VARIABLENAME_LENGTH      BIN FIXED(15) INIT(17);
1/*******************************************************************/
 /*  DECLARE HELP FIELDS AND COUNTERS                               */
 /*  SORTED ALPHABETICALLY TO ALLOW FOR QUICK SEARCH                */
 /*******************************************************************/
 DCL (A,B,C,I,J,K,L,M,N,O,Q)      BIN FIXED(15) INIT(0);
 DCL ADD_TARGET                   DEC FIXED(15,4);
 DCL ASSIGNED_VARIABLE_NAME       CHAR(26);
 DCL BIFIPREC                     BIN FIXED(15) INIT(15);
 DCL BIFISCALE                    BIN FIXED(15) INIT(0);
 DCL BLANK                        BIN FIXED(15);
 DCL BLANK_POSITION               BIN FIXED(15) INIT(0);
 DCL CHARACTER_LENGTH             BIN FIXED(15) INIT(0);
 DCL CHAR_TEMP_CONTENT            CHAR(255);
 DCL CHAR_LEFT_TARGET             CHAR(255);
 DCL CHAR_RIGHT_TARGET            CHAR(255);
 DCL COMPARISON_OPERATOR          BIN FIXED(15);
 DCL COMMA_VERIFY                 BIN FIXED(15);
 DCL DATE_FIELD                   CHAR(255) INIT(' ');
 DCL DATE_HELP_FIELD              CHAR(12) INIT(' ');
 DCL DATE_FORMAT                  CHAR(255) INIT(' ');
 DCL DIGITS_MAX                   BIN FIXED(15);
 DCL DIV_TARGET                   DEC FIXED(15,4);
 DCL END_TOKEN                    BIN FIXED(15);
 DCL EXPRESSION_TOKEN             BIN FIXED(15) INIT(0);
 DCL FIRST_COMMA                  BIN FIXED(15);
 DCL FIRST_OPERAND                DEC FIXED(15,5);
 DCL FIRST_OP_TOKEN               BIN FIXED(15);
 DCL FIRST_PARENTHESIS            BIN FIXED(15);
 DCL FIRST_TOKEN                  BIN FIXED(15);
 DCL FIRST_TOKEN_IN_EXPRESSION    BIN FIXED(15) INIT(0);
 DCL FIRST_USERVARIABLE_NAME      CHAR(255);
 DCL FORMAT_ARGUMENT              CHAR(50);
 DCL FORMAT_PRECISION             BIN FIXED(15) INIT(0);
 DCL FORMAT_SCALE                 BIN FIXED(15) INIT(0);
 DCL HELP_COUNT                   BIN FIXED(15);
 DCL HELP_TARGET                  DEC FIXED(15,4);
 DCL HELP_TARGET_1                DEC FIXED(15,4);
 DCL HELP_TARGET_2                DEC FIXED(15,4);
 DCL IF_IS_OK                     BIT(1)        INIT('0'B);
 DCL IF_TOKEN                     BIN FIXED(15);
 DCL INPUT_LINE                   BIN FIXED(15) INIT ('0'B) STATIC;
 DCL LAST_PARENTHESIS             BIN FIXED(15);
 DCL LAST_TOKEN_IN_EXPRESSION     BIN FIXED(15) INIT(0);
 DCL LEFT_BLANKPOSITION           BIN FIXED(15);
 DCL LEFT_BLANK_POSITION          BIN FIXED(15) INIT(0);
 DCL LEFT_IS_CHARACTER            BIT(1);
 DCL LEFT_PARENTHESIS_COUNT       BIN FIXED(15) INIT(0);
 DCL LEFT_TARGET                  DEC FIXED(15,4);
 DCL LEFT_TARGET_SCALE            BIN FIXED(15);
 DCL LENGTH_OF_VARIABLE_NAME      BIN FIXED(15) INIT(0);
 DCL LI                           BIN FIXED(15);
 DCL LINECHAR                     CHAR(20) INIT(' ');
 DCL LOGIC(8)                     BIT(1) INIT('0'B);
 DCL LOGIC_BIT                    BIN FIXED(15);
 DCL LOGIC_OPERATOR(8)            BIT(1) INIT('0'B);
 DCL LOGIC_OPERATOR_IN_IF_STMNT   BIT(1) INIT('0'B);
 DCL LOGIC_TOKEN                  BIN FIXED(15);
 DCL MUL_TARGET                   DEC FIXED(15,2);
 DCL NEXT_CHAR                    BIN FIXED(15);
 DCL NEXT_SEMICOLON               BIN FIXED(15);
 DCL NON_BLANK_POSITION           BIN FIXED(15);
 DCL LCHAR_STRING_LENGTH          BIN FIXED(15);
 DCL CHAR_STRING_LENGTH_V         BIN FIXED(15);
 DCL CHAR_STRING_LENGTH_I         BIN FIXED(15);
 DCL NUMBER_OF_PAREN_IN_EXPR      BIN FIXED(15) INIT(0);
 DCL NUMCHAR                      CHAR(14) INIT(' ');
 DCL OFFSET_INDEX                 BIN FIXED(15) INIT(0);
 DCL OLD_TOKEN_IN_IF_STATEMENT    BIN FIXED(15);
 DCL P                            BIN FIXED(15) INIT(1);
 DCL POINTPOSITION                BIN FIXED(15);
 DCL POINT_POSITION               BIN FIXED(15) INIT(0);
 DCL RIGHT_BLANKPOSITION          BIN FIXED(15);
 DCL RIGHT_BLANK_POSITION         BIN FIXED(15) INIT(0);
 DCL RIGHT_PARENTHESIS_COUNT      BIN FIXED(15) INIT(0);
 DCL RIGHT_TARGET                 DEC FIXED(15,4);
 DCL RIGHT_TARGET_SCALE           BIN FIXED(15);
 DCL ROUND_DIGIT                  BIN FIXED(15);
 DCL ROUND_USERVARIABLE_NAME      CHAR(8);
 DCL ROUND_VALUE                  DEC FIXED(15,4);
 DCL ROUNDED_VALUE                DEC FIXED(15,4);
 DCL ROUNDED_LEFT_TARGET          DEC FIXED(15,4);
 DCL ROUNDED_RIGHT_TARGET         DEC FIXED(15,4);
 DCL RULE                         CHAR(60);
 DCL RULECHAR                     CHAR(1);
 DCL SAVE_FIRST_TOKEN             BIN FIXED(15);
 DCL SAVE_I                       BIN FIXED(15);
 DCL SAVE_TOKEN_IN_IF_STATEMENT   BIN FIXED(15);
 DCL SCALE_ADD                    BIN FIXED(15);
 DCL SCALE_MAX                    BIN FIXED(15);
 DCL SECOND_COMMA                 BIN FIXED(15);
 DCL SECOND_OPERAND               DEC FIXED(15,4);
 DCL SECOND_OP_TOKEN              BIN FIXED(15);
 DCL SECOND_USERVARIABLE_NAME     CHAR(8);
 DCL SF_TOKEN                     BIN FIXED(15);
 DCL SHIFT                        BIN FIXED(15) INIT(0);
 DCL SUB_TARGET                   DEC FIXED(15,4);
 DCL SUBSTR_ARGUMENT              CHAR(50);
 DCL SUBSTRING_LENGTH             BIN FIXED(15) INIT(0);
 DCL SUBSTRING_STARTPOS           BIN FIXED(15) INIT(0);
 DCL TARGET                       DEC FIXED(15,4);
 DCL TOKEN                        BIN FIXED(15) INIT(0);
 DCL TOKENS_IN_STATEMENT          BIN FIXED(15) INIT(0);
 DCL TOKEN_IN_IF_STATEMENT        BIN FIXED(15) INIT(0);
 DCL TYPE_CONVERSION              BIT(1) INIT('0'B);
 DCL USV_COUNT                    BIN FIXED(15);
 DCL VARIABLE                     BIN FIXED(15) INIT(0);
 DCL VARIABLE_END_POSITION        BIN FIXED(15) INIT(0);
1/*******************************************************************/
 /*  DECLARE POINTERS                                               */
 /*******************************************************************/
0/*********   POINTER TO CHARACTER-FIELDS                    ********/
 DCL CHARACTER_PTR                POINTER;
 DCL CHAR_PTR                     POINTER;
0/*********   POINTER TO DECIMAL-FIXED-FIELDS                ********/
 DCL DECFIXED_PTR                 POINTER;
0/*********   POINTER TO THE ACTUAL ACCESSED FIELD           ********/
 /*********   (NORMALLY HAS THE ADDRESS OF THE OFFSET-TABLE  ********/
 /*********    POINTER PLUS THE VARIABLES'S OFFSET)          ********/
 DCL OFFSET_POINTER               POINTER;
0/*********   POINTER TO THE BEGINNING OF THE OFFSET-TABLE   ********/
 DCL OFFSET_TABLE_POINTER         POINTER;
0/*********   POINTER TO THE STRUCTURES                      ********/
 DCL STRUCTURE_POINTER            POINTER;
1/*******************************************************************/
 /*  DECLARE FIELDS FOR TYPE-CHECKING                               */
 /*******************************************************************/
0DCL ALPHANUMERIC CHAR(36) INIT('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');
 DCL ALPHABETIC   CHAR(26) INIT('ABCDEFGHIJKLMNOPQRSTUVWXYZ');
 DCL NUMERIC      CHAR(11) INIT('0123456789.');
 DCL DIGITS       CHAR(10) INIT('0123456789');
 DCL DEC_NUMERIC  CHAR(14) INIT(' 0123456789.-+');
 DCL APOSTROPHE   CHAR(1)  INIT('''');
1/*******************************************************************/
 /*  DECLARE ARRAYS                                                 */
 /*******************************************************************/
-/*******************************************************************/
 /*  OFFSET-TABLE IS USED TO POSITION A POINTER TO THE CORRECT      */
 /*  OFFSET OF A CERTAIN DATABASE FIELD AS A VALUE FROM THE         */
 /*  BEGINNING OF A DATABASE-STRUCTURE (AS DEFINED IN THE TABLE     */
 /*  QCHSTSTR)                                                      */
 /*******************************************************************/
 /*--- WE HAVE DB-REC'S LONGER THAN 500 ---
0DCL OFFSET_TABLE(500) CHAR(1) BASED(OFFSET_TABLE_POINTER);
 --- GF ---*/
0DCL OFFSET_TABLE(32766) CHAR(1) BASED(OFFSET_TABLE_POINTER);
-/*******************************************************************/
 /*  SFARRAY IS USED TO HOLD THE RULES' CONTENT WHERE THE VARIABLES */
 /*  ARE ALREADY REPLACED WITH THE ACTUAL VALUES (THIS IS VALID FOR */
 /*  USER VARIABLES AS WELL AS DATABASE VARIABLES)                  */
 /*******************************************************************/
0/*******************************************************************/
 /*  THE CONTENT OF 'SFARRAY' IS AS FOLLOWS -                       */
 /*  * VAR_TYPE: THESE BIT FIELDS ARE SET EXCLUSIVELY (I.E.         */
 /*              ONLY TWO BITS OF THEM ARE SET TO '1'B, ALL         */
 /*              OTHERS ARE '0'B) AND SHOW THE TYPE OF TOKEN        */
 /*              EXAMPLE: IF THE TOKEN IS A USER VARIABLE           */
 /*              WHICH HAS A DECIMAL-FIXED-VALUE, THE BITS ARE      */
 /*              SET AS FOLLOWS:                                    */
 /*                  DB_VARIABLE.... '0'B                           */
 /*                  USER_VARIABLE.. '1'B                           */
 /*                  TEMP_FIELD..... '0'B                           */
 /*                  CONSTANT....... '0'B                           */
 /*                  CHARACTER...... '0'B                           */
 /*                  BIN_FIXED...... '0'B                           */
 /*                  DEC_FIXED...... '1'B                           */
 /*                  PARENTHESIS.... '00'B                          */
 /*                  OPERATOR....... '0000'B                        */
 /*                  LOGIC_OPERATOR. '00'B                          */
 /*  * CALCULATION_FIELD: THESE FIELDS CONTAIN THE REAL VALUES      */
 /*              RETRIEVED FROM THE DATABASE TABLES OR THE          */
 /*              INTERNAL USERVARIABLE-TABLE. THE FIELDS ARE        */
 /*              FILLED CORRESPONDING TO THE BITS SET IN THE        */
 /*              FIELD VAR_TYPE DESCRIBED ABOVE (TO FOLLOW          */
 /*              THE PREVIOUS EXAMPLE, THE FIELD DEC_FIXED WILL     */
 /*              BE FILLED WITH THE RETRIEVED DECIMAL-FIXED FIELD,  */
 /*              ALL OTHER FIELDS HAVE A ZERO VALUE)                */
 /*  * PRECISION: THESE FIELDS CONTAIN THE NUMBER OF DIGITS BEFORE  */
 /*              AND AFTER THE DECIMAL POINT:                       */
 /*            - 'DIGITS' CONTAINS THE NUMBER OF DIGITS FOR THE     */
 /*              WHOLE VARIABLE (INCLUDING DIGITS AFTER THE DECIMAL */
 /*              POINT). IT IS EQUAL TO THE NUMBER OF VALID         */
 /*              CHARACTERS IN A CHARACTER FIELD (NOTE THAT THE     */
 /*              FIELD 'CALCULATION_FIELD.CHAR_FIELD' ITSELF HAS    */
 /*              A LENGTH OF 255 CHARACTERS, WHICH IS THE DEFINED   */
 /*              MAXIMUM LENGTH OF CHARACTER CONSTANTS AND          */
 /*              VARIABLES.                                         */
 /*            - 'SCALE' CONTAINS THE NUMBER OF DIGITS AFTER THE    */
 /*              DECIMAL POINT (THIS FIELD IS TYPICALLY ZERO IN     */
 /*              CASE THE VARIABLE IS OF TYPE 'CHARACTER')          */
 /*******************************************************************/
0DCL 1 SFARRAY(MAX_TOKENS_IN_EXPRESSION),
       2 VAR_TYPE,
         3 DB_VARIABLE             BIT(1)         INIT('0'B),
         3 USER_VARIABLE           BIT(1)         INIT('0'B),
         3 TEMP_FIELD              BIT(1)         INIT('0'B),
         3 CONSTANT                BIT(1)         INIT('0'B),
         3 CHARACTER               BIT(1)         INIT('0'B),
         3 BIN_FIXED               BIT(1)         INIT('0'B),
         3 DEC_FIXED               BIT(1)         INIT('0'B),
         3 PARENTHESIS             BIT(2)         INIT('00'B),
           /**************************************************/
           /*  4 LEFT_PARENTHESIS  BIT(1)         INIT('0'B),*/
           /*  4 RIGHT_PARENTHESIS BIT(1)         INIT('0'B),*/
           /**************************************************/
         3 OPERATOR                BIT(4)         INIT('0000'B),
           /**************************************************/
           /*  4 MULTIPLY         BIT(1)         INIT('0'B), */
           /*  4 DIVIDE           BIT(1)         INIT('0'B), */
           /*  4 SUBTRACT         BIT(1)         INIT('0'B), */
           /*  4 ADD              BIT(1)         INIT('0'B), */
           /**************************************************/
         3 LOGIC_OPERATOR          BIT(2)         INIT('00'B),
           /**************************************************/
           /*  4 AND              BIT(1)         INIT('0'B), */
           /*  4 OR               BIT(1)         INIT('0'B), */
           /**************************************************/
       2 CALCULATION_FIELD,
         3 BIN_FIELD               BIN FIXED(15),
         3 CHAR_FIELD              CHAR(255),
         3 DEC_FIELD               DECIMAL FIXED(15,3),
       2 PRECISION,
         3 DIGITS                  BIN FIXED(15)  INIT(0),
         3 SCALE                   BIN FIXED(15)  INIT(0);

   DCL  TRC_TXT      CHAR      (150  )      VAR      ;

     %INCLUDE QCHNOTM; ;
     %INCLUDE QCHUTLD;

     DCL  1 BAT BASED(SP.BATP1),      %INCLUDE QCHBATS; ;
     DCL  1 CON BASED(SP.CONP1),      %INCLUDE QCHCONS; ;
     DCL  1 NOT BASED(SP.NOTP1),      %INCLUDE QCHNOTS; ;

0DO I=1 TO MAX_TOKENS_IN_EXPRESSION;
    SFARRAY.CALCULATION_FIELD.BIN_FIELD(I)   = 0;
    SFARRAY.CALCULATION_FIELD.DEC_FIELD(I)   = 0;
    SFARRAY.CALCULATION_FIELD.CHAR_FIELD(I)  = ' ';
 END;
1/*******************************************************************/
 /*  USER_VARS IS USED TO HOLD THE NAMES AND VALUES OF THE USER     */
 /*  VARIABLES DEFINED BY THE USER IN THE RULES. THEY ARE BASED     */
 /*  ON A SPA POINTER IN ORDER TO SURVIVE SEVERAL CALLS IN A SET    */
 /*  OF RULES. IN ADDITION, THEY ARE ACCESSED BY THE PRINTER        */
 /*  MODULE.                                                        */
 /*******************************************************************/
0/*******************************************************************/
 /*  THE CONTENT OF 'SFARRAY' IS AS FOLLOWS -                       */
 /*  * NAME: THIS IS THE USER-VARIABLE'S NAME                       */
 /*  * TYPE: HERE WE FIND THE USERVARIABLE'S TYPE                   */
 /*          (CHARACTER OR DECIMAL FIXED)                           */
 /*  * CONTENT: THIS FIELDS ARE FILLED CORRESPONDING TO THE BIT     */
 /*          SET IN THE FIELD 'TYPE' DESCRIBED ABOVE                */
 /*  * LENGTH: THESE FIELDS CONTAIN THE NUMBER OF DIGITS BEFORE     */
 /*            AND AFTER THE DECIMAL POINT:                         */
 /*            - 'PRECISION' CONTAINS THE NUMBER OF DIGITS FOR THE  */
 /*              WHOLE VARIABLE (INCLUDING DIGITS AFTER THE DECIMAL */
 /*              POINT). IT IS EQUAL TO THE NUMBER OF VALID         */
 /*              CHARACTERS IN A CHARACTER FIELD (NOTE THAT THE     */
 /*              FIELD 'CONTENT.CHARACTER' ITSELF HAS               */
 /*              A LENGTH OF 255 CHARACTERS, WHICH IS THE DEFINED   */
 /*              MAXIMUM LENGTH OF CHARACTER CONSTANTS AND          */
 /*              VARIABLES.                                         */
 /*            - 'SCALE' CONTAINS THE NUMBER OF DIGITS AFTER THE    */
 /*              DECIMAL POINT (THIS FIELD IS TYPICALLY ZERO IN     */
 /*              CASE THE VARIABLE IS OF TYPE 'CHARACTER')          */
 /*  * FORMAT:   THESE FIELDS CONTAIN THE NECESSARY DATA TO PROCESS */
 /*              A 'FORMAT' STATEMENT WITHIN THE RULES              */
 /*            - 'APPLY' IS THE INDICATOR WHETHER THE FOLLOWING TWO */
 /*              FIELDS HAVE TO BE RECOGNIZED BY THE PRINTER MODULE */
 /*              (A VALUE OF '1'B MEANS 'YES')                      */
 /*            - 'PRECISION' CONTAINS THE NUMBER OF DIGITS FOR THE  */
 /*              WHOLE VARIABLE TO BE PRINTED ON THE CORRESPINDING  */
 /*              FORM (INCLUDING DIGITS AFTER THE DECIMAL           */
 /*              POINT). IT IS EQUAL TO THE NUMBER OF VALID         */
 /*              CHARACTERS IN A CHARACTER FIELD (NOTE THAT THE     */
 /*              FIELD 'FORMAT.CHARACTER' ITSELF HAS                */
 /*              A LENGTH OF 255 CHARACTERS, WHICH IS THE DEFINED   */
 /*              MAXIMUM LENGTH OF CHARACTER CONSTANTS AND          */
 /*              VARIABLES.                                         */
 /*            - 'SCALE' CONTAINS THE NUMBER OF DIGITS AFTER THE    */
 /*              DECIMAL POINT (THIS FIELD IS TYPICALLY ZERO IN     */
 /*              CASE THE VARIABLE IS OF TYPE 'CHARACTER')          */
 /*******************************************************************/
-DCL 1 USER_VARS(2000) BASED(SP.USERVAR_PTR),
       %INCLUDE QCHUSVS;;
1/*******************************************************************/
 /*  USER_VARS_PRINT IS USED FOR PRINTING/TRACING THE ACTUAL        */
 /*  INTERPRETER ACTION. IT IS NECESSARY TO ALLOW FOR COMPLETE      */
 /*  PRINTING OF THE USER_VARS ARRAY BY A SINGLE 'PUT DATA'-        */
 /*  STATEMENT.                                                     */
 /*******************************************************************/
-DCL 1 USER_VARS_PRINT(2000),
       %INCLUDE QCHUSVS;;
1/*******************************************************************/
 /*  HERE WE INITIALISE THE FIRST ARRAY ELEMENT. ONLY ONE FIELD     */
 /*  IS ACTUALLY USED: THE VARIABLE LENGHT.PRECISION HOLDS THE      */
 /*  CURRENT NUMBER OF ALLOCATED USER_VARIABLES AND IS USED BOTH    */
 /*  BY THE INTERPRETER AND THE PRINTER MODULE (NOTE THAT THE       */
 /*  ACTUAL NUMBER OF USER_VARIABLES IS THE FIELDS' CONTENT MINUS   */
 /*  ONE...)                                                        */
 /*  IF THE FIELDS' CONTENT IS ZERO, WE ARE CALLED FOR THE FIRST    */
 /*  TIME... AND SET THE FIELD TO '1'.                              */
 /*******************************************************************/
0USER_VARS.NAME(1)='';
 PUT SKIP EDIT(REPEAT('-',71))(A);
 DCL USV_MAX      BIN FIXED(15);
 IF USER_VARS.LENGTH.PRECISION(1)=0 THEN DO;
    USV_MAX=1;
    PUT SKIP EDIT('FIRST VARIABLE ')(A);
 END;
 ELSE DO;
    USV_MAX = USER_VARS.LENGTH.PRECISION(1);
 END;
 PUT SKIP EDIT('NO OF VARIABLES ',USV_MAX)(A);
 PUT SKIP EDIT(REPEAT('-',71))(A);
1/*******************************************************************/
 /*  VARTABLE IS THE ARRAY WHICH HOLDS THE CONTENTS OF THE DB2      */
 /*  TABLE CALLED QCHSTSTR. THE ACTUAL READING OF THE DB2 TABLE     */
 /*  IS DONE BY THE CHIS DRIVER MODULE AND PASSED TO THE            */
 /*  INTERPRETER VIA A LINKED LIST OF STRUCTURES (SEE THE ACTUAL    */
 /*  ASSIGNMENT STATEMENTS BELOW).                                  */
 /*  VARTABLE IS USED TO ACCESS THE ACTUAL DATABASE FIELDS          */
 /*  BY OVERLAYING THE APPROPRIATE LOCATION IN MEMORY WITH THE      */
 /*  DEFINITION OF A CERTAIN FIELD AS SPECIFIED IN THE RULES.       */
 /*  THE ACTUAL LOCATION IS CALCULATED USING THE OFFSET OF THE      */
 /*  DATABASE VARIABLE TO THE BEGIN OF THE STRUCTURE IN WHICH       */
 /*  IT IS DECLARED.                                                */
 /*******************************************************************/
0/*******************************************************************/
 /*  THE CONTENT OF 'VARTABLE' IS AS FOLLOWS -                      */
 /*  * STRUCTURE_NAME: THIS IS THE NAME OF THE CHIS DATABASE        */
 /*          (NOTE THAT THE FIELD IS DEFINED AS 18 CHARACTERS       */
 /*          LONG ALTHOUGH CHIS DATABASE NAMES ARE ACTUALLY SHORTER */
 /*          - THE INTERPRETER MAY ALSO BE USED FOR NON-CHIS        */
 /*          DATABASES IN THE FUTURE)                               */
 /*  * VARIABLE_NAME: THIS IS THE VARIABLE'S NAME AS DEFINED IN     */
 /*          THE DB2 TABLE                                          */
 /*  * TYPE: HERE WE FIND THE VARIABLE'S TYPE. IT MAY BE CHARACTER  */
 /*          VARCHAR OR DECIMAL FIXED ('C','V' OR 'D').             */
 /*  * LENGTH: THESE FIELDS CONTAIN THE NUMBER OF DIGITS BEFORE     */
 /*            AND AFTER THE DECIMAL POINT:                         */
 /*            - 'PRECISION' CONTAINS THE NUMBER OF DIGITS FOR THE  */
 /*              WHOLE VARIABLE (INCLUDING DIGITS AFTER THE DECIMAL */
 /*              POINT). IT IS EQUAL TO THE NUMBER OF VALID         */
 /*              CHARACTERS IN A CHARACTER FIELD (NOTE THAT THE     */
 /*              FIELD 'CONTENT.CHARACTER' ITSELF HAS               */
 /*              A LENGTH OF 255 CHARACTERS, WHICH IS THE DEFINED   */
 /*              MAXIMUM LENGTH OF CHARACTER CONSTANTS AND          */
 /*              VARIABLES.                                         */
 /*            - 'SCALE' CONTAINS THE NUMBER OF DIGITS AFTER THE    */
 /*              DECIMAL POINT (THIS FIELD IS TYPICALLY ZERO IN     */
 /*              CASE THE VARIABLE IS OF TYPE 'CHARACTER')          */
 /*  * OFFSET: THIS FIELD CONTAINS THE ACTUAL OFFSET OF THE         */
 /*          VARIABLE'S CONTENT TO THE BEGINNING OF THE DATABASE    */
 /*          TABLE STRUCTURE                                        */
 /*******************************************************************/
-DCL 1 VARTABLE(MAXDBVARIABLES),
       2 STRUCTURE_NAME        CHAR(18),
       2 VARIABLE_NAME         CHAR(8),
       2 TYPE                  CHAR(1),
       2 LENGTH,
         3 PRECISION           BIN FIXED(15),
         3 SCALE               BIN FIXED(15),
       2 OFFSET                BIN FIXED(31);
1/*******************************************************************/
 /*  RULEARRAY IS THE ARRAY WHICH HOLDS THE ACTUALLY PARSED TOKENS  */
 /*  BEFORE THEIR CONTENTS ARE EVALUATED. AFTER THE PARSING AND     */
 /*  LEXICAL ANALYSIS STEPS, THE INTERPRETER WORKS WITH THE         */
 /*  RULEARRAY AS THE BASIC INFORMATION SOURCE.                     */
 /*******************************************************************/
0/*******************************************************************/
 /*  THE CONTENT OF 'RULEARRAY' IS AS FOLLOWS -                     */
 /*  * LINENUMBER: THIS IS THE LINENUMBER OF THE RULE SOURCE        */
 /*          IN WHICH THE CURRENT TOKEN IS TO BE FOUND. THIS FIELD  */
 /*          IS IMPORTANT FOR ALL INTERPRETER ERROR MESSAGES AS IT  */
 /*          ALLOWS TO REPORT THE LINE IN ERROR.                    */
 /*  * BIT FIELDS: THE FOLLOWING BIT FIELDS DESCRIBE THE TYPE OF    */
 /*          TOKEN (THEY ARE SET SET '1'B IF TRUE).                 */
 /*    - DB_VARIABLE....THE TOKEN IS A DB2 DATABASE VARIABLE WHOSE  */
 /*                     NAME IS TO BE FOUND IN THE 'CONTENT' FIELD  */
 /*    - USER_VARIABLE..THE TOKEN IS A USER VARIABLE WHOSE          */
 /*                     NAME IS TO BE FOUND IN THE 'CONTENT' FIELD  */
 /*    - ASSIGNMENT.....THE TOKEN IS AN ASSIGNENT OPERATOR ('=')    */
 /*    - SEMICOLON......THE TOKEN IS A SEMICOLON WHICH ENDS A       */
 /*                     STATEMENT                                   */
 /*    - MATH_OPERATOR..THE TOKEN IS A ONE OF THE FOLLOWING         */
 /*                     MATHEMATICAL OPERATORS (*-+/) WHICH IS TO   */
 /*                     BE FOUND IN THE 'CONTENT' FIELD             */
 /*    - LOGIC_OPERATOR.THE TOKEN IS A LOGIC OPERATOR (ONLY 'AND'   */
 /*                     AND 'OR' ARE CURRENTLY SUPPORTED) WHICH     */
 /*                     IS TO BE FOUND IN THE 'CONTENT' FIELD       */
 /*    - COMPARISON.....THE TOKEN IS A COMPARISON OPERATOR          */
 /*                     (>,<,>=,<=,^=) WHICH IS TO BE FOUND IN THE  */
 /*                     'CONTENT' FIELD                             */
 /*    - KEYWORD........THE TOKEN IS A RULE LANGUAGE KEYWORD OTHER  */
 /*                     THAN A FUNCTION NAME (E.G. 'IF', 'THEN' OR  */
 /*                     'ELSE') TO BE FOUND IN THE 'CONTENT' FIELD  */
 /*    - FUNCTION.......THE TOKEN IS A RULE LANGUAGE FUNCTION       */
 /*                     (FORMAT, SUBSTRING, DATE) WHOSE             */
 /*                     NAME IS TO BE FOUND IN THE 'CONTENT' FIELD  */
 /*    - CONSTANT.......THE TOKEN IS A NUMERIC                      */
 /*                     CONSTANT DEFINED IN THE RULES WHICH IS TO   */
 /*                     BE FOUND IN THE 'CONTENT' FIELD             */
 /*    - TEXT...........THE TOKEN IS A CHARACTER CONSTANT DEFINED   */
 /*                     IN THE RULES WHOSE                          */
 /*                     NAME IS TO BE FOUND IN THE 'CONTENT' FIELD  */
 /*                     (NOTE THAT THE FIELD 'TEXTLENGHT' IS FILLED */
 /*                     WITH THE ACTUAL LENGTH OF THE CONSTANT)     */
 /*    - LEFT_PARENTHESIS....THE TOKEN IS A LEFT PARENTHESIS        */
 /*    - RIGHT_PARENTHESIS...THE TOKEN IS A LEFT PARENTHESIS        */
 /*  * TEXTLENGTH: THIS FIELD CONTAINS THE LENGTH OF THE CHARACTER  */
 /*          CONSTANT DEFINED IN THE RULES. IT IS NECESSARY BECAUSE */
 /*          A RULE MAY DEFINE A USERVARIABLE TO HOLD SEVERAL       */
 /*          SPACES WITHOUT ANY OTHER CHARACTERS IN WHICH CASE      */
 /*          IT IS NOT POSSIBLE TO ACCESS THE SPECIFIED NUMBER      */
 /*          OF SPACES IN THE FIELD 'CONTENT' AFTER THE PARSING AND */
 /*          LEXICAL ANLYSIS STEPS.                                 */
 /*******************************************************************/
-DCL 1 RULEARRAY(MAXTOKENS),                      /* EXAMPLES:      */
       2 LINENUMBER        BIN FIXED(15) INIT(0), /* LINE# OF STMNT */
       2 DB_VARIABLE       BIT(1)    INIT('0'B),  /* CUSTOMERNUMBER */
       2 USER_VARIABLE     BIT(1)    INIT('0'B),  /* TTOTAL         */
       2 ASSIGNMENT        BIT(1)    INIT('0'B),  /* =              */
       2 SEMICOLON         BIT(1)    INIT('0'B),  /* ;              */
       2 MATH_OPERATOR     BIT(1)    INIT('0'B),  /* *-+/           */
       2 LOGIC_OPERATOR    BIT(1)    INIT('0'B),  /* AND, OR        */
       2 COMPARISON        BIT(1)    INIT('0'B),  /* =,>,<,>=,<=,^= */
       2 KEYWORD           BIT(1)    INIT('0'B),  /* IF, THEN       */
       2 FUNCTION          BIT(1)    INIT('0'B),  /* FORMAT, SUBSTR */
       2 CONSTANT          BIT(1)    INIT('0'B),  /* 3.1428659265   */
       2 TEXT              BIT(1)    INIT('0'B),  /* 'NOCHARGE'     */
       2 LEFT_PARENTHESIS  BIT(1)    INIT('0'B),  /* (              */
       2 RIGHT_PARENTHESIS BIT(1)    INIT('0'B),  /* )              */
       2 TEXTLENGTH        BIN FIXED(15) INIT(0), /* LENGTH OF TEXT */
       2 CONTENT           CHAR(80)  INIT(' ');   /*                */
1/*******************************************************************/
 /*  DECLARE CTL STRCUTURE (USED FOR SYSTEM VARIABLES CHARACTER)    */
 /*******************************************************************/
 DCL 1 CTL BASED(SP.CTLP1),
 %INCLUDE QCHCTLS;;
1/*******************************************************************/
 /*  START OF THE MAINLINE                                          */
 /*******************************************************************/
-/*******************************************************************/
 /*  INCLUDE PUT STATEMENT PREPROCESSOR                             */
 /*******************************************************************/
 %INCLUDE QCHINTP;;
 OPEN FILE (SYSPRINT);
-UPSK('RULE PROCESSED =',SP.RULE_NAME);
-/*******************************************************************/
 /*  GET STRUCTURE INFORMATION READ BY DRIVER MODULE AND PUT THEM   */
 /*  INTO THE INTERPRETER'S VARTABLE ARRAY                          */
 /*******************************************************************/
 DCL S         POINTER;
 DCL V_COUNT      BIN FIXED(15) INIT(0);
 DCL 1 INT_STRUC  BASED (S),
       2 NEXT    POINTER,
       2 DATA,
         %INCLUDE QCHSTRS;;
 DO S = SP.INT_STRUCS
    REPEAT INT_STRUC.NEXT
    WHILE (S ^= NULL &
           SP.RC = 0);
    V_COUNT = V_COUNT + 1;
    VARTABLE.STRUCTURE_NAME(V_COUNT)   = INT_STRUC.STRUCNAM;
    VARTABLE.VARIABLE_NAME(V_COUNT)    = INT_STRUC.VARNAME;
    VARTABLE.TYPE(V_COUNT)             = INT_STRUC.VARTYPE;
    VARTABLE.LENGTH.PRECISION(V_COUNT) = INT_STRUC.VARLDIGI;
    VARTABLE.LENGTH.SCALE(V_COUNT)     = INT_STRUC.VARLSCAL;
    VARTABLE.OFFSET(V_COUNT)           = INT_STRUC.VAROFFST;
 END;
 CALL SP.DEBUG_EXIT ('STRUCS INPUT');
1/*******************************************************************/
 /*  GET RULES VIA SPA-POINTER FROM QCHRULS                         */
 /*******************************************************************/
 DCL R         POINTER;
 DCL 1 INT_RULE  BASED (R),
       2 NEXT    POINTER,
       2 DATA,
         %INCLUDE QCHRULS;;
 UPSK('INTM RULES INPUT:');
 DO R = SP.INT_RULES
    REPEAT INT_RULE.NEXT
    WHILE (R ^= NULL &
           SP.RC = 0);
    PUT SKIP EDIT (INT_RULE.DATA) ( 5 (A,X(1)), 2 F(6));
    RULE = INT_RULE.RULE;
0/*******************************************************************/
 /*  SET THE RULE'S LINE NUMBER FOR LATER ERROR MESSAGE             */
 /*******************************************************************/
    INPUT_LINE = INT_RULE.LINENBR;
0/*******************************************************************/
 /*  IF THE LINE IS NOT A COMMENT-LINE, ANALYSE IT...               */
 /*******************************************************************/
    IF SUBSTR(RULE,1,1)^='*' THEN
       CALL LEXICAL_ANALYSIS;
 END;
 CALL SP.DEBUG_EXIT ('RULES INPUT');
 UPSK ('END OF RULES INPUT.');
0CALL SYNTAX_CHECK;
 CALL SP.DEBUG_EXIT ('SYNTAX_CHECK');
0CALL INTERPRET_TOKEN;
 CALL SP.DEBUG_EXIT ('INTERPRET_TOKEN');
1/*******************************************************************/
 /*  ASSIGN THE USER VARIABLES ARRAY TO AN EQUIVALENT ONE           */
 /*  AND PRODUCE A DUMP                                             */
 /*******************************************************************/
 ABEND: PUT SKIP LIST('INTERPRETER ENDED');
   USER_VARS.LENGTH.PRECISION(1)=USV_MAX;
   DO I=2 TO USV_MAX+1;
    USER_VARS_PRINT(I) = '';
    USER_VARS_PRINT(I) = USER_VARS(I), BY NAME;
      PUT DATA(USER_VARS_PRINT(I));
 END;
 CLOSE FILE (SYSPRINT);
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE READS THE RULE AND DISCARDS ALL       */
 /*            BLANKS FOUND AS LONG AS THEY ARE NOT REQUIRED TO     */
 /*            SEPARATE TOKENS                                      */
 /*******************************************************************/
0LEXICAL_ANALYSIS: PROCEDURE;
0/*******************************************************************/
 /*  DO A LOOP OVER ALL CHARACTERS WITHIN A RULE LINE AND CALL      */
 /*  THE PROCEDURE WHICH FURTHER ANALYSES AND CATEGARISES THE       */
 /*  SINGLE CHARACTER (NOTE THAT THE CHARACTER INDEX 'I' MAY        */
 /*  BE INCREASED IN THE SUBPROCEDURES WHENEVER A KEYWORD,          */
 /*  FUNCTION OR CONSTANT IS FOUND)                                 */
 /*******************************************************************/
 DO I=1 TO MAXRULELENGTH;
    RULECHAR = SUBSTR(RULE,I,1);
    IF RULECHAR ^= ' ' THEN DO;
       CALL CATEGORISE;
       END;
 END;
 END LEXICAL_ANALYSIS;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE ANALYZES THE RULE CHARACTER AND PUTS  */
 /*            AN APPROPRIATE TOKEN INTO THE 'RULEARRAY'            */
 /*******************************************************************/
0CATEGORISE: PROCEDURE;
0/*******************************************************************/
 /*  THERE ARE FOUR TYPE OF RULE CHARACTERS:                        */
 /*  - SYSTEM VARIABLES BEGIN WITH A PERCENT SIGN                   */
 /*  - ALPHABETIC CHARACTERS SHOW A VARIABLE                        */
 /*  - NUMERIC CHARACTERS SHOW A NUMERIC CONSTANT                   */
 /*  - SPECIAL CHARACTERS (E.G. QUOTATION MARKS) SHOW TEXT          */
 /*    CONSTANTS, COMPARISON OR MATHEMATIC OPERATORS                */
 /*******************************************************************/
 SELECT;
       /*WHEN (RULECHAR='%') CALL SYSVAR_FOUND;*/
       WHEN (RULECHAR=CTL.ISYSPS2) CALL SYSVAR_FOUND;
       WHEN (INDEX(ALPHABETIC,RULECHAR) > 0) CALL ALPHA_FOUND;
       WHEN (INDEX(NUMERIC,RULECHAR) > 0) CALL NUMERIC_FOUND;
       OTHERWISE CALL SPECIAL_CHARACTER_FOUND;
 END;
 END CATEGORISE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE HANDLES SYSTEM VARIABLES              */
 /*******************************************************************/
0SYSVAR_FOUND: PROCEDURE;
 VARIABLE_END_POSITION = VERIFY(SUBSTR(RULE,I+1,
       MAX_VARIABLENAME_LENGTH),ALPHANUMERIC);
 TOKEN = TOKEN + 1;
 RULEARRAY.DB_VARIABLE(TOKEN) = '1'B;
0/*******************************************************************/
 /*  REPLACE THE PERCENT CHARACTER WITH THE PREFIX 'SYV.'           */
 /*  THIS TURNS THE SYSTEM VARIABLE IN AN ORDINARY DATABASE         */
 /*  VARIABLE FOR THE INTERPRETER WHICH IS HANDLED LIKE ANY OTHER   */
 /*  DATABASE VARIABLE                                              */
 /*******************************************************************/
 RULEARRAY.CONTENT(TOKEN)='SYV.' !! SUBSTR(RULE,I+1,
       VARIABLE_END_POSITION - 1);
 RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
 I = I + VARIABLE_END_POSITION - 1;
0END SYSVAR_FOUND;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE ANALYZES THE ALPHABETIC CHARACTER     */
 /*            FOUND, EXTRACTS KEYWORDS, FUNCTIONS AND LOGICAL      */
 /*            OPERATORS FROM THE RULE AND                          */
 /*            INCREMENTS THE CHARACTER COUNTER 'I' ACCORDINGLY     */
 /*******************************************************************/
0ALPHA_FOUND: PROCEDURE;

 DCL CONST BIN FIXED(31) INIT(0);

 SELECT;
       WHEN ((SUBSTR(RULE,I,6) = 'RETURN') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+6,1))=0)) DO;
0           TOKEN = TOKEN + 1;
            RULEARRAY.KEYWORD(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'RETURN';
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + 5;
            END;
            /*GOTO ABEND;*/
       WHEN ((SUBSTR(RULE,I,2) = 'IF') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+2,1))=0)) DO;
0           /********************************************************/
            /*  IF THE NEXT TWO CHARACTERS MAKE UP THE STRING 'IF'  */
            /*  AND THE CHARACTER FOLLOWING THE 'IF' IS NOT         */
            /*  ALPHANUMERIC, THEN WE FOUND AN 'IF'-KEYWORD.        */
            /*  THE CHECK FOR ALPHANUMERIC ALLOWS THE USE OF THE    */
            /*  STRING 'IF' WITHIN VARIABLE NAMES (E.G. IDENTIFIER, */
            /*  KNIFE, MAFIA, IF52ND,...)                           */
            /********************************************************/
0           TOKEN = TOKEN + 1;
            RULEARRAY.KEYWORD(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'IF';
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + 1;
            END;
       WHEN ((SUBSTR(RULE,I,4) = 'THEN') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+4,1))=0)) DO;
0           /********************************************************/
            /*  SEE THE LOGIC FOR THE 'IF'-KEYWORD ABOVE FOR AN     */
            /*  EXPLANATION. IT REMAINS THE SAME FOR ALL SUBSEQUENT */
            /*  KEYWORDS THE RULE IS CHECKED FOR...                 */
            /********************************************************/
0           TOKEN = TOKEN + 1;
            RULEARRAY.KEYWORD(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'THEN';
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + 3;
            END;
       WHEN ((SUBSTR(RULE,I,2) = 'DO') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+2,1))=0)) DO;
            TOKEN = TOKEN + 1;
            RULEARRAY.KEYWORD(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'DO';
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + 1;
            END;
       WHEN ((SUBSTR(RULE,I,3) = 'END') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+3,1))=0)) DO;
            TOKEN = TOKEN + 1;
            RULEARRAY.KEYWORD(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'END';
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + 2;
            END;
       WHEN ((SUBSTR(RULE,I,3) = 'AND') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+3,1))=0)) DO;
            TOKEN = TOKEN + 1;
            RULEARRAY.LOGIC_OPERATOR(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'AND';
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + 2;
            END;
       WHEN ((SUBSTR(RULE,I,2) = 'OR') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+2,1))=0)) DO;
            TOKEN = TOKEN + 1;
            RULEARRAY.LOGIC_OPERATOR(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'OR';
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + 1;
            END;
       WHEN ((SUBSTR(RULE,I,6) = 'FORMAT') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+6,1))=0)) DO;
0           /********************************************************/
            /*  HERE WE FOUND THE 'FORMAT'-KEYWORD. FIRST WE LOOK   */
            /*  FOR THE NEXT SEMICOLON WHICH APPEARS WITHIN THE     */
            /*  RULES. IT SHOWS US THE END OF THE FORMAT-FUNCTION.  */
            /*  IN ANY CASE, WE EXPECT THE SEMICOLON TO APPEAR      */
            /*  AFTER (AT MOST) 50 CHARACTERS...                    */
            /********************************************************/
0           NEXT_SEMICOLON = INDEX(SUBSTR(RULE,I+6),';');
            FORMAT_ARGUMENT = '';
            NEXT_CHAR=0;
0           /********************************************************/
            /*  NOW WE RUN IN LOOP UNTIL THE POSITION OF THE        */
            /*  SEMICOLON ENDING THE FUNCTION TO COMPRESS THE       */
            /*  SPACES BETWEEN THE FORMAT-FUNCTION PARAMETERS       */
            /*  (E.G. THE RULE '   FORMAT   ( VARNAME ,  15  ,3) ;' */
            /*  IS COMPRESSED TO 'FORMAT(VARNAME,15,3);')           */
            /********************************************************/
0           DO BLANK=I+6 TO NEXT_SEMICOLON + 5 + I;
               IF SUBSTR(RULE,BLANK,1)^=' ' THEN DO;
                  NEXT_CHAR=NEXT_CHAR+1;
                  SUBSTR(FORMAT_ARGUMENT,NEXT_CHAR,1) =
                         SUBSTR(RULE,BLANK,1);
                  END;
            END;
0           /********************************************************/
            /*  LAST, WE PUT THE FUNCTION TOGETHER                  */
            /*  WITH ITS PARAMETERS INTO THE 'RULEARRAY' FOR LATER  */
            /*  PROCESSING...                                       */
            /********************************************************/
0           TOKEN = TOKEN + 1;
            RULEARRAY.FUNCTION(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'FORMAT' !! FORMAT_ARGUMENT;
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + NEXT_SEMICOLON + 4;
            END;
       WHEN ((SUBSTR(RULE,I,5) = 'ROUND') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+5,1))=0)) DO;
0           /********************************************************/
            /*  HERE WE FOUND THE 'FORMAT'-KEYWORD. FIRST WE LOOK   */
            /*  FOR THE NEXT SEMICOLON WHICH APPEARS WITHIN THE     */
            /*  RULES. IT SHOWS US THE END OF THE FORMAT-FUNCTION.  */
            /*  IN ANY CASE, WE EXPECT THE SEMICOLON TO APPEAR      */
            /*  AFTER (AT MOST) 50 CHARACTERS...                    */
            /********************************************************/
0           NEXT_SEMICOLON = INDEX(SUBSTR(RULE,I+5),';');
            FORMAT_ARGUMENT = '';
            NEXT_CHAR=0;
0           /********************************************************/
            /*  NOW WE RUN IN LOOP UNTIL THE POSITION OF THE        */
            /*  SEMICOLON ENDING THE FUNCTION TO COMPRESS THE       */
            /*  SPACES BETWEEN THE FORMAT-FUNCTION PARAMETERS       */
            /*  (E.G. THE RULE '   FORMAT   ( VARNAME ,  15  ,3) ;' */
            /*  IS COMPRESSED TO 'FORMAT(VARNAME,15,3);')           */
            /********************************************************/
0           DO BLANK=I+5 TO NEXT_SEMICOLON + 4 + I;
               IF SUBSTR(RULE,BLANK,1)^=' ' THEN DO;
                  NEXT_CHAR=NEXT_CHAR+1;
                  SUBSTR(FORMAT_ARGUMENT,NEXT_CHAR,1) =
                         SUBSTR(RULE,BLANK,1);
                  END;
            END;
0           /********************************************************/
            /*  LAST, WE PUT THE FUNCTION TOGETHER                  */
            /*  WITH ITS PARAMETERS INTO THE 'RULEARRAY' FOR LATER  */
            /*  PROCESSING...                                       */
            /********************************************************/
0           TOKEN = TOKEN + 1;
            RULEARRAY.FUNCTION(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'ROUND' !! FORMAT_ARGUMENT;
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + NEXT_SEMICOLON + 3;
            END;
       WHEN ((SUBSTR(RULE,I,4) = 'DATE') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+4,1))=0)) DO;
0           /********************************************************/
            /*  THE HANDLING OF THE 'DATE' BUILTIN FUNCTION IS THE  */
            /*  SAME AS FOR THE 'FORMAT' FUNCTION... SEE THE        */
            /*  DESCRIPTION ABOVE...                                */
            /********************************************************/
0           NEXT_SEMICOLON = INDEX(SUBSTR(RULE,I+4),';');
            FORMAT_ARGUMENT = '';
            NEXT_CHAR=0;
            CONST=0;
            DO BLANK=I+4 TO NEXT_SEMICOLON + 3 + I;
               IF (SUBSTR(RULE,BLANK,1)=APOSTROPHE) THEN DO;
                  IF CONST=0 THEN CONST=1;
                     ELSE CONST=0;
                  END;
               IF (CONST = 0) THEN DO;
                  IF (SUBSTR(RULE,BLANK,1)^=' ') THEN DO;
                     NEXT_CHAR=NEXT_CHAR+1;
                     SUBSTR(FORMAT_ARGUMENT,NEXT_CHAR,1) =
                           SUBSTR(RULE,BLANK,1);
                     END;
                  END;
               ELSE DO;
                  NEXT_CHAR=NEXT_CHAR+1;
                  SUBSTR(FORMAT_ARGUMENT,NEXT_CHAR,1) =
                        SUBSTR(RULE,BLANK,1);
                  END;
            END;
            TOKEN = TOKEN + 1;
            RULEARRAY.FUNCTION(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'DATE' !! FORMAT_ARGUMENT;
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + NEXT_SEMICOLON + 2;
            END;
       WHEN ((SUBSTR(RULE,I,6) = 'CONCAT') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+6,1))=0)) DO;
0           /********************************************************/
            /*  THE HANDLING OF THE 'CONCAT' BUILTIN FUNCTION IS    */
            /*  THE SAME AS FOR THE 'FORMAT' FUNCTION... SEE THE    */
            /*  DESCRIPTION ABOVE...                                */
            /********************************************************/
0           NEXT_SEMICOLON = INDEX(SUBSTR(RULE,I+6),';');
            FORMAT_ARGUMENT = '';
            NEXT_CHAR=0;
            DO BLANK=I+6 TO NEXT_SEMICOLON + 5 + I;
               IF SUBSTR(RULE,BLANK,1)^=' ' THEN DO;
                  NEXT_CHAR=NEXT_CHAR+1;
                  SUBSTR(FORMAT_ARGUMENT,NEXT_CHAR,1) =
                         SUBSTR(RULE,BLANK,1);
                  END;
            END;
            TOKEN = TOKEN + 1;
            RULEARRAY.FUNCTION(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'CONCAT' !! FORMAT_ARGUMENT;
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + NEXT_SEMICOLON + 4;
            END;
       WHEN ((SUBSTR(RULE,I,4) = 'ZERO') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+4,1))=0)) DO;
0           /********************************************************/
            /*  THE HANDLING OF THE 'ZERO'   BUILTIN FUNCTION IS    */
            /*  THE SAME AS FOR THE 'FORMAT' FUNCTION... SEE THE    */
            /*  DESCRIPTION ABOVE...                                */
            /********************************************************/
0           NEXT_SEMICOLON = INDEX(SUBSTR(RULE,I+4),';');
            FORMAT_ARGUMENT = '';
            NEXT_CHAR=0;
            DO BLANK=I+4 TO NEXT_SEMICOLON + 3 + I;
               IF SUBSTR(RULE,BLANK,1)^=' ' THEN DO;
                  NEXT_CHAR=NEXT_CHAR+1;
                  SUBSTR(FORMAT_ARGUMENT,NEXT_CHAR,1) =
                         SUBSTR(RULE,BLANK,1);
                  END;
            END;
            TOKEN = TOKEN + 1;
            RULEARRAY.FUNCTION(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'ZERO' !! FORMAT_ARGUMENT;
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + NEXT_SEMICOLON + 2;
            END;
       WHEN ((SUBSTR(RULE,I,9) = 'CHARACTER') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+9,1))=0)) DO;
0           /********************************************************/
            /*  THE HANDLING OF THE 'CHARACTER'      FUNCTION IS    */
            /*  THE SAME AS FOR THE 'FORMAT' FUNCTION... SEE THE    */
            /*  DESCRIPTION ABOVE...                                */
            /********************************************************/
0           NEXT_SEMICOLON = INDEX(SUBSTR(RULE,I+9),';');
            FORMAT_ARGUMENT = '';
            NEXT_CHAR=0;
            DO BLANK=I+9 TO NEXT_SEMICOLON + 8 + I;
               IF SUBSTR(RULE,BLANK,1)^=' ' THEN DO;
                  NEXT_CHAR=NEXT_CHAR+1;
                  SUBSTR(FORMAT_ARGUMENT,NEXT_CHAR,1) =
                         SUBSTR(RULE,BLANK,1);
                  END;
            END;
            TOKEN = TOKEN + 1;
            RULEARRAY.FUNCTION(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'CHARACTER' !! FORMAT_ARGUMENT;
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + NEXT_SEMICOLON + 7;
            END;
       WHEN ((SUBSTR(RULE,I,10) = 'LCHARACTER') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+10,1))=0)) DO;
0           /********************************************************/
            /*  THE HANDLING OF THE 'LCHARACTER'     FUNCTION IS    */
            /*  THE SAME AS FOR THE 'FORMAT' FUNCTION... SEE THE    */
            /*  DESCRIPTION ABOVE...                                */
            /********************************************************/
0           NEXT_SEMICOLON = INDEX(SUBSTR(RULE,I+10),';');
            FORMAT_ARGUMENT = '';
            NEXT_CHAR=0;
            DO BLANK=I+10 TO NEXT_SEMICOLON + 9 + I;
               IF SUBSTR(RULE,BLANK,1)^=' ' THEN DO;
                  NEXT_CHAR=NEXT_CHAR+1;
                  SUBSTR(FORMAT_ARGUMENT,NEXT_CHAR,1) =
                         SUBSTR(RULE,BLANK,1);
                  END;
            END;
            TOKEN = TOKEN + 1;
            RULEARRAY.FUNCTION(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'LCHARACTER' !! FORMAT_ARGUMENT;
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + NEXT_SEMICOLON + 8;
            END;
       WHEN ((SUBSTR(RULE,I,7) = 'DECIMAL') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+7,1))=0)) DO;
0           /********************************************************/
            /*  THE HANDLING OF THE 'DECIMAL'        FUNCTION IS    */
            /*  THE SAME AS FOR THE 'FORMAT' FUNCTION... SEE THE    */
            /*  DESCRIPTION ABOVE...                                */
            /********************************************************/
0           NEXT_SEMICOLON = INDEX(SUBSTR(RULE,I+7),';');
            FORMAT_ARGUMENT = '';
            NEXT_CHAR=0;
            DO BLANK=I+7 TO NEXT_SEMICOLON + 6 + I;
               IF SUBSTR(RULE,BLANK,1)^=' ' THEN DO;
                  NEXT_CHAR=NEXT_CHAR+1;
                  SUBSTR(FORMAT_ARGUMENT,NEXT_CHAR,1) =
                         SUBSTR(RULE,BLANK,1);
                  END;
            END;
            TOKEN = TOKEN + 1;
            RULEARRAY.FUNCTION(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'DECIMAL' !! FORMAT_ARGUMENT;
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
            I = I + NEXT_SEMICOLON + 5;
            END;
       WHEN ((SUBSTR(RULE,I,9) = 'SUBSTRING') &
            (INDEX(ALPHANUMERIC,SUBSTR(RULE,I+9,1))=0)) DO;
0           /********************************************************/
            /*  THE HANDLING OF THE 'SUBSTRING' BUILTIN FUNCTION IS */
            /*  THE SAME AS FOR THE 'FORMAT' FUNCTION... SEE THE    */
            /*  DESCRIPTION ABOVE...                                */
            /********************************************************/
0           NEXT_SEMICOLON = INDEX(SUBSTR(RULE,I+6),';');
            SUBSTR_ARGUMENT = '';
            NEXT_CHAR=0;
            DO BLANK=I+6 TO NEXT_SEMICOLON + 5 + I;
               IF SUBSTR(RULE,BLANK,1)^=' ' THEN DO;
                  NEXT_CHAR=NEXT_CHAR+1;
                  SUBSTR(SUBSTR_ARGUMENT,NEXT_CHAR,1) =
                         SUBSTR(RULE,BLANK,1);
                  END;
            END;
            TOKEN = TOKEN + 1;
            RULEARRAY.FUNCTION(TOKEN) = '1'B;
            RULEARRAY.CONTENT(TOKEN) = 'SUBSTR' !! SUBSTR_ARGUMENT;
            RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
         /* I = I + NEXT_SEMICOLON + 7; */
            I = I + NEXT_SEMICOLON + 5;
            END;
       OTHERWISE DO;
            /*********************************************************/
            /*  IF THE TOKEN STARTS WITH AN ALPHABETIC CHARACTER AND */
            /*  IT IS NOT ONE OF THE KEYWORDS HANDLED ABOVE,         */
            /*  WE APPARENTLY FOUND A VARIABLE.. CHECK WHETHER IT'S  */
            /*  A USER-VARIABLE OR A DATABASE-VARIABLE               */
            /*********************************************************/
            VARIABLE_END_POSITION = VERIFY(SUBSTR(RULE,I,
                  MAX_VARIABLENAME_LENGTH),ALPHANUMERIC);
            IF SUBSTR(RULE,I+VARIABLE_END_POSITION-1,1)='.'
               THEN DO;
               /*****************************************************/
               /*  ACCORDING TO OUR BASIC DEFINITION, WE HAVE A     */
               /*  DATABASE VARIABLE IF THE STRING MAKING UP THE    */
               /*  VARIABLE NAME CONTAINS A POINT ('.')             */
               /*****************************************************/
               /*  THE LENGTH OF THE VARIABLE'S NAME IS DEFINED BY  */
               /*  THE NEXT NON-ALPHANUMERIC CHARACTER FOLLOWING    */
               /*  THE VARIABLE  (E.G. 'CCO.MYVAR =',               */
               /*  'CCO.NEWVAR*23',...)                             */
               /*****************************************************/
               /*  WE HAVE TO SPLIT THE VARIABLES'S NAME INTO TWO   */
               /*  PARTS BECAUSE PLI'S VERIFY FUNCTION FIRST        */
               /*  FINDS THE POINT MARKING THE END OF THE VARIABLE. */
               /*  WE HAVE TO CALL IT AGAIN TO INCLUDE NOT ONLY THE */
               /*  THE DATABASE NAME BUT THE VARIABLE NAME, TOO...  */
               /*****************************************************/
               DBNAME_LENGTH=VARIABLE_END_POSITION-1;
               VARIABLE_END_POSITION=VERIFY(SUBSTR(RULE,I+
               DBNAME_LENGTH+1,MAX_VARIABLENAME_LENGTH),ALPHANUMERIC);
               TOKEN = TOKEN + 1;
               RULEARRAY.DB_VARIABLE(TOKEN) = '1'B;
               RULEARRAY.CONTENT(TOKEN)=SUBSTR(RULE,I,DBNAME_LENGTH+
                 VARIABLE_END_POSITION);
               RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
               I=I+DBNAME_LENGTH+VARIABLE_END_POSITION-1;
               END;
            ELSE DO;
               /*****************************************************/
               /*  ACCORDING TO OUR BASIC DEFINITION, WE HAVE A     */
               /*  USER VARIABLE IF THE STRING MAKING UP THE        */
               /*  VARIABLE NAME DOES NOT CONTAIN A POINT ('.')     */
               /*****************************************************/
               TOKEN = TOKEN + 1;
               RULEARRAY.USER_VARIABLE(TOKEN) = '1'B;
               RULEARRAY.CONTENT(TOKEN)=SUBSTR(RULE,I,
                 VARIABLE_END_POSITION-1);
               RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
               I=I+VARIABLE_END_POSITION-2;
               END;
            END;                    /* END OF OTHERWISE   */
  END;                              /* END OF SELECT      */
 END;                               /* END OF PROCEDURE   */
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE TAKES THE RULE'S CONTENT BEGINNING    */
 /*            WITH THE NUMERIC CHARACTER FOUND AND PUTS THE WHOLE  */
 /*            CONSTANT (ENDING WITH THE NEXT NON-NUMERIC           */
 /*            CHARACTER) INTO THE 'RULEARRAY'                      */
 /*******************************************************************/
0NUMERIC_FOUND: PROCEDURE;
 VARIABLE_END_POSITION = VERIFY(SUBSTR(RULE,I,
                         MAX_CONSTANT_LENGTH),NUMERIC);
 TOKEN = TOKEN + 1;
 RULEARRAY.CONSTANT(TOKEN) = '1'B;
 RULEARRAY.CONTENT(TOKEN) = SUBSTR(RULE,I,
                        VARIABLE_END_POSITION-1);
 RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
 I = I + VARIABLE_END_POSITION-2;
 END;                               /* END OF PROCEDURE   */
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE ANALYZES THE SPECIAL CHARACTER        */
 /*            FOUND AND SETS AN ACCORDING TOKEN IN THE 'RULEARRAY' */
 /*******************************************************************/
0SPECIAL_CHARACTER_FOUND: PROCEDURE;
 SELECT (RULECHAR);
        WHEN ('*','/','+','-') DO;
0            /********************************************************/
             /*  WE FOUND ONE OF THE DEFINED BASIC MATH OPERATORS    */
             /********************************************************/
0            TOKEN = TOKEN + 1;
             RULEARRAY.MATH_OPERATOR(TOKEN) = '1'B;
             RULEARRAY.CONTENT(TOKEN) = RULECHAR;
             RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
             END;
        WHEN ('>','<','=','^') DO;
             IF SUBSTR(RULE,I+1,1) = '=' THEN DO;
0            /********************************************************/
             /*  WE FOUND ONE OF THE DEFINED COMPARISON OPERATORS    */
             /*  TOGETHER WITH AN EQUALITY OPERATOR (<=,>=,^=)       */
             /********************************************************/
0               TOKEN = TOKEN + 1;
                RULEARRAY.COMPARISON(TOKEN) = '1'B;
                RULEARRAY.CONTENT(TOKEN) = SUBSTR(RULE,I,2);
                RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
                I = I + 1;
                END;
             ELSE DO;
                IF RULECHAR = '=' THEN DO;
0                  /**************************************************/
                   /*  WE FOUND AN ASSIGNMENT OPERATOR               */
                   /**************************************************/
0                  TOKEN = TOKEN + 1;
                   RULEARRAY.ASSIGNMENT(TOKEN) = '1'B;
                   RULEARRAY.CONTENT(TOKEN) = RULECHAR;
                   RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
                   END;
                ELSE DO;
0                  /**************************************************/
                   /*  WE FOUND ONE OF THE COMPARISON OPERATORS      */
                   /**************************************************/
0                  TOKEN = TOKEN + 1;
                   RULEARRAY.COMPARISON(TOKEN) = '1'B;
                   RULEARRAY.CONTENT(TOKEN) = RULECHAR;
                   RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
                   END;
                END;
             END;
        WHEN ('(') DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI758                                    */
             /* MESSAGE: OPEN PARENTHESIS FOUND OUT OF CONTEXT IN   */
             /*          LINE NUMBER XXX                            */
             /* MESSAGECLASS: LEXICAL ANALYSIS ERROR MESSAGE        */
             /* EXPLANATION: THE INTERPRETER FOUND AN OPEN          */
             /*              PARENTHESIS OUT OF CONTEXT. THIS MAY   */
             /*              BE CAUSED BY AN INVALID SPELLING OF    */
             /*              A BUILTIN-FUNCTION.                    */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SPECIAL_CHARACTER_FOUND                  */
             /* USER RESPONSE: CHANGE THE RULES AND DELETE THE      */
             /*                PARENTHESIS OR CORRECT THE SPELLING  */
             /*                OF THE BUILTIN FUNCTION.             */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER ACTION                       */
             /* EXAMPLE: USV = DEIT(BLA.VLRXG,YYMMDD);              */
             /*******************************************************/
                LINECHAR = INPUT_LINE;
                IF SP.RUN_MODE = 'M' THEN DO;
                   INTMSG ('758',SUBSTR(LINECHAR,7,3)
                                 !! ',' !! SP.RULE_NAME);
                END;
                ELSE DO;
                   QCHNOT(958);
                   SP.EOP_FROM_RULE = '1'B;
                   SP.ROLB_REQU  = '1'B;
                   GOTO ABEND;
                END;
             END;
        WHEN (')') DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI759                                    */
             /* MESSAGE: INVALID CLOSING PARENTHESIS FOUND IN LINE  */
             /*          NUMBER XXX                                 */
             /* MESSAGECLASS: LEXICAL ANALYSIS ERROR MESSAGE        */
             /* EXPLANATION: THE INTERPRETER FOUND A CLOSING        */
             /*              PARENTHESIS OUT OF CONTEXT.            */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SPECIAL_CHARACTER_FOUND                  */
             /* USER RESPONSE: CHANGE THE RULES AND DELETE THE      */
             /*                PARENTHESIS.                         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER ACTION                       */
             /* EXAMPLE: USV = BLA.VLRXG * )3*2);                   */
             /*******************************************************/
                LINECHAR = INPUT_LINE;
                IF SP.RUN_MODE = 'M' THEN DO;
                   INTMSG ('759',SUBSTR(LINECHAR,7,3)
                                 !! ',' !! SP.RULE_NAME);
                END;
                ELSE DO;
                   QCHNOT(959);
                   SP.EOP_FROM_RULE = '1'B;
                   SP.ROLB_REQU  = '1'B;
                   GOTO ABEND;
                END;
             END;
        WHEN ('!','&') DO;
             IF (SUBSTR(RULE,I+1,1) = '!') THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI760                                    */
             /* MESSAGE: USE OF '!!' FOR CONCATENATION              */
             /*          IN LINE NUMBER *V                          */
             /* MESSAGECLASS: LEXICAL ANALYSIS ERROR MESSAGE        */
             /* EXPLANATION: THE INTERPRETER FOUND TWO CONCATENATION*/
             /*              CHARACTERS TRYING TO CONCATENATE TWO   */
             /*              EXPRESSIONS. THIS IS NOT ALLOWED.      */
             /*              USE THE 'CONCAT'-BUILTIN-FUNCTION      */
             /*              INSTEAD.                               */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SPECIAL_CHARACTER_FOUND                  */
             /* USER RESPONSE: CHANGE THE RULES BY USING THE        */
             /*                'CONCAT' FUNCTION FOR CONCATENATION. */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER ACTION                       */
             /* EXAMPLE: ABC.CHARGE = 'NOCHARGE;                    */
             /*******************************************************/
                LINECHAR = INPUT_LINE;
                IF SP.RUN_MODE = 'M' THEN DO;
                   INTMSG ('760',SUBSTR(LINECHAR,7,3)
                                 !! ',' !! SP.RULE_NAME);
                END;
                ELSE DO;
                   QCHNOT(960);
                   SP.EOP_FROM_RULE = '1'B;
                   SP.ROLB_REQU  = '1'B;
                   GOTO ABEND;
                END;
             END;
             ELSE DO;
0               /*****************************************************/
                /*  WE FOUND A LOGIC OPERATOR                        */
                /*****************************************************/
0               TOKEN = TOKEN + 1;
                RULEARRAY.LOGIC_OPERATOR(TOKEN) = '1'B;
                RULEARRAY.CONTENT(TOKEN) = RULECHAR;
                RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
                END;
             END;
        WHEN (';') DO;
0            /********************************************************/
             /*  WE FOUND THE STATEMENT-TERMINATION CHARACTER        */
             /********************************************************/
0            TOKEN = TOKEN + 1;
             RULEARRAY.SEMICOLON(TOKEN) = '1'B;
             RULEARRAY.CONTENT(TOKEN) = RULECHAR;
             RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
             END;
        WHEN (APOSTROPHE) DO;
0            /********************************************************/
             /*  WE FOUND A TEXT CONSTANT SURROUNDED BY APOSTROPHES  */
             /********************************************************/
0            TOKEN = TOKEN + 1;
             RULEARRAY.TEXT(TOKEN) = '1'B;
0            /********************************************************/
             /*  ACTUALLY I DON'T KNOW WHAT THE NEXT TWO LOOPS DO... */
             /*  I'LL TAKE THEM OUT AS SOON AS I HAVE THE TIME TO    */
             /*  MAKE SURE THEY AREN'T NEEDED BY ANY TRICKY FUNCTION */
             /********************************************************/
0            DO P=1 TO 80;
                IF SUBSTR(RULE,P,1)=APOSTROPHE THEN LEAVE;
             END;
             DO Q=P+1 TO 80;
                IF SUBSTR(RULE,Q,1)=APOSTROPHE THEN LEAVE;
             END;
             DO VARIABLE_END_POSITION = I+1 TO 256;
                IF SUBSTR(RULE,VARIABLE_END_POSITION,1)=APOSTROPHE
                   THEN LEAVE;
             END;
             IF VARIABLE_END_POSITION >=256 THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI701                                    */
             /* MESSAGE: NO CLOSING APOSTROPHE FOUND                */
             /*          IN LINE *V, RULE *V                        */
             /* MESSAGECLASS: LEXICAL ANALYSIS ERROR MESSAGE        */
             /* EXPLANATION: THE INTERPRETER COULD NOT FIND A       */
             /*              CLOSING APOSTROPHE WITHIN 256          */
             /*              CHARACTERS AFTER AN OPENING APOSTROPHE */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SPECIAL_CHARACTER_FOUND                  */
             /* USER RESPONSE: CHANGE THE RULES AND DELETE THE      */
             /*                UNNECESSARY APOSTROPHE (OR ADD THE   */
             /*                MISSING CLOSING ONE)                 */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER ACTION                       */
             /* EXAMPLE: ABC.CHARGE = 'NOCHARGE;                    */
             /*******************************************************/
                LINECHAR = INPUT_LINE;
                IF SP.RUN_MODE = 'M' THEN DO;
                   INTMSG ('701',SUBSTR(LINECHAR,7,3)
                                 !! ',' !! SP.RULE_NAME);
                END;
                ELSE DO;
                   QCHNOT(901);
                   SP.EOP_FROM_RULE = '1'B;
                   SP.ROLB_REQU  = '1'B;
                   GOTO ABEND;
                END;
             END;
             ELSE DO;
               RULEARRAY.CONTENT(TOKEN) = SUBSTR(RULE,I+1,
                                          VARIABLE_END_POSITION-I-1);
               RULEARRAY.LINENUMBER(TOKEN) = INPUT_LINE;
               RULEARRAY.TEXTLENGTH(TOKEN) = VARIABLE_END_POSITION-I-1;
               I = VARIABLE_END_POSITION;
             END;
             END;
        OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI702                                    */
             /* MESSAGE: INVALID CHARACTER  FOUND IN LINE NUMBER X */
             /* MESSAGECLASS: LEXICAL ANALYSIS WARNING MESAGE       */
             /* EXPLANATION: THERE WAS AN INVALID CHARACTER FOUND   */
             /*              WITHIN THE RULES WHICH IS NOT AMONG    */
             /*              THE VALID CHARACTERS AS DEFINED        */
             /*              IN THE CHIS INTERPRETER LANGUAGE.      */
             /*              THIS ERROR MAY CAUSE DEPENDENT ERRORS  */
             /*              FOLLOWING THE INVALID CHARACTER.       */
             /* SEVERITY: 4                                         */
             /* PROCEDURE: SPECIAL_CHARACTER_FOUND                  */
             /* USER RESPONSE: CHANGE THE RULES AND DELETE THE      */
             /*                INVALID CHARACTER                    */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS              */
             /* EXAMPLE: USE OF THE CHARACTER '' INSTEAD OF '>'    */
             /*******************************************************/
                LINECHAR = INPUT_LINE;
                IF SP.RUN_MODE = 'M' THEN DO;
                   INTMSG ('702',SUBSTR(LINECHAR,7,3)
                                 !! ',' !! SP.RULE_NAME);
                END;
                ELSE DO;
                   QCHNOT(902);
                   SP.EOP_FROM_RULE = '1'B;
                   SP.ROLB_REQU  = '1'B;
                   GOTO ABEND;
                END;
             END;
 END;
 END;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE CHECKS THE TOKENIZED RULE SYNTAX      */
 /*            AND WRITES APPROPRIATE ERROR MESSAGES                */
 /*******************************************************************/
0SYNTAX_CHECK: PROCEDURE;
0/*******************************************************************/
 /* STEP 1: CHECK FOR CORRECT IF-THEN-DO-END NESTING               */
 /* STEP 2: CHECK FOR CORRECT PARENTHESES NESTING                  */
 /*******************************************************************/
0DO I=1 TO TOKEN;
    IF (RULEARRAY.KEYWORD(I)='1') &
       (RULEARRAY.CONTENT(I)='IF') THEN DO;
       DO K=1 TO MAX_TOKENS_IN_EXPRESSION;
          IF (RULEARRAY.KEYWORD(K+I)='1') &
             (RULEARRAY.CONTENT(K+I)='THEN') THEN LEAVE;
          IF (RULEARRAY.KEYWORD(K+I)='1') &
             (RULEARRAY.CONTENT(K+I)='DO') THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI703                                    */
             /* MESSAGE: KEYWORD 'THEN' MISSING IN IF-CLAUSE IN     */
             /*          LINE NUMBER XXXX                           */
             /* MESSAGECLASS: SYNTAX CHECK ERROR   MESSAGE          */
             /* EXPLANATION: THERE WAS AN 'IF' KEYWORD FOUND BY     */
             /*              THE SYNTAX CHECK ROUTINE WHICH IS      */
             /*              FOLLOWED BY A 'DO' KEYWORD WITHOUT     */
             /*              A NECESSARY 'THEN' KEYWORD.            */
             /* SEVERITY: 4                                         */
             /* PROCEDURE: SYNTAX_CHECK                             */
             /* USER RESPONSE: CHANGE THE RULES AND ADD THE MISSING */
             /*                'THEN' KEYWORD                       */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS...           */
             /* EXAMPLE: IF TESTDB.PRICE > 999 DO; ...              */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(K+I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('703',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(903);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
          END;
          IF (RULEARRAY.KEYWORD(K+I)='1') &
             (RULEARRAY.CONTENT(K+I)='END') THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI704                                    */
             /* MESSAGE: 'END' KEYWORD FOUND AFTER 'IF' IN LINE XXX */
             /* MESSAGECLASS: SYNTAX CHECK ERROR MESSAGE            */
             /* EXPLANATION: THERE WAS AN 'IF' KEYWORD FOUND BY     */
             /*              THE SYNTAX CHECK ROUTINE WHICH IS      */
             /*              FOLLOWED BY AN 'END' KEYWORD WITHOUT   */
             /*              THE NECESSARY KEYWORDS 'THEN' AND 'DO' */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SYNTAX_CHECK                             */
             /* USER RESPONSE: CHANGE THE RULES AND ADD THE MISSING */
             /*                KEYWORDS OR                          */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                TRYING TO CORRECT THE ERROR          */
             /* EXAMPLE: IF TESTDB.PRICE > 999 END;                 */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(K+I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('704',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(904);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
          END;
       END;
       IF K=MAX_TOKENS_IN_EXPRESSION THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI705                                    */
             /* MESSAGE: 'IF' KEYWORD NOT FOLLOWED BY A 'THEN'      */
             /*          KEYWORD                                    */
             /* MESSAGECLASS: SYNTAX CHECK ERROR MESSAGE            */
             /* EXPLANATION: THERE WAS NO 'THEN' KEYWORD FOLLOWING  */
             /*              AN 'IF' KEYWORD WITHIN MANY TOKENS     */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SYNTAX_CHECK                             */
             /* USER RESPONSE: CHANGE THE RULES AND ADD THE MISSING */
             /*                'THEN' KEYWORD                       */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                TRYING TO CORRECT THE ERROR          */
             /* EXAMPLE: IF TESTDB.PRICE > 999 DO; ... END;         */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(K+I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('705',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(905);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
       END;
       I = K + I;
       IF (RULEARRAY.KEYWORD(I+1)^='1') &
          (RULEARRAY.CONTENT(I+1)^='DO') THEN DO;
          DO K=1 TO MAX_TOKENS_IN_EXPRESSION;
             IF (RULEARRAY.SEMICOLON(K+I)='1') THEN LEAVE;
             IF (RULEARRAY.KEYWORD(K+I)='1') &
                (RULEARRAY.CONTENT(K+I)='END') THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI706                                    */
             /* MESSAGE: 'END' KEYWORD FOUND WITHOUT                */
             /*          'DO' IN LINE NUMBER XXXX                   */
             /* MESSAGECLASS: SYNTAX CHECK ERROR MESSAGE            */
             /* EXPLANATION: THERE WAS AN 'END' KEYWORD AFTER       */
             /*              A 'THEN' KEYWORD WITHOUT THE NECESSARY */
             /*              'DO' KEYWORD                           */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SYNTAX_CHECK                             */
             /* USER RESPONSE: CHANGE THE RULES AND ADD THE MISSING */
             /*                'DO' KEYWORD                         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                TRYING TO CORRECT THE ERROR          */
             /* EXAMPLE: IF TESTDB.PRICE > 999 THEN ... END;        */
             /*******************************************************/
                LINECHAR =  RULEARRAY.LINENUMBER(K+I);
                IF SP.RUN_MODE = 'M' THEN DO;
                   INTMSG ('706',SUBSTR(LINECHAR,7,3)
                                 !! ',' !! SP.RULE_NAME);
                END;
                ELSE DO;
                   QCHNOT(906);
                   SP.EOP_FROM_RULE = '1'B;
                   SP.ROLB_REQU     = '1'B;
                   GOTO ABEND;
                END;
             END;
          END;
          IF K=MAX_TOKENS_IN_EXPRESSION THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI707                                    */
             /* MESSAGE: SEMICOLON MISSING IN IF-STATEMENT          */
             /*          IN LINE NUMBER XXXXX                       */
             /* MESSAGECLASS: SYNTAX CHECK ERROR MESSAGE            */
             /* EXPLANATION: THERE WAS NO SEMICOLON FOLLOWING       */
             /*              A 'THEN' KEYWORD AFTER MANY TOKENS     */
             /*              1) NO 'DO' SPECIFIED AFTER A 'THEN'    */
             /*                 ALTHOUGH THERE IS MORE THAN ONE     */
             /*                 EXPRESSION FOLLOWING                */
             /*              2) NUMBER DEFINED BY THE FIELD         */
             /*                 MAX_TOKENS_IN_EXPRESSION IS TOO     */
             /*                 SMALL                               */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SYNTAX_CHECK                             */
             /* USER RESPONSE: CHANGE THE RULES AND ADD THE MISSING */
             /*                'DO-END' CONSTRUCTION                */
             /* PROGRAMMER RESPONSE: INCREMENT THE FIELD            */
             /*                MAX_TOKENS_IN_EXPRESSIONS IF THERE   */
             /*                IS NO APPARENT ERROR IN THE RULES    */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                TRYING TO CORRECT THE ERROR          */
             /* EXAMPLE: IF TESTDB.PRICE > 999 THEN HUGO1=3         */
             /*                                     HUGO2=4;        */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(K+I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('707',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(907);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
          END;
       END;  /* END 'DO' FOLLOWED AFTER 'IF'                          */
    END;
 END;
 /********************************************************************/
1/* STEP 2: CHECK FOR CORRECT PARENTHESES NESTING                    */
 /********************************************************************/
0DO I=1 TO TOKEN;
    IF (RULEARRAY.LEFT_PARENTHESIS(I)='1'B) THEN DO;
       DO K=1 TO MAX_TOKENS_IN_EXPRESSION;
          IF (RULEARRAY.RIGHT_PARENTHESIS(K+I)='1'B) THEN LEAVE;
       END;
       IF K=MAX_TOKENS_IN_EXPRESSION THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI708                                    */
             /* MESSAGE: MISSING RIGHT PARENTHESIS IN LINE XXXXX    */
             /* MESSAGECLASS: SYNTAX CHECK ERROR MESSAGE            */
             /* EXPLANATION: THE INTERPRETER SEARCHED FOR A         */
             /*              A RIGHT PARENTHESIS FOLLOWING          */
             /*              A LEFT PARENTHESIS, BUT THERE WAS      */
             /*              NONE AFTER MANY TOKENS.                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SYNTAX_CHECK                             */
             /* USER RESPONSE: CHANGE THE RULES AND ADD THE MISSING */
             /*                RIGHT PARENTHESIS OR DELETE THE      */
             /*                LEFT PARENTHESIS                     */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                TRYING TO CORRECT THE ERROR          */
             /* EXAMPLE: NEWFIELD = (TESTDB.PRICE * FOO;            */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(K+I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('708',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(908);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
       END;
       LEFT_PARENTHESIS_COUNT = 1;
       RIGHT_PARENTHESIS_COUNT = 1;
       DO K=1 TO MAX_TOKENS_IN_EXPRESSION;
          IF ((RULEARRAY.KEYWORD(K+I)='1'B) !
             (RULEARRAY.SEMICOLON(K+I)='1'B)) THEN LEAVE;
          IF (RULEARRAY.LEFT_PARENTHESIS(K+I)='1'B) THEN
             LEFT_PARENTHESIS_COUNT=LEFT_PARENTHESIS_COUNT+1;
          IF (RULEARRAY.RIGHT_PARENTHESIS(K+I)='1'B) THEN
             RIGHT_PARENTHESIS_COUNT=RIGHT_PARENTHESIS_COUNT+1;
       END;
       IF LEFT_PARENTHESIS_COUNT > MAX_PARENTHESIS_NESTING THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI709                                    */
             /* MESSAGE: TOO MANY NESTED PARENTHESES IN LINE XXX    */
             /* MESSAGECLASS: SYNTAX CHECK ERROR MESSAGE            */
             /* EXPLANATION: THERE WERE TOO MANY NESTED PARENTHESES */
             /*              AS DEFINED BY THE FIELD                */
             /*              MAX_PARENTHESIS_NESTING.               */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SYNTAX_CHECK                             */
             /* USER RESPONSE: CHANGE THE RULES AND TRY TO WRITE    */
             /*                THE EXPRESSION WITH LESS PARENTHESES */
             /* PROGRAMMER RESPONSE: INCREMENT THE FIELD            */
             /*                MAX_PARENTHESIS_NESTING IF NECESSARY */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                TRYING TO CORRECT THE ERROR          */
             /* EXAMPLE: F3 = (FOO*(BAR-(TEST/(CASE-FOOBAR))));     */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(K+I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('709',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(909);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
       END;
       IF RIGHT_PARENTHESIS_COUNT > MAX_PARENTHESIS_NESTING THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI709                                    */
             /* MESSAGE: TOO MANY NESTED PARENTHESES IN LINE XXX    */
             /* MESSAGECLASS: SYNTAX CHECK ERROR MESSAGE            */
             /* EXPLANATION: THERE WERE TOO MANY NESTED PARENTHESES */
             /*              AS DEFINED BY THE FIELD                */
             /*              MAX_PARENTHESIS_NESTING.               */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SYNTAX_CHECK                             */
             /* USER RESPONSE: CHANGE THE RULES AND TRY TO WRITE    */
             /*                THE EXPRESSION WITH LESS PARENTHESES */
             /* PROGRAMMER RESPONSE: INCREMENT THE FIELD            */
             /*                MAX_PARENTHESIS_NESTING IF NECESSARY */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                TRYING TO CORRECT THE ERROR          */
             /* EXAMPLE: F3 = (FOO*(BAR-(TEST/(CASE-FOOBAR))));     */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(K+I);
              IF SP.RUN_MODE = 'M' THEN DO;
                 INTMSG ('709',SUBSTR(LINECHAR,7,3)
                               !! ',' !! SP.RULE_NAME);
              END;
              ELSE DO;
                 QCHNOT(909);
                 SP.EOP_FROM_RULE = '1'B;
                 SP.ROLB_REQU     = '1'B;
                 GOTO ABEND;
              END;
       END;
       IF RIGHT_PARENTHESIS_COUNT ^= LEFT_PARENTHESIS_COUNT THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI711                                    */
             /* MESSAGE: UNBALANCED PARENTHESES IN LINE NUMBER XXXX */
             /* MESSAGECLASS: SYNTAX CHECK ERROR MESSAGE            */
             /* EXPLANATION: THE INTERPRETER FOUND UNBALANCED       */
             /*              PARENTHESES WITHIN THE RULES.          */
             /*              THERE ARE MORE LEFT THAN RIGHT         */
             /*              PARENTHESES OR VICE VERSA.             */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SYNTAX_CHECK                             */
             /* USER RESPONSE: CHANGE THE RULES AND ADD THE MISSING */
             /*                PARENTHESIS                          */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                TRYING TO CORRECT THE ERROR          */
             /* EXAMPLE: NEWFIELD = (TESTDB.PRICE * (FOO - BAR);    */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(K+I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('711',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(911);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
       END;
   END;
 END;     /*  END OF CHECK FOR CORRECT PARENTHESIS                  */
0END SYNTAX_CHECK;
1/*******************************************************************/
 /*  NOW WE DO THE ACTUAL INTERPRETATION STEPS WORKING FROM THE     */
 /*  RULEARRAY AS THE PRIMARY SOURCE. THE RULEARRAY CONTAINS THE    */
 /*  PARSED TOKENS TOGETHER WITH A RANGE OF BIT SWITCHES DEFINING   */
 /*  THE TYPE OF TOKEN FOUND IN THE RULES.                          */
 /*******************************************************************/
0INTERPRET_TOKEN: PROCEDURE;
 MAX_TOKENS = TOKEN;
0/*******************************************************************/
 /*  AFTER ASSIGNING THE NUMBER OF TOKENS FOUND TO MAX_TOKENS,      */
 /*  WE START THE INTERPRETERS MAIN LOOP WHICH RUNS THROUGH THE     */
 /*  WHOLE RULEARRAY. WE USE 'I' AS THE RUNNING INDEX VARIABLE      */
 /*  HOLDING THE CURRENT TOKEN OF THE RULEARRAY BEING PROCESSED.    */
 /*******************************************************************/
0DO I=1 TO MAX_TOKENS;
0   /****************************************************************/
    /*  HERE WE LOOK FOR THE NEXT SEMICOLON IN THE RULEARRAY        */
    /*  DEFINING THE RANGE OF TOKENS THE STATEMENT IS MADE OF.      */
    /****************************************************************/
    /*  NOTE THAT 'TOKENS_IN_STATEMENT' (WHICH IS EQUAL TO THE      */
    /*  NUMBER OF TOKENS A STATEMENT IS MADE OF) ALSO INCLUDES      */
    /*  THE SEMICOLON AS THE STATEMENT SEPERATOR...                 */
    /****************************************************************/
0   DO TOKENS_IN_STATEMENT=1 TO MAX_TOKENS;
       IF RULEARRAY.SEMICOLON(I+TOKENS_IN_STATEMENT-1)='1'B THEN LEAVE;
    END;
0   /****************************************************************/
    /*  NOW WE LOOK AT THE TYPE OF TOKEN THE STATEMENT BEGINS WITH. */
    /*  IF IT IS A KEYWORD, IT MUST BE AN IF-THEN-DO-END STATEMENT. */
    /****************************************************************/
0   IF RULEARRAY.KEYWORD(I)='1'B THEN
       DO;
       IF ((RULEARRAY.CONTENT(I)^='IF') &
           (RULEARRAY.CONTENT(I)^='RETURN')) THEN
          DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI712                                    */
             /* MESSAGE: FIRST KEYWORD IN STATEMENT MUST BE 'IF'    */
             /*          OR 'RETURN'                                */
             /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
             /* EXPLANATION: THE FIRST TOKEN IN A STATEMENT         */
             /*              WAS FOUND TO BE A KEYWORD, BUT IS      */
             /*              NOT AN 'IF' KEYWORD OR A 'RETURN'      */
             /*              KEYWORD AS REQUIRED.                   */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: INTERPRET_TOKEN                          */
             /* USER RESPONSE: CHANGE THE RULES AND CORRECT THE     */
             /*                STATEMENT IN ERROR                   */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                TRYING TO CORRECT THE ERROR          */
             /* EXAMPLE: DO; FOO=3; BAR=4; END;                     */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('712',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(912);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
          END;
       ELSE DO;
          IF (RULEARRAY.CONTENT(I)='RETURN') THEN
             GOTO ABEND;
0         /**********************************************************/
          /*  WE ACTUALLY HAVE AN IF-THEN-DO-END STATEMENT HERE.    */
          /*  NOW WE RUN THROUGH THE STATEMENT LOOKING FOR THE      */
          /*  'THEN' TOKEN IN ORDER TO KNOW THE BEGINNING AND       */
          /*  END OF THE EXPRESSION TO BE EVALUATED...              */
          /**********************************************************/
          /*  THE VARIABLES WHICH HOLD THESE VALUES ARE CALLED      */
          /*  FIRST_TOKEN_IN_EXPRESSION AND LAST_TOKEN_IN_EXPRESSION*/
          /*  RESPECTIVELY                                          */
          /**********************************************************/
0         DO TOKEN_IN_IF_STATEMENT = I TO (I+TOKENS_IN_STATEMENT);
             IF (RULEARRAY.CONTENT(TOKEN_IN_IF_STATEMENT) = 'THEN')
                THEN LEAVE;
          END;
          FIRST_TOKEN_IN_EXPRESSION = I + 1;
          LAST_TOKEN_IN_EXPRESSION = TOKEN_IN_IF_STATEMENT - 1;
0         /**********************************************************/
          /*  NOW THAT WE KNOW WHERE THE EXPRESSION STARTS AND ENDS,*/
          /*  PROCESS IT...                                         */
          /**********************************************************/
0         CALL EVALUATE_EXPRESSION;
          END;
       END;
    ELSE DO;
0        /**********************************************************/
         /*  IF THE STATEMENT DOES NOT START WITH A KEYWORD, IT    */
         /*  HAS TO BE AN ASSIGNMENT STATEMENT...                  */
         /**********************************************************/
         CALL DO_ASSIGNMENT;
         /**********************************************************/
         /* NOW WE ADD THE NUMBER OF TOKENS PROCESSED TO THE       */
         /* INDEX VARIABLE AND SUBTRACT ONE (BECAUSE I IS          */
         /* INCREMENTED AT THE TOP OF THE LOOP ANYWAY)             */
         /**********************************************************/
         I = I + TOKENS_IN_STATEMENT - 1;
         END;
 END;   /* END OF LOOP TO INTERPRET TOKENS IN RULEARRAY             */
0END INTERPRET_TOKEN;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE PROCESSES AN 'IF-THEN-DO-END'         */
 /*            STATEMENT AND INCREMENTS THE MAIN COUNTER 'I'        */
 /*******************************************************************/
0EVALUATE_EXPRESSION: PROCEDURE;
 LOGIC_OPERATOR_IN_IF_STMNT = '0'B;
0/*******************************************************************/
 /*  HERE WE START A LOOP OVER THE WHOLE 'IF-THEN-DO-END'           */
 /*  STATEMENT TO FIND OUT WHETHER THERE ARE LOGIC OPERATORS IN     */
 /*  THE IF-EXPRESSION AND TO FIND THE NUMBERS OF TOKENS TO         */
 /*  EVALUATE                                                       */
 /*******************************************************************/
0LOOK_FORWARD: DO IF_TOKEN = FIRST_TOKEN_IN_EXPRESSION TO
                  FIRST_TOKEN_IN_EXPRESSION + TOKEN_IN_IF_STATEMENT;
    IF RULEARRAY.LOGIC_OPERATOR(IF_TOKEN)='1'B THEN DO;
       LOGIC_OPERATOR_IN_IF_STMNT = '1'B;
       LEAVE LOOK_FORWARD;
       END;
    IF ((RULEARRAY.CONTENT(IF_TOKEN) = '=')  !
        (RULEARRAY.CONTENT(IF_TOKEN) = '^=') !
        (RULEARRAY.CONTENT(IF_TOKEN) = '^') !
        (RULEARRAY.CONTENT(IF_TOKEN) = '<')  !
        (RULEARRAY.CONTENT(IF_TOKEN) = '<=') !
        (RULEARRAY.CONTENT(IF_TOKEN) = '>')  !
        (RULEARRAY.CONTENT(IF_TOKEN) = '>=')) THEN
        COMPARISON_OPERATOR = IF_TOKEN;
        IF RULEARRAY.CONTENT(IF_TOKEN)='THEN' THEN LEAVE;
 END;
0/*******************************************************************/
 /*  HERE WE SAVE SOME IMPORTANT VALUES TO RESTORE THEM PROPERLY    */
 /*  AFTER CALLING THE INTERPRETERS GENERAL PURPOSE EVALUATION      */
 /*  ROUTINES                                                       */
 /*******************************************************************/
0SAVE_FIRST_TOKEN = FIRST_TOKEN;
 SAVE_TOKEN_IN_IF_STATEMENT = TOKEN_IN_IF_STATEMENT;
0/*******************************************************************/
 /*  IN CASE THERE IS A LOGIC OPERATOR (AND,OR) IN THE EXPRESSION   */
 /*  TO BE EVALUATED, WE CALL A SPECIAL PROCESSING ROUTINE          */
 /*******************************************************************/
0IF LOGIC_OPERATOR_IN_IF_STMNT='1'B THEN CALL DO_LOGIC;
 ELSE DO;
0  /*****************************************************************/
   /*  APPARENTLY WE HAVE A SIMPLE COMPARISON EXPRESSION            */
   /*  (EXAMPLE: IF OLDFIELD > NEWFIELD THEN...)                    */
   /*****************************************************************/
   LEFT_IS_CHARACTER = '0'B;
0  /*****************************************************************/
   /*  FIRST WE EVALUATE THE LEFT SIDE OF THE COMPARISON STATEMENT  */
   /*****************************************************************/
0  CALL EVALUATE_LEFT_SIDE;
   IF SFARRAY.CHARACTER(1)='1'B THEN LEFT_IS_CHARACTER='1'B;
0  /*****************************************************************/
   /*  THEN WE EVALUATE THE RIGHT SIDE OF THE COMPARISON STATEMENT  */
   /*****************************************************************/
0  CALL EVALUATE_RIGHT_SIDE;
0  /*****************************************************************/
   /*  DEPENDING ON THE PREVIOUS BIT SWITCHES SET, WE CALL THE      */
   /*  APPROPRIATE COMPARISON-ROUTINE                               */
   /*****************************************************************/
0  IF ((SFARRAY.CHARACTER(1)='1'B) ! (LEFT_IS_CHARACTER='1'B)) THEN
      CALL CHARACTER_COMPARE;
   ELSE CALL DECIMAL_COMPARE;
   END;
0  /*****************************************************************/
   /*  AND NOW WE RESTORE THE PREVIOUSLY SAVED VALUES...            */
   /*****************************************************************/
0  FIRST_TOKEN = SAVE_FIRST_TOKEN;
   TOKEN_IN_IF_STATEMENT = SAVE_TOKEN_IN_IF_STATEMENT;
0  /*****************************************************************/
   /* TO FIND OUT ABOUT THE RELATIVE POSITION OF THE 'END' TOKEN,   */
   /* WE RUN ANOTHER LOOP...                                        */
   /*****************************************************************/
0  DO END_TOKEN = TOKEN_IN_IF_STATEMENT TO MAX_TOKENS;
      IF ((RULEARRAY.KEYWORD(END_TOKEN)='1'B) &
          (RULEARRAY.CONTENT(END_TOKEN)='END')) THEN LEAVE;
   END;
   IF END_TOKEN >= MAX_TOKENS THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI713                                    */
             /* MESSAGE: END OF RULES FOUND BEFORE CLOSING 'END'    */
             /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
             /* EXPLANATION: THE INTERPRETER FOUND THE END OF THE   */
             /*              RULES SOURCE BEFORE A CLOSING 'END'    */
             /*              FOR AN IF-THEN-DO-STATEMENT WAS        */
             /*              FOUND.                                 */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: EVALUATE_EXPRESSION                      */
             /* USER RESPONSE: CHANGE THE RULES AND ADD THE MISSING */
             /*                'END' STATEMENT                      */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                TRYING TO CORRECT THE ERROR          */
             /* EXAMPLE: IF A=3 THEN DO; B=2; C=4;                  */
             /*          * END OF RULES                             */
             /*                                                     */
             /*******************************************************/
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('713',SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(913);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
       END;
    ELSE DO;
0  /*****************************************************************/
   /* NOW WE DO THE ASSIGNMENT STATEMENTS WITHIN THE DO-END LOOP OR */
   /* WE JUMP AFTER THE 'END' STATEMENT... DEPENDING ON A BIT-SWITCH*/
   /* SET BY THE PREVIOUSLY CALLED COMPARISON-ROUTINES...           */
   /*****************************************************************/
      PUT DATA(IF_IS_OK);
0     IF IF_IS_OK='1'B THEN DO;
         I = TOKEN_IN_IF_STATEMENT + 3;
         /*  HANDLE 'RETURN' KEYWORD   */
         IF ((RULEARRAY.KEYWORD(I)='1'B) &
             (RULEARRAY.CONTENT(I)='RETURN')) THEN
             GOTO ABEND;
0      /*************************************************************/
       /*  NOW WE RUN A LOOP OVER THE STATEMENTS IN THE DO-END      */
       /*  BLOCK. NOTE THAT THE ONLY TYPE OF STATEMENT ALLOWED      */
       /*  IN SUCH A BLOCK IS AN ASSIGNMENT STATEMENT. IT IS        */
       /*  *NOT* ALLOWED TO CODE ANOTHER IF-THEN-DO-END STATEMENT   */
       /*  IN A DO-END BLOCK...                                     */
       /*************************************************************/
       DO WHILE (I < END_TOKEN);
          DO M = I TO END_TOKEN;
             /*******************************************************/
             /*  IF THE TOKEN IS A SEMICOLON, WE PROCESS THE NEXT   */
             /*  ASSIGNMENT STATEMENT UP TO THIS TOKEN              */
             /*******************************************************/
             IF RULEARRAY.SEMICOLON(M)='1'B THEN LEAVE;
          END;
          TOKENS_IN_STATEMENT = M - I + 1;
          CALL DO_ASSIGNMENT;
          I = I + TOKENS_IN_STATEMENT;
          PUT DATA(I,M);
       END;
    END;
 END;
 /********************************************************************/
 /* INCREMENT I WITH ONE ONLY (IT IS ADDITIONALLY INCREMENTED AT THE */
 /* TOP OF THE LOOP ANYWAY)                                          */
 /********************************************************************/
0I = END_TOKEN + 1;
0END EVALUATE_EXPRESSION;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE PROCESSES AN IF-STATEMENT CONTAINING  */
 /*            AT LEAST ONE AND/OR LOGIC-OPERATOR                   */
 /*******************************************************************/
0DO_LOGIC: PROCEDURE;
 LOGIC_BIT=0;
0/*******************************************************************/
 /*  THERE MUST NOT BE MORE THAN 8 LOGIC OPERATORS IN AN            */
 /*  IF-EXPRESSION... HERE WE CLEAR THE SMALL BIT-ARRAYS            */
 /*  HOLDING THE TYPE OF LOGIC_OPERATOR AND THE LOGIC RESULTS       */
 /*******************************************************************/
0DO M=1 TO 8;
    LOGIC(M)='0'B;
    LOGIC_OPERATOR(M)='0'B;
 END;
0/*******************************************************************/
 /*  SINCE THE SINGLE COMPARISON EXPRESSIONS COMBINED THROUGH       */
 /*  THE DIFFERENT LOGIC OPERATORS ALL HAVE THE FORMAT              */
 /*  'VARIABLE COMPARISON-OPERATOR VARIABLE', WE CAN BE SURE THAT   */
 /*  THE NUMBERS OF TOKENS IS 3 (PLUS ONE FOR THE 'VIRTUAL'         */
 /*  SEMICOLON)                                                     */
 /*******************************************************************/
0TOKENS_IN_STATEMENT = 4;
 OLD_TOKEN_IN_IF_STATEMENT = TOKEN_IN_IF_STATEMENT;
0/*******************************************************************/
 /*  HERE WE DO A LOOP OVER ALL TOKENS BETWEEN THE 'IF' AND 'THEN'  */
 /*  KEYWORDS...                                                    */
 /*******************************************************************/
0/*DO LOGIC_TOKEN = FIRST_TOKEN_IN_EXPRESSION TO
          FIRST_TOKEN_IN_EXPRESSION + OLD_TOKEN_IN_IF_STATEMENT;*/
0DO LOGIC_TOKEN = FIRST_TOKEN_IN_EXPRESSION TO
                  OLD_TOKEN_IN_IF_STATEMENT;
0   /****************************************************************/
    /* IF WE FIND A LOGIC_OPERATOR, WE SET THE SPECIAL BIT ARRAY    */
    /* CALLED LOGIC_OPERATOR TO THE APPRIPRIATE VALUE ('AND' IS     */
    /* '1'B, 'OR' IS '0'B')...                                      */
    /****************************************************************/
    IF RULEARRAY.LOGIC_OPERATOR(LOGIC_TOKEN)='1'B THEN
       DO;
       LOGIC_BIT = LOGIC_BIT + 1;
       IF RULEARRAY.CONTENT(LOGIC_TOKEN)='AND' THEN
          LOGIC_OPERATOR(LOGIC_BIT)='1'B;
       ELSE LOGIC_OPERATOR(LOGIC_BIT)='0'B;
       DO IF_TOKEN = FIRST_TOKEN_IN_EXPRESSION TO LOGIC_TOKEN;
0         /**********************************************************/
          /* LEAVE THE LOOP WHENEVER A COMPARISON OPERATOR IS FOUND */
          /**********************************************************/
0         IF ((RULEARRAY.CONTENT(IF_TOKEN) = '=')  !
              (RULEARRAY.CONTENT(IF_TOKEN) = '^=') !
              (RULEARRAY.CONTENT(IF_TOKEN) = '^')  !
              (RULEARRAY.CONTENT(IF_TOKEN) = '<')  !
              (RULEARRAY.CONTENT(IF_TOKEN) = '<=') !
              (RULEARRAY.CONTENT(IF_TOKEN) = '>')  !
              (RULEARRAY.CONTENT(IF_TOKEN) = '>=')) THEN LEAVE;
       END;
0      /**********************************************************/
       /* SET THE NECESSARY GLOBAL VARIABLES BEFORE CALLING THE  */
       /* ROUTINE TO CALCULATE THE EXPRESSION ON THE LEFT SIDE   */
       /* OF THE COMPARISON OPERATOR                             */
       /**********************************************************/
0      I = I + (LOGIC_BIT-1) * 4;
       COMPARISON_OPERATOR = IF_TOKEN;
       LEFT_IS_CHARACTER = '0'B;
       CALL EVALUATE_LEFT_SIDE;
0      /**********************************************************/
       /* SET A BIT TO REMEMBER THE TYPE OF VALUE CALCULATED AND */
       /* SET THE NECESSARY GLOBAL VARIABLES BEFORE CALLING THE  */
       /* ROUTINE TO CALCULATE THE EXPRESSION ON THE RIGHT SIDE  */
       /* OF THE COMPARISON OPERATOR                             */
       /**********************************************************/
0      IF SFARRAY.CHARACTER(1)='1'B THEN LEFT_IS_CHARACTER='1'B;
       TOKENS_IN_STATEMENT = 4;
       TOKEN_IN_IF_STATEMENT = COMPARISON_OPERATOR + 2;
       CALL EVALUATE_RIGHT_SIDE;
0      /**********************************************************/
       /* NOW CALL THE APPROPRIATE COMPARISON ROUTINE DEPENDING  */
       /* ON THE TYPE OF VALUES TO BE COMPARED...                */
       /**********************************************************/
0      IF ((SFARRAY.CHARACTER(1)='1'B) ! (LEFT_IS_CHARACTER='1'B)) THEN
          CALL CHARACTER_COMPARE;
       ELSE CALL DECIMAL_COMPARE;
0      /**********************************************************/
       /* NOW SET THE NEXT BIT IN THE ARRAY 'LOGIC' TO THE       */
       /* DEFINED VALUE ('1'B IF BOTH SIDES ARE EQUAL, '0'B      */
       /* IF THEY ARE NOT)...                                    */
       /**********************************************************/
0      LOGIC(LOGIC_BIT)=IF_IS_OK;
0      /**********************************************************/
       /* HERE WE ASSIGN THE VALUES TO ENABLE THE NEXT LOGICAL   */
       /* EXPRESSION TO BE EVALUATED...                          */
       /**********************************************************/
0      FIRST_TOKEN_IN_EXPRESSION = LOGIC_TOKEN + 1;
       TOKENS_IN_STATEMENT = 4;
       END;
 END;
1/*******************************************************************/
 /*  NOW WE PROCESS THE LAST LOGICAL EXPRESSION UP TO THE 'THEN'    */
 /*  KEYWORD...                                                     */
 /*******************************************************************/
 COMPARISON_OPERATOR = COMPARISON_OPERATOR + 4;
 /*FIRST_TOKEN_IN_EXPRESSION = FIRST_TOKEN_IN_EXPRESSION + 4;*/
 TOKEN_IN_IF_STATEMENT = TOKEN_IN_IF_STATEMENT + 1;
 TOKENS_IN_STATEMENT = 3;
 LEFT_IS_CHARACTER = '0'B;
 CALL EVALUATE_LEFT_SIDE;
 IF SFARRAY.CHARACTER(1)='1'B THEN LEFT_IS_CHARACTER='1'B;
 TOKEN_IN_IF_STATEMENT = TOKEN_IN_IF_STATEMENT + 3;
 CALL EVALUATE_RIGHT_SIDE;
 IF ((SFARRAY.CHARACTER(1)='1'B) ! (LEFT_IS_CHARACTER='1'B)) THEN
    CALL CHARACTER_COMPARE;
 ELSE CALL DECIMAL_COMPARE;
 LOGIC_BIT = LOGIC_BIT + 1;
 LOGIC(LOGIC_BIT)=IF_IS_OK;
1/*******************************************************************/
 /*  NOW ANALYSE THE WHOLE IF-EXPRESSION WHETHER ALL THOSE          */
 /*  AND'S AND OR'S GIVE A POSITIVE VALUE OR NOT                    */
 /*******************************************************************/
 DO LI=1 TO LOGIC_BIT-1;
    SELECT(LOGIC_OPERATOR(LI));
       WHEN('1'B) DO;
0         /**********************************************************/
          /* IF THE OPERATOR WAS AN 'AND' AND BOTH SIDES ARE TRUE,  */
          /* WE SET THE FIRST VALUE TO 'TRUE' ('1'B)...             */
          /**********************************************************/
0         IF ((LOGIC(1)='1'B) & (LOGIC(2)='1'B)) THEN LOGIC(1)='1'B;
          ELSE LOGIC(1)='0'B;
          END;
       WHEN('0'B) DO;
0         /**********************************************************/
          /* IF THE OPERATOR WAS AN 'OR' AND ONE OF THE 2 SIDES WAS */
          /* TRUE, WE SET THE FIRST VALUE TO 'TRUE' ('1'B)...       */
          /**********************************************************/
0         IF ((LOGIC(1)='1'B) ! (LOGIC(2)='1'B)) THEN LOGIC(1)='1'B;
          ELSE LOGIC(1)='0'B;
          END;
    END;
0   /**********************************************************/
    /* NOW WE 'COMPRESS' THE 'LOGIC' ARRAY BY SHIFTING ALL    */
    /* VALUES ONE POSITION TO THE RIGHT SIDE...               */
    /**********************************************************/
0   DO J=3 TO LOGIC_BIT;
       LOGIC(J-1)=LOGIC(J);
    END;
    LOGIC_BIT = LOGIC_BIT - 1;
0   /**********************************************************/
    /* NOW WE HAVE A 'LOGIC' ARRAY WHERE THE FIRST LOGIC      */
    /* EXPRESSION HAS BEEN EVALUATED AND ELIMINATED. WE DO    */
    /* THIS LOOP UNTIL THERE IS ONLY ONE VALUE LEFT OVER.     */
    /* THIS VALUE TELLS US WHETHER THE WHOLE 'IF'-CONDITION   */
    /* WAS TRUE...                                            */
    /**********************************************************/
0END;
 IF_IS_OK = LOGIC(1);
0END DO_LOGIC;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE COMPARES TWO CHARACTER VALUES         */
 /*******************************************************************/
0CHARACTER_COMPARE: PROCEDURE;
0/*******************************************************************/
 /*  HERE WE CHECK WHETHER THE TWO OPERANDS ARE COMPATIBLE. WE      */
 /*  LIKE TO COMPARE CHARACTER FIELDS WITH DECIMAL-FIXED-FIELDS...  */
 /*******************************************************************/
0IF (((SFARRAY.CHARACTER(1)='1'B) & (LEFT_IS_CHARACTER='0'B)) !
     ((SFARRAY.CHARACTER(1)^='1'B) & (LEFT_IS_CHARACTER='1'B)))
    THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI714                                    */
             /* MESSAGE: CHARACTER VALUE COMPARED WITH DECIMAL      */
             /*          VALUE                                      */
             /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
             /* EXPLANATION: THE RULES SPECIFIED AN IF-THEN-DO-END  */
             /*              STATEMENT WHERE ONE OF THE COMPARISON  */
             /*              OPERATORS WAS FOUND TO BE A CHARACTER  */
             /*              VALUE (OR FIELD) AND THE OTHER ONE     */
             /*              IS A DECIMAL-FIXED FIELD/VALUE.        */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: EVALUATE_EXPRESSION                      */
             /* USER RESPONSE: CHANGE THE RULES AND CORRECT THE     */
             /*                ERROR (E.G. BY SPECIFYING THE        */
             /*                STRING/DECIMAL FIELD IN QUESTION     */
             /*                WITH/WITHOUT QUOTATION MARKS).       */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                TRYING TO CORRECT THE ERROR          */
             /* EXAMPLE1: IF ABC.DECFIXED = '123' THEN DO;...       */
             /* EXAMPLE2: IF ABC.CHARFIELD = 123 THEN DO;...        */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('714',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(914);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
    END;
 ELSE DO;
0   /****************************************************************/
    /*  THE ACTUAL COMPARISON IS SIMPLE, BUT NOT ELEGANT:           */
    /*  CHECK THE OPERATOR'S TYPE AND DO THE ACCORDING              */
    /*  PL/I-COMPARISON                                             */
    /****************************************************************/
0   SELECT (RULEARRAY.CONTENT(COMPARISON_OPERATOR));
        WHEN('=') DO;
           IF CHAR_LEFT_TARGET = CHAR_RIGHT_TARGET THEN IF_IS_OK = '1'B;
           ELSE IF_IS_OK = '0'B;
           END;
        WHEN('^=') DO;
           IF CHAR_LEFT_TARGET ^= CHAR_RIGHT_TARGET THEN IF_IS_OK='1'B;
           ELSE IF_IS_OK = '0'B;
           END;
        WHEN('^') DO;
           IF CHAR_LEFT_TARGET ^= CHAR_RIGHT_TARGET THEN IF_IS_OK='1'B;
           ELSE IF_IS_OK = '0'B;
           END;
        WHEN('<') DO;
           IF CHAR_LEFT_TARGET < CHAR_RIGHT_TARGET THEN IF_IS_OK = '1'B;
           ELSE IF_IS_OK = '0'B;
           END;
        WHEN('<=') DO;
           IF CHAR_LEFT_TARGET <= CHAR_RIGHT_TARGET THEN IF_IS_OK='1'B;
           ELSE IF_IS_OK = '0'B;
           END;
        WHEN('>') DO;
           IF CHAR_LEFT_TARGET > CHAR_RIGHT_TARGET THEN IF_IS_OK = '1'B;
           ELSE IF_IS_OK = '0'B;
           END;
        WHEN('>=') DO;
           IF CHAR_LEFT_TARGET >= CHAR_RIGHT_TARGET THEN IF_IS_OK='1'B;
           ELSE IF_IS_OK = '0'B;
           END;
        OTHERWISE;
    END;
    END;
0END CHARACTER_COMPARE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE COMPARES TWO DECIMAL VALUES           */
 /*******************************************************************/
0DECIMAL_COMPARE: PROCEDURE;
0/*******************************************************************/
 /* NOW WE USE A SPECIAL ROUTINE TO ELIMINATE ROUNDING ERRORS       */
 /* CAUSED BY PL/I PRECISION PROBLEMS IN DIVIDE EXPRESSIONS         */
 /*******************************************************************/
 /* IN SHORT, THERE MAY BE RESULTS SUCH AS 2304.99999 OR 2156.7399  */
 /* WE HANDLE THIS BY LOOKING WHETHER THERE IS A SERIES OF '9'      */
 /* UP TO THE END OF THE NUMBER. IF TRUE, WE ROUND TO THE NUMBER    */
 /* WHICH IS THE LAST ONE DIFFERENT FROM '9' (IN OUR PREVIOUS       */
 /* EXAMPLE, IT COMES OUT AS 2305 AS WELL AS 2156.74)               */
 /*******************************************************************/
 /* IN CASE THE ROUTINE IS NOT NEEDED, ONE MAY DELETE ALL LINES     */
 /* BETWEEN THE STRINGS 'START OF ROUND ROUTINE' AND 'END OF        */
 /* ROUND-ROUTINE'...                                               */
 /*******************************************************************/
 /*****************    START OF ROUND-ROUTINE    ********************/
0DCL ROUND_STRING         CHAR(18) INIT(' ');
 DCL ROUND_OK             BIT(1)   INIT('0'B);
 ROUND_STRING = LEFT_TARGET;
 ROUND_LOOP1: DO N=1 TO 18;
    IF SUBSTR(ROUND_STRING,N,1)='.' THEN DO;
       DO O=N+1 TO 18;
          IF SUBSTR(ROUND_STRING,O,1)='9' THEN DO;
             DO P=O TO 18;
                ROUND_OK='1'B;
                IF SUBSTR(ROUND_STRING,P,1)=' ' THEN LEAVE ROUND_LOOP1;
                IF SUBSTR(ROUND_STRING,P,1)^='9' THEN ROUND_OK='0'B;
             END;
             LEAVE ROUND_LOOP1;
             END;
        END;
        END;
 END;
 IF ROUND_OK='1'B THEN DO;
    LEFT_TARGET_SCALE = O - N - 1;
    SELECT(LEFT_TARGET_SCALE);
       WHEN(1) LEFT_TARGET = ROUND(LEFT_TARGET,1);
       WHEN(2) LEFT_TARGET = ROUND(LEFT_TARGET,2);
       WHEN(3) LEFT_TARGET = ROUND(LEFT_TARGET,3);
       WHEN(4) LEFT_TARGET = ROUND(LEFT_TARGET,4);
       WHEN(5) LEFT_TARGET = ROUND(LEFT_TARGET,5);
       OTHERWISE;
    END;
 END;
 ROUND_OK = '0'B;
 ROUND_STRING = RIGHT_TARGET;
 ROUND_LOOP2: DO N=1 TO 18;
    IF SUBSTR(ROUND_STRING,N,1)='.' THEN DO;
       DO O=N+1 TO 18;
          IF SUBSTR(ROUND_STRING,O,1)='9' THEN DO;
             DO P=O TO 18;
                ROUND_OK='1'B;
                IF SUBSTR(ROUND_STRING,P,1)=' ' THEN LEAVE ROUND_LOOP2;
                IF SUBSTR(ROUND_STRING,P,1)^='9' THEN ROUND_OK='0'B;
             END;
             LEAVE ROUND_LOOP2;
             END;
        END;
        END;
 END;
 IF ROUND_OK='1'B THEN DO;
    RIGHT_TARGET_SCALE = O - N - 1;
    SELECT(RIGHT_TARGET_SCALE);
       WHEN(1) RIGHT_TARGET = ROUND(RIGHT_TARGET,1);
       WHEN(2) RIGHT_TARGET = ROUND(RIGHT_TARGET,2);
       WHEN(3) RIGHT_TARGET = ROUND(RIGHT_TARGET,3);
       WHEN(4) RIGHT_TARGET = ROUND(RIGHT_TARGET,4);
       WHEN(5) RIGHT_TARGET = ROUND(RIGHT_TARGET,5);
       OTHERWISE;
    END;
 END;
 /******************    END OF ROUND-ROUTINE    ********************/
 /******************************************************************/
 /* NOW WE ROUND THE LONGER VALUE TO FIT THE SHORTER VALUE'S SCALE */
 /******************************************************************/
 IF LEFT_TARGET_SCALE > RIGHT_TARGET_SCALE THEN DO;
    SELECT(RIGHT_TARGET_SCALE);
       WHEN(1) LEFT_TARGET = ROUND(LEFT_TARGET,1);
       WHEN(2) LEFT_TARGET = ROUND(LEFT_TARGET,2);
       WHEN(3) LEFT_TARGET = ROUND(LEFT_TARGET,3);
       WHEN(4) LEFT_TARGET = ROUND(LEFT_TARGET,4);
       WHEN(5) LEFT_TARGET = ROUND(LEFT_TARGET,5);
       OTHERWISE;
    END;
    END;
 ELSE DO;
    SELECT(LEFT_TARGET_SCALE);
       WHEN(1) RIGHT_TARGET = ROUND(RIGHT_TARGET,1);
       WHEN(2) RIGHT_TARGET = ROUND(RIGHT_TARGET,2);
       WHEN(3) RIGHT_TARGET = ROUND(RIGHT_TARGET,3);
       WHEN(4) RIGHT_TARGET = ROUND(RIGHT_TARGET,4);
       WHEN(5) RIGHT_TARGET = ROUND(RIGHT_TARGET,5);
       OTHERWISE;
    END;
    END;
 /******************************************************************/
 /* AND HERE IS THE ACTUAL COMPARISON, FINALLY...                  */
 /******************************************************************/
 SELECT (RULEARRAY.CONTENT(COMPARISON_OPERATOR));
     WHEN('=') DO;
        IF LEFT_TARGET = RIGHT_TARGET THEN IF_IS_OK = '1'B;
        ELSE IF_IS_OK = '0'B;
        END;
     WHEN('^=') DO;
        IF LEFT_TARGET ^= RIGHT_TARGET THEN IF_IS_OK = '1'B;
        ELSE IF_IS_OK = '0'B;
        END;
     WHEN('^') DO;
        IF LEFT_TARGET ^= RIGHT_TARGET THEN IF_IS_OK = '1'B;
        ELSE IF_IS_OK = '0'B;
        END;
     WHEN('<') DO;
        IF LEFT_TARGET < RIGHT_TARGET THEN IF_IS_OK = '1'B;
        ELSE IF_IS_OK = '0'B;
        END;
     WHEN('<=') DO;
        IF LEFT_TARGET <= RIGHT_TARGET THEN IF_IS_OK = '1'B;
        ELSE IF_IS_OK = '0'B;
        END;
     WHEN('>') DO;
        IF LEFT_TARGET > RIGHT_TARGET THEN IF_IS_OK = '1'B;
        ELSE IF_IS_OK = '0'B;
        END;
     WHEN('>=') DO;
        IF LEFT_TARGET >= RIGHT_TARGET THEN IF_IS_OK = '1'B;
        ELSE IF_IS_OK = '0'B;
        END;
     OTHERWISE;
 END;
0END DECIMAL_COMPARE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE EVALUATES THE LEFT SIDE OF AN         */
 /*            'IF' COMPARISON STATEMENT                            */
 /*******************************************************************/
0EVALUATE_LEFT_SIDE: PROCEDURE;
0/*******************************************************************/
 /*  SET THE GLOBAL VALUES FOR THE ACTUAL CALCULATION...            */
 /*******************************************************************/
0 SAVE_I = I;
  I = FIRST_TOKEN_IN_EXPRESSION - 2;
  TOKENS_IN_STATEMENT = COMPARISON_OPERATOR - I + 1;
  CALL CALCULATE_ASSIGNMENT;
0/*******************************************************************/
 /*  IF IT WAS A CHARACTER FIELD, WE GET THE VALUE FROM THE         */
 /*  SFARRAY'S CHARACTER FIELD, OTHERWISE FROM THE DEC_FIELD        */
 /*******************************************************************/
0 IF SFARRAY.CHARACTER(1)='1'B THEN DO;
     CHAR_LEFT_TARGET = SFARRAY.CHAR_FIELD(1);
     LEFT_BLANKPOSITION = INDEX(CHAR_LEFT_TARGET,' ');
     END;
  ELSE DO;
    LEFT_TARGET = SFARRAY.DEC_FIELD(1);
    LEFT_TARGET_SCALE = SFARRAY.SCALE(1);
    END;
0END EVALUATE_LEFT_SIDE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE EVALUATES THE RIGHT SIDE OF AN        */
 /*            IF-COMPARISON STATEMENT                              */
 /*******************************************************************/
0EVALUATE_RIGHT_SIDE: PROCEDURE;
  /* THE DCL RIGHT_LEFT_TARGET MAKES NO SENSE, IT IS JUST DEFINED
     TO AVOID THE ENTERPRISE PLI COMPILER ERROR "VARIABLE IS IMPLICITELY
     DECLARED". THIS FUNCTION DID NEVER WORK IN THE PAST AS THE VARIABLE
     WAS IMPLICITELLY DECLARED BY THE COMPILER, AND THEREFORE THE RESULT
     WAS UNPREDICTABLE GHA */
  DCL RIGHT_LEFT_TARGET CHAR(1) INIT(' ');
  I = COMPARISON_OPERATOR - 1;
  TOKENS_IN_STATEMENT = TOKEN_IN_IF_STATEMENT - I + 1;
  CALL CALCULATE_ASSIGNMENT;
0/*******************************************************************/
 /*  SAME AS IN THE FUNCTION BEFORE: GET THE CORRECT VALUE FROM     */
 /*  THE SFARRAY                                                    */
 /*******************************************************************/
0 IF SFARRAY.CHARACTER(1)='1'B THEN DO;
     CHAR_RIGHT_TARGET = SFARRAY.CHAR_FIELD(1);
     RIGHT_BLANKPOSITION = INDEX(RIGHT_LEFT_TARGET,' ');
     END;
  ELSE DO;
     RIGHT_TARGET = SFARRAY.DEC_FIELD(1);
     RIGHT_TARGET_SCALE = SFARRAY.SCALE(1);
     END;
0END EVALUATE_RIGHT_SIDE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE CALCULATES AN ASSIGNMENT STATEMENT    */
 /*******************************************************************/
 /*  PARAMETERS: TOKENS_IN_STATEMENT.... NUMBER OF TOKENS IN        */
 /*                    STATEMENT (INCLUDING SEMICOLON)              */
 /*              I.... FIRST TOKEN IN THE ASSIGNMENT                */
 /*                    STATEMENT                                    */
 /*******************************************************************/
0DO_ASSIGNMENT: PROCEDURE;
0/*******************************************************************/
 /*  IF WE HAVE A 'RETURN' STATEMENT IN THE IF-THEN-DO-BLOCK,       */
 /*  WE END THE CURRENT RULE IMMEADIATELY...                        */
 /*******************************************************************/
0IF ((RULEARRAY.KEYWORD(I)='1'B) &
     (RULEARRAY.CONTENT(I)='RETURN')) THEN GOTO ABEND;
0/*******************************************************************/
 /*  IF THE RIGHT SIDE OF AN ASSIGNMENT STATEMENT IS A FUNCTION     */
 /*  THEN CALL A SPECIAL ROUTINE...                                 */
 /*******************************************************************/
0IF RULEARRAY.FUNCTION(I+2)='1'B THEN CALL DO_FUNCTION;
 ELSE DO;
    IF RULEARRAY.ASSIGNMENT(I+1)='1'B THEN
       DO;
0      /************************************************************/
       /*  CHECK WHETHER WE HAVE A USERVARIABLE OR A DATABASE      */
       /*  VARIABLE ON THE LEFT SIDE (CONSTANTS OR WHATEVER ARE    */
       /*  OBVIOUSLY NOT ALLOWED)...                               */
       /************************************************************/
       IF ((RULEARRAY.DB_VARIABLE(I)='1'B) !
          (RULEARRAY.USER_VARIABLE(I)='1'B)) THEN
          DO;
          ASSIGNED_VARIABLE_NAME=RULEARRAY.CONTENT(I);
0         /*********************************************************/
          /*  CALCULATE THE RIGHT SIDE OF THE ASSIGNMENT STATEMENT */
          /*********************************************************/
0         CALL CALCULATE_ASSIGNMENT;
0         /*********************************************************/
          /*  ASSIGN THE CALCULATED VALUE TO THE VARIABLE AT THE   */
          /*  LEFT SIDE OF THE ASSIGNMENT STATEMENT                */
          /*********************************************************/
0         CALL ASSIGN_CALCULATED_VALUE;
          END;
       ELSE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI715                                    */
             /* MESSAGE: MISPLACED ASSIGNMENT OPERATOR              */
             /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
             /* EXPLANATION: THE INTERPRETER FOUND A STATEMENT      */
             /*              WHERE THE SECOND TOKEN WAS AN          */
             /*              ASSIGNMENT OPERATOR, BUT THE FIRST     */
             /*              TOKEN WAS NEITHER A DB-VARIABLE NOR    */
             /*              A USER-VARIABLE                        */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_ASSIGNMENT                            */
             /* USER RESPONSE: CHANGE THE RULES AND CORRECT THE     */
             /*                STATEMENT IN ERROR                   */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                TRYING TO CORRECT THE ERROR          */
             /* EXAMPLE: 4 = FOOBAR;                                */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('715',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(915);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
          END;
       END;
    ELSE DO;
         /*******************************************************/
         /* ----------------     E R R O R     ---------------- */
         /* MSGCODE: QCHI716                                    */
         /* MESSAGE: ASSIGNMENT STATEMENT FOUND WITH INCORRECT  */
         /*          STRUCTURE                                  */
         /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
         /* EXPLANATION: THE INTERPRETER FOUND AN ASSIGNMENT    */
         /*              STATEMENT WHERE THE SECOND TOKEN WAS   */
         /*              NOT THE ASSIGNMENT OPERATOR.           */
         /* SEVERITY: 8                                         */
         /* PROCEDURE: DO_ASSIGNMENT                            */
         /* USER RESPONSE: CHANGE THE RULES AND CORRECT THE     */
         /*                STATEMENT IN ERROR                   */
         /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
         /*                TRYING TO CORRECT THE ERROR          */
         /* EXAMPLE: FOO BAR = SOMETHING;                       */
         /*                                                     */
         /*******************************************************/
         LINECHAR =  RULEARRAY.LINENUMBER(I);
         IF SP.RUN_MODE = 'M' THEN DO;
            INTMSG ('716',SUBSTR(LINECHAR,7,3)
                          !! ',' !! SP.RULE_NAME);
         END;
         ELSE DO;
            QCHNOT(916);
            SP.EOP_FROM_RULE = '1'B;
            SP.ROLB_REQU     = '1'B;
            GOTO ABEND;
         END;
       END;
    END;
0END DO_ASSIGNMENT;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE ASSIGNS THE CALCULATED VALUE OF THE   */
 /*            RIGHT SIDE OF THE ASSIGNMENT STATEMENT (TO BE FOUND  */
 /*            IN SFARRAY(1)) TO THE VARIABLE ON THE LEFT SIDE OF   */
 /*            THE ASSIGNMENT STATEMENT                             */
 /*******************************************************************/
0ASSIGN_CALCULATED_VALUE: PROCEDURE;
0IF RULEARRAY.DB_VARIABLE(I)='1'B THEN DO;
0   /**************************************************************/
    /* THE LEFT SIDE OF THE ASSIGNMENT STATEMENT IS A DB_VARIABLE */
    /* SET THE GLOBAL VARIABLES FOR THE SUBPROCEDURES             */
    /**************************************************************/
0   TOKEN = I;
0   /**************************************************************/
    /* SEARCH THE VALUES READ FROM QCHSTSTR (STRUCTURE OFFSETS    */
    /* OF THE DB2-DATABASE-VARIABLES) TO GET INFORMATION ABOUT    */
    /* THE VARIABLE USED IN THE EXPRESSION...                     */
    /**************************************************************/
    CALL FIND_DB_VARIABLE;
0   /**************************************************************/
    /* SEARCH THROUGH THE HARDCODED LIST OF STRUCTURES (DATABASES)*/
    /* TO FIND THE NAME OF THE POINTER THE STRUCTURE IS BASED ON  */
    /**************************************************************/
0   CALL FIND_STRUCTURE;
    IF VARTABLE.TYPE(VARIABLE) = 'D' THEN DO;
0      /***********************************************************/
       /* THE DB_VARIABLE IS A DECIMAL-FIXED-FIELD                */
       /***********************************************************/
0      CALL ASSIGN_RIGHT_TO_DECFIXED;
       END;
    ELSE DO;
0      /***********************************************************/
       /* THE DB_VARIABLE IS A CHAR-FIELD                         */
       /***********************************************************/
0      CALL ASSIGN_RIGHT_TO_CHAR;
       END;
    END;
 ELSE DO;
0   /****************************************************************/
    /* THE LEFT SIDE OF THE ASSIGNMENT STATEMENT IS A USER_VARIABLE */
    /****************************************************************/
0   CALL ASSIGN_RIGHT_TO_USER_VARIABLE;
    END;
0END ASSIGN_CALCULATED_VALUE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE ASSIGNS THE CALCULATED VALUE OF THE   */
 /*            RIGHT SIDE OF THE ASSIGNMENT STATEMENT (TO BE FOUND  */
 /*            IN SFARRAY(1)) TO THE USERVAR ON THE LEFT SIDE OF    */
 /*            THE ASSIGNMENT STATEMENT                             */
 /*******************************************************************/
0ASSIGN_RIGHT_TO_USER_VARIABLE: PROCEDURE;
0/*******************************************************************/
 /* STEPS:                                                          */
 /* 1. SEARCH WHETHER USER_VARIABLE ALREADY EXISTS (IN USER_VARS)   */
 /* 2. A) YES  -->                                                  */
 /*       REPLACE USERVAR'S CONTENT                                 */
 /*    B) NO   -->                                                  */
 /*       CREATE A NEW ENTRY IN THE TABLE USER_VARS AND INCREMENT   */
 /*       THE COUNTER                                               */
 /*******************************************************************/
 /*IF (SUBSTR(RULEARRAY.CONTENT(I),9,1) != ' ') THEN DO; */
    /*******************************************************/
    /* ----------------     E R R O R     ---------------- */
    /* MSGCODE: QCHI775                                    */
    /* MESSAGE: NAME OF USERVARIABLE *V TOO LONG IN        */
    /*          RULE *V                                    */
    /* MESSAGECLASS: INTERPRETATION WARNING MESSAGE        */
    /* EXPLANATION: THE INTERPRETER FOUND A USERVARIABLE   */
    /*              WHOSE NAME WAS LONGER THAN 8 CHARACTERS*/
    /*              AND GAVE THIS WARNING MESSAGE.         */
    /*              NOTE THAT THIS WILL CAUSE THE PRINTER  */
    /*              MODULE TO PRINT THE VARIABLE'S NAME    */
    /*              INSTEAD OF ITS CONTENT...              */
    /* SEVERITY: 8                                         */
    /* PROCEDURE: DO_ASSIGNMENT                            */
    /* USER RESPONSE: CHANGE THE RULES AND SHORTEN THE     */
    /*                VARIABLE'S NAME                      */
    /* SYSTEM ACTION: THE INTERPRETER CONTINUES            */
    /* EXAMPLE: LONGUSERVAR = 3.14;                        */
    /*                                                     */
    /*******************************************************/
  /*  LINECHAR =  RULEARRAY.LINENUMBER(I);
    INTMSG ('775',RULEARRAY.CONTENT(I) !! ',' !!
                  SP.RULE_NAME);
    END;*/
0DO USV_COUNT = 1 TO USV_MAX;
    IF USER_VARS.NAME(USV_COUNT) = RULEARRAY.CONTENT(I) THEN LEAVE;
 END;
0IF USV_COUNT > USV_MAX THEN CALL CREATE_NEW_USER_VARIABLE;
 ELSE CALL REPLACE_USER_VARIABLE;
0END ASSIGN_RIGHT_TO_USER_VARIABLE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE CREATES A NEW ENTRY IN THE ARRAY      */
 /*            USER_VARS FOR A NEW USER VARIABLE                    */
 /*******************************************************************/
0CREATE_NEW_USER_VARIABLE: PROCEDURE;
0/*******************************************************************/
 /*  INCREMENT THE COUNTER                                          */
 /*******************************************************************/
0USV_MAX = USV_MAX + 1;
0/*******************************************************************/
 /*  CLEAR THE CONTENT AND ASSIGN THE USERVARIABLE'S NAME           */
 /*******************************************************************/
0USER_VARS(USV_MAX)='';
 USER_VARS.NAME(USV_MAX) = RULEARRAY.CONTENT(I);
0/*******************************************************************/
 /*  THE USERVARIABLE WILL BE CHARACTER                             */
 /*******************************************************************/
0IF SFARRAY.VAR_TYPE.CHARACTER(1)='1'B THEN DO;
         USER_VARS.TYPE.CHARACTER(USV_MAX)='1'B;
    USER_VARS.CONTENT.CHARACTER(USV_MAX)=
         SFARRAY.CALCULATION_FIELD.CHAR_FIELD(1);
    USER_VARS.LENGTH.SCALE(USV_MAX) = 0;
    IF (SFARRAY.PRECISION.DIGITS(1) = 0) THEN
       USER_VARS.LENGTH.PRECISION(USV_MAX) = 1;
    ELSE
       USER_VARS.LENGTH.PRECISION(USV_MAX) =
            SFARRAY.PRECISION.DIGITS(1);
         END;
 ELSE DO;
0/*******************************************************************/
 /*  THE USERVARIABLE WILL BE DECIMAL                               */
 /*******************************************************************/
0   USER_VARS.TYPE.DEC_FIXED(USV_MAX)='1'B;
    USER_VARS.CONTENT.DEC_FIXED(USV_MAX)=
         SFARRAY.CALCULATION_FIELD.DEC_FIELD(1);
    USER_VARS.LENGTH.PRECISION(USV_MAX) = SFARRAY.PRECISION.DIGITS(1);
    USER_VARS.LENGTH.SCALE(USV_MAX) = SFARRAY.PRECISION.SCALE(1);
    END;
0END CREATE_NEW_USER_VARIABLE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE REPLACES AN ALREADY EXISTING USER     */
 /*            VARIABLE IN THE ARRAY USER_VARS                      */
 /*******************************************************************/
0REPLACE_USER_VARIABLE: PROCEDURE;
0/*******************************************************************/
 /*  HERE WE CHECK WHETHER THE TYPES ARE COMPATIBLE                 */
 /*******************************************************************/
0IF ((SFARRAY.VAR_TYPE.CHARACTER(1)='1'B) &
    (USER_VARS.TYPE.CHARACTER(USV_COUNT)='1'B)) THEN DO;
0    /****************************************************************/
     /*  THE OLD VARIABLE WAS CHARACTER, THE NEW ONE IS CHARACTER -> */
     /*  WE REPLACE IT...                                            */
0    /****************************************************************/
    USER_VARS.CONTENT.CHARACTER(USV_COUNT)=
         SFARRAY.CALCULATION_FIELD.CHAR_FIELD(1);
    USER_VARS.LENGTH.SCALE(USV_COUNT) = 0;
    IF (SFARRAY.PRECISION.DIGITS(1) = 0) THEN
       USER_VARS.LENGTH.PRECISION(USV_COUNT) = 1;
    ELSE
       USER_VARS.LENGTH.PRECISION(USV_COUNT) =
            SFARRAY.PRECISION.DIGITS(1);
    END;
 ELSE IF ((SFARRAY.VAR_TYPE.DEC_FIXED(1)='1'B) &
    ((TYPE_CONVERSION = '1'B) !
    (USER_VARS.TYPE.DEC_FIXED(USV_COUNT)='1'B))) THEN DO;
0    /****************************************************************/
     /*  THE OLD VARIABLE WAS DECIMAL, THE NEW ONE IS DECIMAL        */
     /*  (OR WE HAVE BEEN IN ONE OF THE SPECIAL TYPE CONVERSION      */
     /*  FUNCTIONS LIKE 'ZERO' AND 'DATE'), SO WE REPLACE IT         */
0    /****************************************************************/
     USER_VARS.CONTENT.DEC_FIXED(USV_COUNT)=
          SFARRAY.CALCULATION_FIELD.DEC_FIELD(1);
     USER_VARS.LENGTH.PRECISION(USV_COUNT)=SFARRAY.PRECISION.DIGITS(1);
     USER_VARS.LENGTH.SCALE(USV_COUNT) = SFARRAY.PRECISION.SCALE(1);
     END;
     ELSE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI717                                    */
             /* MESSAGE: INVALID TYPE OF USERVARIABLE               */
             /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
             /* EXPLANATION: THE INTERPRETER FOUND AN ASSIGNMENT    */
             /*              TO A USER VARIABLE AND DETECTED        */
             /*              THAT THE SAME USER VARIABLE HAS BEEN   */
             /*              USED IN A PREVIOUS RULE, BUT HAD A     */
             /*              DIFFERENT TYPE  (E.G. WAS USED AS      */
             /*              A CHARACTER VARIABLE, BUT IS NOW       */
             /*              ASSIGNED A DEC-FIXED FIELD)            */
             /* SEVERITY: 4                                         */
             /* PROCEDURE: REPLACE_USER_VARIABLE                    */
             /* USER RESPONSE: CHECK THE RULES AND USE A DIFFERENT  */
             /*              VARIABLE NAME FOR THE VARIABLE IN      */
             /*              QUESTION                               */
             /* PROGRAMMER RESPONSE: NONE                           */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS              */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('717',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(917);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
         END;
0END REPLACE_USER_VARIABLE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE ASSIGNS THE CALCULATED VALUE OF THE   */
 /*            RIGHT SIDE OF THE ASSIGNMENT STATEMENT (TO BE FOUND  */
 /*            IN SFARRAY(1)) TO THE VARIABLE ON THE LEFT SIDE OF   */
 /*            THE ASSIGNMENT STATEMENT                             */
 /*******************************************************************/
0ASSIGN_RIGHT_TO_CHAR: PROCEDURE;
0/*******************************************************************/
 /*  WE LOOK AT THE VARTABLE WHICH HOLDS THE OFFSET OF THE FOUND    */
 /*  VARIABLE TO THE BEGINNING OF ITS STRUCTURE AND ADD 1 TO THE    */
 /*  OFFSET. THEN WE SET A POINTER TO THAT ADDRESS AND DECLARE A    */
 /*  MAXIMUM-LENGTH CHARACTER FIELD BASED ON THE ADDRESS FOUND      */
 /*  ABOVE. WE ASSIGN THE CALCULATED VALUE TO THIS CHARACTER FIELD  */
 /*  WHICH CAUSES THE OLD FIELD TO BE OVERLAYED WITH THE NEW VALUE  */
 /*******************************************************************/
0/*IF (VARTABLE.TYPE(VARIABLE)='V') THEN
    OFFSET_INDEX=VARTABLE.OFFSET(VARIABLE)-1;
 ELSE OFFSET_INDEX=VARTABLE.OFFSET(VARIABLE)+1;*/
 OFFSET_INDEX=VARTABLE.OFFSET(VARIABLE)+1;
0OFFSET_TABLE_POINTER = STRUCTURE_POINTER;

     /*   HIER KRIEGT DER POINTER SEINE ADRESSE  */
 CHAR_PTR = ADDR(OFFSET_TABLE(OFFSET_INDEX));

 DCL LENGTH_FIELD_POINTER POINTER;
 LENGTH_FIELD_POINTER = ADDR(OFFSET_TABLE(OFFSET_INDEX-2));
                                /* IVAN SHOULDN'T ADD +2 */
     /*   HIER IST DIE DEKLARATION DES FELDES   */
 DCL CHAR_OVERLAY CHAR(255) BASED(CHAR_PTR);
 /*---
 DCL VARCHAR_OVERLAY CHAR(255) VAR BASED(CHAR_PTR);
 ---*/
 DCL VARCHAR_OVERLAY CHAR(255) VAR BASED(LENGTH_FIELD_POINTER);

 DCL VARCHAR_OVERLAY_LENGTH BIN FIXED(15) BASED(LENGTH_FIELD_POINTER);
 DCL CHAR1_HELP    CHAR(18) INIT(' ');
 DCL CHAR2_HELP    CHAR(18) INIT(' ');
 DCL FIRST_NON_BLANK_POSITION    BIN FIXED(15) INIT(0);
0IF SFARRAY.CHARACTER(1)='1'B THEN DO;
    IF (VARTABLE.TYPE(VARIABLE)='V') THEN DO;
       VARCHAR_OVERLAY =
                  SUBSTR(SFARRAY.CHAR_FIELD(1),1,SFARRAY.DIGITS(1));
       END;
0   ELSE SUBSTR(CHAR_OVERLAY,1,VARTABLE.LENGTH.PRECISION(VARIABLE)) =
         SUBSTR(SFARRAY.CHAR_FIELD(1),1,
                VARTABLE.LENGTH.PRECISION(VARIABLE));
    END;
 ELSE DO;
0   /****************************************************************/
    /*  IF THE FIELD IS NOT CHARACTER, WE ASSIGN THE CALCULATED VAL.*/
    /*  UP TO THE FIRST NON-BLANK WITH THE CALCULATED FIELD'S       */
    /*  VALUE.                                                      */
    /****************************************************************/
0   CHAR1_HELP=SFARRAY.DEC_FIELD(1);
    FIRST_NON_BLANK_POSITION = VERIFY(CHAR1_HELP,' ');
    CHAR2_HELP = SUBSTR(CHAR1_HELP,FIRST_NON_BLANK_POSITION,
                 SFARRAY.DIGITS(1)+1);
    SUBSTR(CHAR_OVERLAY,1,VARTABLE.LENGTH.PRECISION(VARIABLE)) =
             CHAR2_HELP;
    END;
0END ASSIGN_RIGHT_TO_CHAR;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE ASSIGNS THE CALCULATED VALUE OF THE   */
 /*            RIGHT SIDE OF THE ASSIGNMENT STATEMENT (TO BE FOUND  */
 /*            IN SFARRAY(1)) TO THE VARIABLE ON THE LEFT SIDE OF   */
 /*            THE ASSIGNMENT STATEMENT                             */
 /*******************************************************************/
0ASSIGN_RIGHT_TO_DECFIXED: PROCEDURE;
0/*******************************************************************/
 /*  WE LOOK AT THE VARTABLE WHICH HOLDS THE OFFSET OF THE FOUND    */
 /*  VARIABLE TO THE BEGINNING OF ITS STRUCTURE AND ADD 1 TO THE    */
 /*  OFFSET. THEN WE SET A POINTER TO THAT ADDRESS AND DECLARE A    */
 /*  MAXIMUM-LENGTH PICTURE - FIELD BASED ON THE ADDRESS FOUND      */
 /*  ABOVE. WE ASSIGN THE CALCULATED VALUE TO THIS PICTURE   FIELD  */
 /*  WHICH CAUSES THE OLD FIELD TO BE OVERLAYED WITH THE NEW VALUE  */
 /*******************************************************************/
0OFFSET_INDEX=VARTABLE.OFFSET(VARIABLE)+1;
 OFFSET_TABLE_POINTER = STRUCTURE_POINTER;
 DECFIXED_PTR = ADDR(OFFSET_TABLE(OFFSET_INDEX));
 IF SFARRAY.CHARACTER(1)='1'B THEN DO;
0   /****************************************************************/
    /*  HERE WE SEARCH FOR NON-NUMERIC CHARACTERS IN THE TARGET     */
    /*  FIELD AND REPLACE THEM WITH ZEROES. THIS IS NECESSARY TO    */
    /*  AVOID DATA EXCEPTIONS WHEN ASSIGNING THE FIELD LATER        */
    /****************************************************************/
0   DO N=1 TO SFARRAY.DIGITS(1);
    IF (VERIFY(SUBSTR(SFARRAY.CHAR_FIELD(1),N,1),NUMERIC))>0
        THEN SUBSTR(SFARRAY.CHAR_FIELD(1),N,1)='0';
    END;
0   /****************************************************************/
    /*  ... AND HERE COMES THE DECLARATION AND ASSIGNMENT           */
    /*  TO AN INTERMEDIATE VARIABLE...                              */
    /****************************************************************/
0   DCL PIC_FIELD PICTURE '99999999999V9999';
    PIC_FIELD = SUBSTR(SFARRAY.CHAR_FIELD(1),1,
                SFARRAY.DIGITS(1));
    END;
0/****************************************************************/
 /*  HERE WE HAVE A BIG SELECT OVER THE SOURCE VARIABLE'S        */
 /*  PRECISION AND SCALE. IT IS NECESSARY DUE TO CERTAIN         */
 /*  PL/I COMPILER LIMITATIONS...                                */
 /****************************************************************/
 /*  THE TYPE OF ACTION IS ALWAYS THE SAME:                      */
 /*  - WE DECLARE A DECIMAL-FIXED-FIELD OF A CERTAIN LENGTH AND  */
 /*    PRECISION (THE TARGET'S FIELD LENGTH AND PRECISION, THAT  */
 /*    IS)                                                       */
 /*  - WE ASSIGN THE APPROPRIATE VALUE (DEPENDING ON THE SOURCE  */
 /*    FIELD'S TYPE) TO IT                                       */
 /****************************************************************/
0SELECT(VARTABLE.LENGTH.PRECISION(VARIABLE));
    WHEN(1) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_1_0    DEC FIXED(1,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_1_0 = PIC_FIELD;
             ELSE DECFIXED_1_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_1_1    DEC FIXED(1,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_1_1 = PIC_FIELD;
             ELSE DECFIXED_1_1 = SFARRAY.DEC_FIELD(1);
             END;
       END;
    END;
    WHEN(2) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_2_0    DEC FIXED(2,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_2_0 = PIC_FIELD;
             ELSE DECFIXED_2_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_2_1    DEC FIXED(2,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_2_1 = PIC_FIELD;
             ELSE DECFIXED_2_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_2_2    DEC FIXED(2,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_2_2 = PIC_FIELD;
             ELSE DECFIXED_2_2 = SFARRAY.DEC_FIELD(1);
             END;
          END;
       END;
    WHEN(3) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_3_0    DEC FIXED(3,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_3_0 = PIC_FIELD;
             ELSE DECFIXED_3_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_3_1    DEC FIXED(3,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_3_1 = PIC_FIELD;
             ELSE DECFIXED_3_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_3_2    DEC FIXED(3,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_3_2 = PIC_FIELD;
             ELSE DECFIXED_3_2 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(3) DO;
             DCL DECFIXED_3_3    DEC FIXED(3,3)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_3_3 = PIC_FIELD;
             ELSE DECFIXED_3_3 = SFARRAY.DEC_FIELD(1);
             END;
       END;
       END;
    WHEN(4) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_4_0    DEC FIXED(4,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_4_0 = PIC_FIELD;
             ELSE DECFIXED_4_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_4_1    DEC FIXED(4,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_4_1 = PIC_FIELD;
             ELSE DECFIXED_4_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_4_2    DEC FIXED(4,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_4_2 = PIC_FIELD;
             ELSE DECFIXED_4_2 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(3) DO;
             DCL DECFIXED_4_3    DEC FIXED(4,3)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_4_3 = PIC_FIELD;
             ELSE DECFIXED_4_3 = SFARRAY.DEC_FIELD(1);
             END;
       END;
       END;
    WHEN(5) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_5_0    DEC FIXED(5,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_5_0 = PIC_FIELD;
             ELSE DECFIXED_5_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_5_1    DEC FIXED(5,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_5_1 = PIC_FIELD;
             ELSE DECFIXED_5_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_5_2    DEC FIXED(5,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_5_2 = PIC_FIELD;
             ELSE DECFIXED_5_2 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(3) DO;
             DCL DECFIXED_5_3    DEC FIXED(5,3)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_5_3 = PIC_FIELD;
             ELSE DECFIXED_5_3 = SFARRAY.DEC_FIELD(1);
             END;
       END;
       END;
    WHEN(6) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_6_0    DEC FIXED(6,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_6_0 = PIC_FIELD;
             ELSE DECFIXED_6_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_6_1    DEC FIXED(6,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_6_1 = PIC_FIELD;
             ELSE DECFIXED_6_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_6_2    DEC FIXED(6,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_6_2 = PIC_FIELD;
             ELSE DECFIXED_6_2 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(3) DO;
             DCL DECFIXED_6_3    DEC FIXED(6,3)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_6_3 = PIC_FIELD;
             ELSE DECFIXED_6_3 = SFARRAY.DEC_FIELD(1);
             END;
       END;
       END;
    WHEN(7) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_7_0    DEC FIXED(7,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_7_0 = PIC_FIELD;
             ELSE DECFIXED_7_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_7_1    DEC FIXED(7,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_7_1 = PIC_FIELD;
             ELSE DECFIXED_7_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_7_2    DEC FIXED(7,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_7_2 = PIC_FIELD;
             ELSE DECFIXED_7_2 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(3) DO;
             DCL DECFIXED_7_3    DEC FIXED(7,3)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_7_3 = PIC_FIELD;
             ELSE DECFIXED_7_3 = SFARRAY.DEC_FIELD(1);
             END;
       END;
       END;
    WHEN(8) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_8_0    DEC FIXED(8,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_8_0 = PIC_FIELD;
             ELSE DECFIXED_8_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_8_1    DEC FIXED(8,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_8_1 = PIC_FIELD;
             ELSE DECFIXED_8_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_8_2    DEC FIXED(8,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_8_2 = PIC_FIELD;
             ELSE DECFIXED_8_2 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(3) DO;
             DCL DECFIXED_8_3    DEC FIXED(8,3)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_8_3 = PIC_FIELD;
             ELSE DECFIXED_8_3 = SFARRAY.DEC_FIELD(1);
             END;
       END;
       END;
    WHEN(9) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_9_0    DEC FIXED(9,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_9_0 = PIC_FIELD;
             ELSE DECFIXED_9_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_9_1    DEC FIXED(9,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_9_1 = PIC_FIELD;
             ELSE DECFIXED_9_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_9_2    DEC FIXED(9,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_9_2 = PIC_FIELD;
             ELSE DECFIXED_9_2 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(3) DO;
             DCL DECFIXED_9_3    DEC FIXED(9,3)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_9_3 = PIC_FIELD;
             ELSE DECFIXED_9_3 = SFARRAY.DEC_FIELD(1);
             END;
       END;
       END;
    WHEN(10) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_10_0    DEC FIXED(10,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_10_0 = PIC_FIELD;
             ELSE DECFIXED_10_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_10_1    DEC FIXED(10,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_10_1 = PIC_FIELD;
             ELSE DECFIXED_10_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_10_2    DEC FIXED(10,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_10_2 = PIC_FIELD;
             ELSE DECFIXED_10_2 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(3) DO;
             DCL DECFIXED_10_3    DEC FIXED(10,3)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_10_3 = PIC_FIELD;
             ELSE DECFIXED_10_3 = SFARRAY.DEC_FIELD(1);
             END;
       END;
       END;
    WHEN(11) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_11_0    DEC FIXED(11,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_11_0 = PIC_FIELD;
             ELSE DECFIXED_11_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_11_1    DEC FIXED(11,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_11_1 = PIC_FIELD;
             ELSE DECFIXED_11_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_11_2    DEC FIXED(11,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_11_2 = PIC_FIELD;
             ELSE DECFIXED_11_2 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(3) DO;
             DCL DECFIXED_11_3    DEC FIXED(11,3)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_11_3 = PIC_FIELD;
             ELSE DECFIXED_11_3 = SFARRAY.DEC_FIELD(1);
             END;
       END;
       END;
    WHEN(12) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_12_0    DEC FIXED(12,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_12_0 = PIC_FIELD;
             ELSE DECFIXED_12_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_12_1    DEC FIXED(12,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_12_1 = PIC_FIELD;
             ELSE DECFIXED_12_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_12_2    DEC FIXED(12,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_12_2 = PIC_FIELD;
             ELSE DECFIXED_12_2 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(3) DO;
             DCL DECFIXED_12_3    DEC FIXED(12,3)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_12_3 = PIC_FIELD;
             ELSE DECFIXED_12_3 = SFARRAY.DEC_FIELD(1);
             END;
       END;
       END;
    WHEN(13) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_13_0    DEC FIXED(13,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_13_0 = PIC_FIELD;
             ELSE DECFIXED_13_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_13_1    DEC FIXED(13,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_13_1 = PIC_FIELD;
             ELSE DECFIXED_13_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_13_2    DEC FIXED(13,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_13_2 = PIC_FIELD;
             ELSE DECFIXED_13_2 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(3) DO;
             DCL DECFIXED_13_3    DEC FIXED(13,3)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_13_3 = PIC_FIELD;
             ELSE DECFIXED_13_3 = SFARRAY.DEC_FIELD(1);
             END;
       END;
       END;
    WHEN(14) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_14_0    DEC FIXED(14,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_14_0 = PIC_FIELD;
             ELSE DECFIXED_14_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_14_1    DEC FIXED(14,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_14_1 = PIC_FIELD;
             ELSE DECFIXED_14_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_14_2    DEC FIXED(14,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_14_2 = PIC_FIELD;
             ELSE DECFIXED_14_2 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(3) DO;
             DCL DECFIXED_14_3    DEC FIXED(14,3)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_14_3 = PIC_FIELD;
             ELSE DECFIXED_14_3 = SFARRAY.DEC_FIELD(1);
             END;
       END;
       END;
    WHEN(15) DO;
       SELECT(VARTABLE.LENGTH.SCALE(VARIABLE));
          WHEN(0) DO;
             DCL DECFIXED_15_0    DEC FIXED(15,0)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_15_0 = PIC_FIELD;
             ELSE DECFIXED_15_0 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(1) DO;
             DCL DECFIXED_15_1    DEC FIXED(15,1)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_15_1 = PIC_FIELD;
             ELSE DECFIXED_15_1 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(2) DO;
             DCL DECFIXED_15_2    DEC FIXED(15,2)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_15_2 = PIC_FIELD;
             ELSE DECFIXED_15_2 = SFARRAY.DEC_FIELD(1);
             END;
          WHEN(3) DO;
             DCL DECFIXED_15_3    DEC FIXED(15,3)  BASED(DECFIXED_PTR);
             IF SFARRAY.CHARACTER(1)='1'B THEN
                DECFIXED_15_3 = PIC_FIELD;
             ELSE DECFIXED_15_3 = SFARRAY.DEC_FIELD(1);
             END;
       END;
       END;
    OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI718                                    */
             /* MESSAGE: INVALID LENGTH *V OF FIELD *V IN QCHSTSTR  */
             /* MESSAGECLASS: STRUCTURE ERROR MESSAGE               */
             /* EXPLANATION: THE INTERPRETER FOUND AN INVALID       */
             /*              LENGTH OF AN FIELD DECLARED AS         */
             /*              DECIMAL FIXED (ANY OTHER VALUE LESS    */
             /*              THAN 1 OR GREATER THAN 15 IS           */
             /*              CONSIDERED TO BE INVALID AS DEFINED    */
             /*              IN THE REFERENCE MANUAL)               */
             /* SEVERITY: 12                                        */
             /* PROCEDURE: ASSIGN_DECFIXED_VALUE                    */
             /* USER RESPONSE: NONE                                 */
             /* PROGRAMMER RESPONSE: CHANGE THE LENGTH OF THE       */
             /*              FIELD DECLARATION IN THE STRUCTURE     */
             /*              DEFINITION                             */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
             IF SP.RUN_MODE = 'M' THEN DO;
             INTMSG ('718',SUBSTR(VARTABLE.STRUCTURE_NAME(VARIABLE),1,3)
                           !! '.' !!
                           VARTABLE.VARIABLE_NAME(VARIABLE) !! ',' !!
                           SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(918);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
          END;
 END;
0END ASSIGN_RIGHT_TO_DECFIXED;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE SEARCHES FOR A DB_VARIABLE IN THE     */
 /*            VARTABLE ARRAY OF STRUCTURES                         */
 /*  PARAMETERS: TOKEN.... TOKEN CONTAINING THE CORRESPONDING       */
 /*            ELEMENT OF THE RULEARRAY                             */
 /*******************************************************************/
0FIND_DB_VARIABLE: PROCEDURE;
0/*******************************************************************/
 /*  RUN A LOOP OVER THE WHOLE ARRAY...                             */
 /*******************************************************************/
0DO VARIABLE = 1 TO MAXDBVARIABLES;
0   /****************************************************************/
    /*  LOOK WHERE THE POINT IS (SHOULD NORMALLY BE IN THE FOURTH   */
    /*  POSITION AS THE FORMAT OF A DATABASE VARIABLE IS            */
    /*  DDD.NNNNNNNN (DDD IS THE DATABASE, NNNNNNNN IS THE FIELD    */
    /*  NAME)...                                                    */
    /****************************************************************/
0   POINT_POSITION = INDEX(RULEARRAY.CONTENT(TOKEN),'.');
0   /****************************************************************/
    /*  LOOK WHERE THE VARIABLE'S NAME ENDS. NORMALLY THE FOLLOWING */
    /*  SHOULD GIVE A VALUE OF 12 OR LESS (AS DECRIBED BEFORE)...   */
    /****************************************************************/
0   LENGTH_OF_VARIABLE_NAME = INDEX(RULEARRAY.CONTENT(TOKEN),' ') - 1;
0   /****************************************************************/
    /*  THE 3-CHARACTER DATABASE NAME AS LOADED BY THE STRUCTURE    */
    /*  LOAD UTILITY IS TO BE FOUND ON POSITION 4 (EXAMPLE:         */
    /*  'QCHBLAS'). WE COMPARE IT WITH THE DATABASE NAME FOUND      */
    /*  IN THE RULES. IF THERE IS A MATCH, WE IMMEDIATELY RETURN    */
    /*  AND REMEMBER THE APPROPRIATE INDEX OF THE VARTABLE IN THE   */
    /*  FIELD 'VARIABLE'...                                         */
    /****************************************************************/
0   IF ((SUBSTR(VARTABLE.STRUCTURE_NAME(VARIABLE),4,3) =
        SUBSTR(RULEARRAY.CONTENT(TOKEN),1,POINT_POSITION-1)) &
        (VARTABLE.VARIABLE_NAME(VARIABLE) =
        SUBSTR(RULEARRAY.CONTENT(TOKEN),POINT_POSITION+1,
               LENGTH_OF_VARIABLE_NAME-POINT_POSITION)))
        THEN RETURN;
 END;
 IF VARIABLE > MAXDBVARIABLES THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI719                                    */
             /* MESSAGE: FIELD *V NOT FOUND IN QCHSTSTR             */
             /* MESSAGECLASS: RULES ERROR                           */
             /* EXPLANATION: THE RULES SPECIFIED A DATABASE FIELD   */
             /*              IN THE FORMAT STRUCTURE.VARIABLE       */
             /*              WHICH COULD NOT BE FOUND BY THE        */
             /*              INTERPRETER.                           */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: FIND_DB_VARIABLE                         */
             /* PROGRAMMER RESPONSE: ADD THE MISSING STRUCTURE      */
             /*              TO THE INTERPRETER SOURCE CODE AND     */
             /*              RECOMPILE THE INTERPRETER OR LOAD THE  */
             /*              MISSING FIELD TO THE TABLE QCHSTSTR.   */
             /* USER RESPONSE: CHECK THE CORRECT SPELLING OF THE    */
             /*              STRUCTURE NAME AS WELL AS THE FIELD    */
             /*              NAME AND CHANGE THE RULE IF NECESSARY. */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('719',
                SUBSTR(RULEARRAY.CONTENT(TOKEN),1,POINT_POSITION-1) !!
                '.' !!
                SUBSTR(RULEARRAY.CONTENT(TOKEN),POINT_POSITION+1,
                    LENGTH_OF_VARIABLE_NAME-POINT_POSITION) !! ',' !!
                SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(919);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
         END;
0END FIND_DB_VARIABLE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE PREPARES THE ASSIGNMENT STATEMENT BY  */
 /*     - ANALYSING THE RULEARRAY FOR THE TYPE OF TOKEN APPEARING   */
 /*       IN THE RULE                                               */
 /*     - CALLING THE APPROPRIATE SUBROUTINES                       */
 /*     - FILLING ANOTHER SPECIAL ARRAY: 'SFARRAY' HOLDS            */
 /*       THE TOKENS OF THE RULE ARRAY ENRICHED WITH ITS ACTUAL     */
 /*       CONTENTS (THE FIELD NAMES ARE TRANSLATED INTO ACTUAL      */
 /*       VALUES HERE)                                              */
 /*  IMPORTANT 'PARAMETERS': TOKENS_IN_STATEMENT.... NUMBER OF      */
 /*             TOKENS IN STATEMENT (INCLUDING SEMICOLON)           */
 /*       I.... FIRST TOKEN IN THE WHOLE ASSIGNMENT                 */
 /*             STATEMENT                                           */
 /*******************************************************************/
0CALCULATE_ASSIGNMENT: PROCEDURE;
0/*******************************************************************/
 /*  CLEAR THE SFARRAY ELEMENTS BEFORE THEY ARE FILLED...           */
 /*******************************************************************/
0DO SF_TOKEN=1 TO TOKENS_IN_STATEMENT;
    SFARRAY(SF_TOKEN)='';
 END;
0/*******************************************************************/
 /*  INITIALIZE THE INDEX...                                        */
 /*******************************************************************/
0SF_TOKEN = 0;
0/*******************************************************************/
 /*  RUN THE LOOP FROM THE FIRST TOKEN ON THE LEFT SIDE OF THE      */
 /*  ASSIGNMENT STATEMENT (GENERAL FORMAT: 'XXXX = YYYY;' OR        */
 /*  'XXXX = YYYY * ZZZZ;', SO I+2 MEANS 'YYYY' IN BOTH CASES)      */
 /*  UP TO THE SEMICOLON ENDING THE STATEMENT...                    */
 /*******************************************************************/
0DO EXPRESSION_TOKEN=I+2 TO I+TOKENS_IN_STATEMENT-2;
    SELECT;
       WHEN(RULEARRAY.DB_VARIABLE(EXPRESSION_TOKEN)='1'B)
           DO;
           PUT SKIP LIST('WE HAVE A DATABASE FIELD HERE');
0          /**********************************************************/
           /*   WE HAVE A DATABASE FIELD HERE...                     */
           /**********************************************************/
0          TOKEN=EXPRESSION_TOKEN;
0          /**********************************************************/
           /*   HERE WE LOOK FOR THE FIELD'S OFFSET                  */
           /**********************************************************/
0          CALL FIND_DB_VARIABLE;
           SF_TOKEN = SF_TOKEN + 1;
           SFARRAY.DB_VARIABLE(SF_TOKEN)='1'B;
0          /**********************************************************/
           /*   HERE WE LOOK FOR THE APPROPRIATE DATABASE AND ITS    */
           /*   POINTER...                                           */
           /**********************************************************/
0          CALL FIND_STRUCTURE;
0          /**********************************************************/
           /*   NOW WE EXAMINE THE FIELD'S TYPE AS DEFINED IN THE    */
           /*   VARTABLE...                                          */
           /*   DEPENDING ON THE TYPE WE CALL THE RESPECTIVE         */
           /*   ASSIGNMENT SUBROUTINES AND SET SOME FIELDS OF THE    */
           /*   SFARRAY...                                           */
           /**********************************************************/
           PUT SKIP LIST('ITS TYPE IS',VARTABLE.TYPE(VARIABLE));
0          SELECT (VARTABLE.TYPE(VARIABLE));
              WHEN('C','V') DO;
                 SFARRAY.CHARACTER(SF_TOKEN)='1'B;
                 SFARRAY.DIGITS(SF_TOKEN)=
                         VARTABLE.LENGTH.PRECISION(VARIABLE);
0                /***************************************************/
                 /*   WE CALL THE ROUTINE WHICH GETS THE REAL       */
                 /*   VALUE INTO THE SFARRAY                        */
                 /***************************************************/
0                CALL ASSIGN_CHAR_VALUE;
                 END;
              WHEN('D') DO;
                 SFARRAY.DEC_FIXED(SF_TOKEN)='1'B;
                 SFARRAY.DIGITS(SF_TOKEN) =
                         VARTABLE.LENGTH.PRECISION(VARIABLE);
                 SFARRAY.SCALE(SF_TOKEN) =
                         VARTABLE.LENGTH.SCALE(VARIABLE);
0                /***************************************************/
                 /*   WE CALL THE ROUTINE WHICH GETS THE REAL       */
                 /*   VALUE INTO THE SFARRAY                        */
                 /***************************************************/
0                CALL ASSIGN_DECFIXED_VALUE;
                 END;
              OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI720                                    */
             /* MESSAGE: INVALID FIELD TYPE *V IN FIELD *V          */
             /* MESSAGECLASS: INTERPRETER INTERNAL ERROR            */
             /* EXPLANATION: THE INTERPRETER FOUND AN INVALID       */
             /*              VALUE IN THE FIELD VARTABLE.TYPE       */
             /* SEVERITY: 12                                        */
             /* PROCEDURE: CALCULATE_ASSIGNMENT                     */
             /* PROGRAMMER RESPONSE: TRACE THE RUNNING PROGRAM      */
             /*              TO CHECK THE CONTENT OF VARTABLE.TYPE  */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
                IF SP.RUN_MODE = 'M' THEN DO;
                   INTMSG ('720',
                   VARTABLE.TYPE(VARIABLE) !! ',' !!
                   SUBSTR(VARTABLE.STRUCTURE_NAME(VARIABLE),1,3) !! '.'
                   !! VARTABLE.VARIABLE_NAME(VARIABLE)
                   !! ',' !! SUBSTR(SP.RULE_NAME,5,4));
                END;
                ELSE DO;
                   QCHNOT(920);
                   SP.EOP_FROM_RULE = '1'B;
                   SP.ROLB_REQU     = '1'B;
                   GOTO ABEND;
                END;
             END;
           END;  /* END SELECT */
           END;  /* END DO     */
       WHEN(RULEARRAY.USER_VARIABLE(EXPRESSION_TOKEN)='1'B)
           DO;
0          /**********************************************************/
           /*   WE HAVE A USERVARIABLE HERE...                       */
           /**********************************************************/
0          SF_TOKEN = SF_TOKEN + 1;
0          /**********************************************************/
           /*   LET'S LOOK WHETHER THE USERVARIABLE DOES ALREADY     */
           /*   EXIST (INTERPRETER SYNTAX REQUIREMENT: A             */
           /*   USERVARIABLE MUST APPEAR ON THE LEFT  SIDE OF AN     */
           /*   ASSIGNMENT STATEMENT BEFORE IT IS USED ON THE        */
           /*   RIGHT SIDE), OTHERWISE THIS IS A SYNTAX ERROR...     */
           /**********************************************************/
0          DO USV_COUNT = 1 TO USV_MAX;
              IF USER_VARS.NAME(USV_COUNT) =
                 RULEARRAY.CONTENT(EXPRESSION_TOKEN) THEN LEAVE;
           END;
           IF USV_COUNT <= USV_MAX THEN DO;
0             /*******************************************************/
              /*   YES, WE HAD THIS ONE ALREADY...                   */
              /*******************************************************/
0             SFARRAY.VAR_TYPE.USER_VARIABLE(SF_TOKEN) = '1'B;
              IF USER_VARS.TYPE.CHARACTER(USV_COUNT) = '1'B THEN DO;
                 SFARRAY.CHAR_FIELD(SF_TOKEN) =
                 USER_VARS.CONTENT.CHARACTER(USV_COUNT);
                 SFARRAY.VAR_TYPE.CHARACTER(SF_TOKEN) = '1'B;
                 END;
              ELSE DO;
                 SFARRAY.DEC_FIELD(SF_TOKEN) =
                 USER_VARS.CONTENT.DEC_FIXED(USV_COUNT);
                 SFARRAY.VAR_TYPE.DEC_FIXED(SF_TOKEN) = '1'B;
                 END;
              SFARRAY.DIGITS(SF_TOKEN) =
                      USER_VARS.LENGTH.PRECISION(USV_COUNT);
              SFARRAY.SCALE(SF_TOKEN) =
                      USER_VARS.LENGTH.SCALE(USV_COUNT);
              END;
           ELSE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI721                                    */
             /* MESSAGE: USER VARIABLE XX NOT DEFINED IN LINE XXXX  */
             /* MESSAGECLASS: INTERPRETER INTERPRETATION ERROR      */
             /* EXPLANATION: THE INTERPRETER FOUND A USER VARIABLE  */
             /*              IN EXPRESSION WHICH HAS NOT BEEN       */
             /*              DEFINED/INITIALIZED PREVIOUSLY.        */
             /*              THIS MAY BE CAUSED BY A TYPO OR SIMPLY */
             /*              BY FORGETTING TO DEFINE/INITIALIZE     */
             /*              THE VARIABLE IN THE BEGIN-RULES.       */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: CALCULATE_ASSIGNMENT                     */
             /* USER RESPONSE: ADD THE MISSING DEFINITION/          */
             /*              INITIALISATION STATEMENT OR CORRECT    */
             /*              THE MISSPELLING OF THE USER VARIABLE.  */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /* EXAMPLE: COMPLEXNAMES = 3.14                        */
             /*                 .                                   */
             /*                 .                                   */
             /*                 .                                   */
             /*          DBSTRUC.FIELD = COMPLEKSNAME * 2;          */
             /*                                                     */
             /*******************************************************/
              LINECHAR=RULEARRAY.LINENUMBER(EXPRESSION_TOKEN);
              IF SP.RUN_MODE = 'M' THEN DO;
                 INTMSG ('721',
                 SUBSTR(RULEARRAY.CONTENT(EXPRESSION_TOKEN),1,7) !! ','
                 !! SUBSTR(LINECHAR,7,3) !! ',' !!
                 SUBSTR(SP.RULE_NAME,5,4));
              END;
              ELSE DO;
                 QCHNOT(921);
                 SP.EOP_FROM_RULE = '1'B;
                 SP.ROLB_REQU     = '1'B;
                 GOTO ABEND;
              END;
           END;
           END;
       WHEN(RULEARRAY.CONSTANT(EXPRESSION_TOKEN)='1'B)
           DO;
           /*******************************************************/
           /*  THE TOKEN IN THE RULE WAS A NUMERIC CONSTANT       */
           /*******************************************************/
           SF_TOKEN = SF_TOKEN + 1;
           SFARRAY.CONSTANT(SF_TOKEN)='1'B;
           SFARRAY.DEC_FIXED(SF_TOKEN)='1'B;
           /*******************************************************/
           /*  ONLY THE POSITIONS UP TO THE FIRST BLANK ARE       */
           /*  INTERESTING FOR US...                              */
           /*******************************************************/
           BLANK_POSITION = INDEX(RULEARRAY.CONTENT(EXPRESSION_TOKEN),
              ' ');
           SFARRAY.CALCULATION_FIELD.DEC_FIELD(SF_TOKEN) =
              SUBSTR(RULEARRAY.CONTENT(EXPRESSION_TOKEN),1,
              BLANK_POSITION-1);
           /*******************************************************/
           /*  HERE WE USE THE STANDARD PRECISION AND SCALE       */
           /*******************************************************/
           SFARRAY.DIGITS(SF_TOKEN) = 15;
           SFARRAY.SCALE(SF_TOKEN) = 3;
           END;
       WHEN(RULEARRAY.LEFT_PARENTHESIS(EXPRESSION_TOKEN)='1'B)
           DO;
           SF_TOKEN = SF_TOKEN + 1;
           SFARRAY.PARENTHESIS(SF_TOKEN)='1'B;
           END;
       WHEN(RULEARRAY.RIGHT_PARENTHESIS(EXPRESSION_TOKEN)='1'B)
           DO;
           SF_TOKEN = SF_TOKEN + 1;
           SFARRAY.PARENTHESIS(SF_TOKEN)='1'B;
           END;
       WHEN(RULEARRAY.LOGIC_OPERATOR(EXPRESSION_TOKEN)='1'B)
           DO;
           /*******************************************************/
           /*  WE SET THE SFARRAY.LOGIC_OPERATOR ACCORDING TO     */
           /*  THE TYPE OF LOGIC OPERATOR FOUND IN THE RULES      */
           /*******************************************************/
           SF_TOKEN = SF_TOKEN + 1;
           SELECT(SUBSTR(RULEARRAY.CONTENT(EXPRESSION_TOKEN),1,3));
                 WHEN('AND') SFARRAY.LOGIC_OPERATOR(SF_TOKEN)='10';
                 WHEN('OR ') SFARRAY.LOGIC_OPERATOR(SF_TOKEN)='01';
                 OTHERWISE;
           END;
           END;
       WHEN(RULEARRAY.MATH_OPERATOR(EXPRESSION_TOKEN)='1'B)
           DO;
           /*******************************************************/
           /*  WE FOUND A MATHEMATIC OPERATOR AN SET THE BIT      */
           /*  SWITCHES IN SFARRAY.OPERATOR ACCORDINGLY           */
           /*******************************************************/
           SF_TOKEN = SF_TOKEN + 1;
           SELECT(SUBSTR(RULEARRAY.CONTENT(EXPRESSION_TOKEN),1,1));
                 WHEN('*') SFARRAY.OPERATOR(SF_TOKEN)='1000';
                 WHEN('/') SFARRAY.OPERATOR(SF_TOKEN)='0100';
                 WHEN('-') SFARRAY.OPERATOR(SF_TOKEN)='0010';
                 WHEN('+') SFARRAY.OPERATOR(SF_TOKEN)='0001';
           END;
           END;
       WHEN(RULEARRAY.TEXT(EXPRESSION_TOKEN)='1'B)
           DO;
           /*******************************************************/
           /*  WE FOUND A CHARACTER CONSTANT...                   */
           /*******************************************************/
           SF_TOKEN = SF_TOKEN + 1;
           SFARRAY.CONSTANT(SF_TOKEN) = '1'B;
           SFARRAY.CHARACTER(SF_TOKEN) = '1'B;
           SFARRAY.CALCULATION_FIELD.CHAR_FIELD(SF_TOKEN) =
               RULEARRAY.CONTENT(EXPRESSION_TOKEN);
           /*******************************************************/
           /*  WE ALREADY KNOW ABOUT THE CHARACTER CONSTANT'S     */
           /*  LENGTH FROM PREVIOUS INTERPRETATION STEPS...       */
           /*******************************************************/
           SFARRAY.PRECISION.DIGITS(SF_TOKEN) =
                   RULEARRAY.TEXTLENGTH(EXPRESSION_TOKEN);
           SFARRAY.PRECISION.SCALE(SF_TOKEN) = 0;
           END;
       OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI722                                    */
             /* MESSAGE: SEMICOLON MISSING IN LINE *V, RULE *V      */
             /* MESSAGECLASS: INTERPRETER INTERNAL ERROR            */
             /* EXPLANATION: THE INTERPRETER FOUND AN INVALID       */
             /*              TYPE OF TOKEN IN THE RULEARRAY -       */
             /*              STRUCTURE                              */
             /*              THIS MAY BE CAUSED BY A MISSING        */
             /*              SEMICOLON...                           */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: CALCULATE_ASSIGNMENT                     */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
               LINECHAR =  RULEARRAY.LINENUMBER(EXPRESSION_TOKEN);
               IF SP.RUN_MODE = 'M' THEN DO;
                  INTMSG ('722',SUBSTR(LINECHAR,7,3) !! ',' !!
                           SUBSTR(SP.RULE_NAME,5,4) !! ',' !!
                           RULEARRAY.CONTENT(EXPRESSION_TOKEN));
               END;
               ELSE DO;
                  QCHNOT(922);
                  SP.EOP_FROM_RULE = '1'B;
                  SP.ROLB_REQU     = '1'B;
                  GOTO ABEND;
               END;
           END;
    END;
 END;
0/*******************************************************************/
 /* NOW WE CALL THE ACTUAL CALCULATION OF THE EXPRESSION ON THE     */
 /* RIGHT SIDE OF THE ASSIGNMENT STATEMENT...                       */
 /*******************************************************************/
0CALL CALCULATE_RIGHT;
0END CALCULATE_ASSIGNMENT;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE SEARCHES A LIST OF STRUCTURES         */
 /*            (DATABASES) FOR THE STRUCTURE SPEFICIED IN THE       */
 /*            RULES. IT ASSIGNS THE APPROPRIATE SPA-POINTER        */
 /*            TO THE STRUCTURE_POINTER USED FOR LATER ACCESS       */
 /*            TO THE STRUCTURES FIELDS...                          */
 /*  PARAMETERS: VARIABLE.... INDEX TO THE STRUCTURE TABLE          */
 /*******************************************************************/
0FIND_STRUCTURE: PROCEDURE;
0/*******************************************************************/
 /*  THE ACTUAL DATABASE NAME IS HELD IN POSITION 4 AS DEFINED      */
 /*  BY THE STRUCTURE LOAD UTILITY...                               */
 /*******************************************************************/
0SELECT(SUBSTR(VARTABLE.STRUCTURE_NAME(VARIABLE),4,3));
       WHEN ('BAT') STRUCTURE_POINTER = SP.BATP1;
       WHEN ('CFL') STRUCTURE_POINTER = SP.CFLP1;
       WHEN ('CTL') STRUCTURE_POINTER = SP.CTLP1;
       WHEN ('CTY') STRUCTURE_POINTER = SP.CTYP1;
       WHEN ('GIL') STRUCTURE_POINTER = SP.GILP1;
       WHEN ('PRT') STRUCTURE_POINTER = SP.PRTP1;
       WHEN ('RUL') STRUCTURE_POINTER = SP.RULP1;
       WHEN ('STA') STRUCTURE_POINTER = SP.STAP1;
       WHEN ('STR') STRUCTURE_POINTER = SP.STRP1;
       WHEN ('TAP') STRUCTURE_POINTER = SP.TAPP1;
       WHEN ('TBL') STRUCTURE_POINTER = SP.TBLP1;
       WHEN ('UIB') STRUCTURE_POINTER = SP.UIBP1;
       WHEN ('UID') STRUCTURE_POINTER = SP.UIDP1;
       WHEN ('UIS') STRUCTURE_POINTER = SP.UISP1;

       WHEN ('AID') STRUCTURE_POINTER = SP.AIDP1;
       WHEN ('AIP') STRUCTURE_POINTER = SP.AIPP1;
     /*WHEN ('AIT') STRUCTURE_POINTER = SP.AITP1;               OBS810*/
       WHEN ('ATT') STRUCTURE_POINTER = SP.ATTP1;
       WHEN ('BIB') STRUCTURE_POINTER = SP.BIBP1;
       WHEN ('BIH') STRUCTURE_POINTER = SP.BIHP1;
       WHEN ('BIL') STRUCTURE_POINTER = SP2.BILP1;
       WHEN ('BIM') STRUCTURE_POINTER = SP.BIMP1;
       WHEN ('BIS') STRUCTURE_POINTER = SP.BISP1;
       WHEN ('BLA') STRUCTURE_POINTER = SP.BLAP1;
       WHEN ('BLM') STRUCTURE_POINTER = SP.BLMP1;
       WHEN ('BME') STRUCTURE_POINTER = SP.BMEP1;
       WHEN ('BMF') STRUCTURE_POINTER = SP.BMFP1;
       WHEN ('CAR') STRUCTURE_POINTER = SP.CARP1;
       WHEN ('CCD') STRUCTURE_POINTER = SP.CCDP1;
       WHEN ('CCF') STRUCTURE_POINTER = SP.CCFP1;
       WHEN ('CCR') STRUCTURE_POINTER = SP.CCRP1;
       WHEN ('CCT') STRUCTURE_POINTER = SP.CCTP1;
       WHEN ('CDA') STRUCTURE_POINTER = SP.CDAP1;
       WHEN ('CEH') STRUCTURE_POINTER = SP.CEHP1;
       WHEN ('CEV') STRUCTURE_POINTER = SP.CEVP1;
       WHEN ('CLC') STRUCTURE_POINTER = SP.CLCP1;
       WHEN ('CMA') STRUCTURE_POINTER = SP.CMAP1;
       WHEN ('CMF') STRUCTURE_POINTER = SP.CMFP1;
       WHEN ('CML') STRUCTURE_POINTER = SP.CMLP1;
       WHEN ('COD') STRUCTURE_POINTER = SP.CODP1;
       WHEN ('COF') STRUCTURE_POINTER = SP.COFP1;
       WHEN ('CON') STRUCTURE_POINTER = SP.CONP1;
       WHEN ('CUB') STRUCTURE_POINTER = SP.CUBP1;
       WHEN ('CUC') STRUCTURE_POINTER = SP.CUCP1;
     /*WHEN ('FCH') STRUCTURE_POINTER = SP.FCHP1;               OBS810*/
       WHEN ('IFS') STRUCTURE_POINTER = SP.IFSP1;
       WHEN ('LIO') STRUCTURE_POINTER = SP.LIOP1;
       WHEN ('MIC') STRUCTURE_POINTER = SP.MICP1;
       WHEN ('MIM') STRUCTURE_POINTER = SP.MIMP1;
       WHEN ('MIX') STRUCTURE_POINTER = SP.MIXP1;
       WHEN ('MOC') STRUCTURE_POINTER = SP.MOCP1;
       WHEN ('MOX') STRUCTURE_POINTER = SP.MOXP1;
       WHEN ('NOC') STRUCTURE_POINTER = SP.NOCP1;
       WHEN ('NOT') STRUCTURE_POINTER = SP.NOTP1;
       WHEN ('RCL') STRUCTURE_POINTER = SP.RCLP1;
       WHEN ('RSC') STRUCTURE_POINTER = SP.RSCP1;
       WHEN ('SED') STRUCTURE_POINTER = SP.SEDP1;
       WHEN ('SEL') STRUCTURE_POINTER = SP.SELP1;
       WHEN ('TCC') STRUCTURE_POINTER = SP.TCCP1;
       WHEN ('TCF') STRUCTURE_POINTER = SP.TCFP1;
     /*WHEN ('TCH') STRUCTURE_POINTER = SP.TCHP1;               OBS810*/
       WHEN ('TCM') STRUCTURE_POINTER = SP.TCMP1;
       WHEN ('TCO') STRUCTURE_POINTER = SP.TCOP1;
     /*WHEN ('TCS') STRUCTURE_POINTER = SP.TCSP1;               OBS810*/
       WHEN ('TFO') STRUCTURE_POINTER = SP.TFOP1;
       WHEN ('TIR') STRUCTURE_POINTER = SP.TIRP1;
       WHEN ('TPT') STRUCTURE_POINTER = SP.TPTP1;
       WHEN ('TRG') STRUCTURE_POINTER = SP.TRGP1;
       WHEN ('WDC') STRUCTURE_POINTER = SP.WDCP1;
       WHEN ('WDF') STRUCTURE_POINTER = SP.WDFP1;
       WHEN ('WDI') STRUCTURE_POINTER = SP.WDIP1;
       WHEN ('WDO') STRUCTURE_POINTER = SP.WDOP1;
       WHEN ('WDR') STRUCTURE_POINTER = SP.WDRP1;
       WHEN ('XIC') STRUCTURE_POINTER = SP.XICP1;
       WHEN ('XIX') STRUCTURE_POINTER = SP.XIXP1;
       WHEN ('XOC') STRUCTURE_POINTER = SP.XOCP1;
       WHEN ('XOX') STRUCTURE_POINTER = SP.XOXP1;
       WHEN ('XXX') STRUCTURE_POINTER = SP.XXXP1;
       WHEN ('XXC') STRUCTURE_POINTER = SP.XXCP1;
       /* R060 TABLES */
       WHEN ('BFS') STRUCTURE_POINTER = SP.BFSP1;
       WHEN ('CCE') STRUCTURE_POINTER = SP.CCEP1;
       WHEN ('CRA') STRUCTURE_POINTER = SP.CRAP1;
       WHEN ('CRP') STRUCTURE_POINTER = SP.CRPP1;
       WHEN ('CRU') STRUCTURE_POINTER = SP.CRUP1;
       WHEN ('CSC') STRUCTURE_POINTER = SP.CSCP1;
       WHEN ('ELI') STRUCTURE_POINTER = SP.ELIP1;
       WHEN ('FIO') STRUCTURE_POINTER = SP.FIOP1;
       WHEN ('FLA') STRUCTURE_POINTER = SP.FLAP1;
       WHEN ('FMC') STRUCTURE_POINTER = SP.FMCP1;
       WHEN ('FMO') STRUCTURE_POINTER = SP.FMOP1;
       WHEN ('FRS') STRUCTURE_POINTER = SP.FRSP1;
       WHEN ('FSC') STRUCTURE_POINTER = SP.FSCP1;
       WHEN ('FTI') STRUCTURE_POINTER = SP.FTIP1;
       WHEN ('FTS') STRUCTURE_POINTER = SP.FTSP1;
       WHEN ('OBC') STRUCTURE_POINTER = SP.OBCP1;
       WHEN ('OBJ') STRUCTURE_POINTER = SP.OBJP1;
       WHEN ('OFF') STRUCTURE_POINTER = SP.OFFP1;
       WHEN ('OVC') STRUCTURE_POINTER = SP.OVCP1;
       WHEN ('OVI') STRUCTURE_POINTER = SP.OVIP1;
       WHEN ('OVS') STRUCTURE_POINTER = SP.OVSP1;
       WHEN ('RLA') STRUCTURE_POINTER = SP.RLAP1;
       WHEN ('TOB') STRUCTURE_POINTER = SP.TOBP1;
       WHEN ('TXT') STRUCTURE_POINTER = SP.TXTP1;
       WHEN ('USC') STRUCTURE_POINTER = SP.USCP1;
       WHEN ('UTI') STRUCTURE_POINTER = SP.UTIP1;
       WHEN ('UTS') STRUCTURE_POINTER = SP.UTSP1;

       WHEN ('OJS') STRUCTURE_POINTER = OJSP1;
       WHEN ('OJC') STRUCTURE_POINTER = OJCP1;
       WHEN ('OJI') STRUCTURE_POINTER = OJIP1;
       WHEN ('OTS') STRUCTURE_POINTER = OTSP1;
       WHEN ('OTC') STRUCTURE_POINTER = OTCP1;
       WHEN ('OTI') STRUCTURE_POINTER = OTIP1;

       WHEN ('PP1') STRUCTURE_POINTER = PP1P1;
       WHEN ('PP2') STRUCTURE_POINTER = PP2P1;
       WHEN ('PP3') STRUCTURE_POINTER = PP3P1;

       WHEN ('SYV') STRUCTURE_POINTER = SP.SYVP1;
       WHEN ('CHG') STRUCTURE_POINTER = SP.CHGP1;
       WHEN ('CU1') STRUCTURE_POINTER = SP.CU1P1;
       WHEN ('CU2') STRUCTURE_POINTER = SP.CU2P1;
       WHEN ('CU3') STRUCTURE_POINTER = SP.CU3P1;
       WHEN ('CU4') STRUCTURE_POINTER = SP.CU4P1;
       WHEN ('CU5') STRUCTURE_POINTER = SP.CU5P1;
       WHEN ('SPA') STRUCTURE_POINTER = $$USPAPTR;

       WHEN ('XAA') STRUCTURE_POINTER = ADDR(SP.SCREEN_LINE);
       WHEN ('XBA') STRUCTURE_POINTER = ADDR(SP.SCREEN_LINE);
       WHEN ('XCA') STRUCTURE_POINTER = ADDR(SP.SCREEN_LINE);
       WHEN ('XDA') STRUCTURE_POINTER = ADDR(SP.SCREEN_LINE);
       WHEN ('XEA') STRUCTURE_POINTER = ADDR(SP.SCREEN_LINE);
0      /***********************************************************/
       /*  ACCESS TO THE TABLES LISTED ABOVE MAY BE RESTRICTED    */
       /*  BY SIMPLY OUTCOMMENTING THE APPROPRIATE LINE...        */
       /***********************************************************/
0      OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI723                                    */
             /* MESSAGE: DATABASE XXXXXXX DOES NOT EXIST IN LINE X  */
             /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
             /* EXPLANATION: THE INTERPRETER COULD NOT FIND THE     */
             /*              STRUCTURE SPECIFIED (DESCRIBING        */
             /*              THE DATABASE-VARIABLE).                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: FIND_STRUCTURE                           */
             /* USER RESPONSE: CHECK THE CORRECT SPELLING OF THE    */
             /*              STRUCTURE PART OF THE DB-VARIABLE      */
             /*              SPECIFIED IN THE RULES                 */
             /* PROGRAMMER RESPONSE: ADD THE STRUCTURE SPECIFIED    */
             /*              TO THE LIST OF STRUCTURES IN THE       */
             /*              PROCEDURE FIND_STRUCTURE IF NECESSARY  */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(I);
                IF SP.RUN_MODE = 'M' THEN DO;
                   INTMSG ('723',
                   SUBSTR(VARTABLE.STRUCTURE_NAME(VARIABLE),4,3) !! ','
                   !! SUBSTR(LINECHAR,7,3) !! ',' !!
                   SUBSTR(SP.RULE_NAME,5,4));
                END;
                ELSE DO;
                   QCHNOT(923);
                   SP.EOP_FROM_RULE = '1'B;
                   SP.ROLB_REQU        = '1'B;
                   GOTO ABEND;
                END;
          END;
 END;
0END FIND_STRUCTURE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE GETS A CHARACTER FIELD FROM A         */
 /*            DATABASE STRUCTURE AND PUTS IT INTO THE SFARRAY      */
 /*  PARAMETERS: SF_TOKEN.... INDEX TO THE SFARRAY                  */
 /*              VARIABLE.... INDEX TO THE STRUCTURE TABLE          */
 /*******************************************************************/
0ASSIGN_CHAR_VALUE: PROCEDURE;
0/*******************************************************************/
 /*  GET THE OFFSET OF THE CHARACTER VARIABLE (TO THE BEGINNING     */
 /*  OF THE STRUCTURE, THAT IS)                                     */
 /*  ...AND SET THE POINTER WHICH LOCATES THE OFFSET_TABLE          */
 /*  TO THE BEGINNING OF THE STRUCTURE                              */
 /*  ...THIS CAUSES THE STRUCTURE TO BE LOGICALLY OVERLAID BY       */
 /*  THE OFFSET_TABLE                                               */
 /*  ... AND SO WE CAN ADDRESS A SPECIFIC LOCATION OF THE           */
 /*  ARRAY (EACH ELEMENT HAS A LENGTH OF 1 BYTE - SO WE SIMPLY      */
 /*  ADD THE OFFSET FOUND BEFORE TO THE BEGINNING OF THE ARRAY      */
 /*  AND SET A POINTER TO A CHARACTER FIELD TO THAT ADDRESS)        */
 /*  ... THIS AGAIN CAUSES THE STRUCTURE FIELD TO BE LOGICALLY      */
 /*  OVERLAID WITH OUR GENERIC CHARACTER FIELD                      */
 /*  ... AND WE ACCESS THIS CHARACTER FIELD TO GET THE REAL VALUE   */
 /*  IN THE DATABASE STRUCTURE                                      */
 /*******************************************************************/
0IF (VARTABLE.TYPE(VARIABLE)='V') THEN
    OFFSET_INDEX=VARTABLE.OFFSET(VARIABLE)-1;
 ELSE OFFSET_INDEX=VARTABLE.OFFSET(VARIABLE)+1;
 OFFSET_TABLE_POINTER = STRUCTURE_POINTER;
 DCL VARCHAR_FIELD   CHAR(255) VAR BASED(CHARACTER_PTR);
 DCL VARCHAR_LENGTH  BIN FIXED(15) BASED(CHARACTER_PTR);
 DCL CHARACTER_FIELD CHAR(255)     BASED(CHARACTER_PTR);
 CHARACTER_PTR=ADDR(OFFSET_TABLE(OFFSET_INDEX));
 IF (VARTABLE.TYPE(VARIABLE)='V') THEN DO;
    SFARRAY.CHAR_FIELD(SF_TOKEN) = VARCHAR_FIELD;
    SFARRAY.DIGITS(SF_TOKEN)=VARCHAR_LENGTH;
    END;
 ELSE
    SFARRAY.CHAR_FIELD(SF_TOKEN) =
    SUBSTR(CHARACTER_FIELD,1,VARTABLE.LENGTH.PRECISION(VARIABLE));
0END ASSIGN_CHAR_VALUE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE GETS A DECIMAL   FIELD FROM A         */
 /*            DATABASE STRUCTURE AND PUTS IT INTO THE SFARRAY      */
 /*  PARAMETERS: SF_TOKEN.... INDEX TO THE SFARRAY                  */
 /*              VARIABLE.... INDEX TO THE STRUCTURE TABLE          */
 /*******************************************************************/
0ASSIGN_DECFIXED_VALUE: PROCEDURE;
0/*******************************************************************/
 /*  GET THE OFFSET OF THE DECIMAL   VARIABLE (TO THE BEGINNING     */
 /*  OF THE STRUCTURE, THAT IS)                                     */
 /*  ...AND SET THE POINTER WHICH LOCATES THE OFFSET_TABLE          */
 /*  TO THE BEGINNING OF THE STRUCTURE                              */
 /*  ...THIS CAUSES THE STRUCTURE TO BE LOGICALLY OVERLAID BY       */
 /*  THE OFFSET_TABLE                                               */
 /*  ... AND SO WE CAN ADDRESS A SPECIFIC LOCATION OF THE           */
 /*  ARRAY (EACH ELEMENT HAS A LENGTH OF 1 BYTE - SO WE SIMPLY      */
 /*  ADD THE OFFSET FOUND BEFORE TO THE BEGINNING OF THE ARRAY      */
 /*  AND SET A POINTER TO A CHARACTER FIELD TO THAT ADDRESS)        */
 /*  ... THIS AGAIN CAUSES THE STRUCTURE FIELD TO BE LOGICALLY      */
 /*  OVERLAID WITH A DECIMAL FIELD DECLARED IN THE APPROPRIATE      */
 /*  LENGTH (PL/I DOES NOT SUPPORT VARIABLE LENGTH DECLARATION      */
 /*  IN DECIMAL FIXED FIELDS, SO WE HAVE TO RUN THROUGH A SELECT)   */
 /*  ... AND WE ACCESS THIS DECIMAL   FIELD TO GET THE REAL VALUE   */
 /*  IN THE DATABASE STRUCTURE                                      */
 /*******************************************************************/
0OFFSET_INDEX=VARTABLE.OFFSET(VARIABLE)+1;
 OFFSET_TABLE_POINTER = STRUCTURE_POINTER;
 DECFIXED_PTR = ADDR(OFFSET_TABLE(OFFSET_INDEX));
 SELECT(VARTABLE.LENGTH.PRECISION(VARIABLE));
    WHEN(1)  DO;
             DCL DECFIXED_FIELD_1  DEC FIXED(1)  BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_1;
             END;
    WHEN(2)  DO;
             DCL DECFIXED_FIELD_2  DEC FIXED(2)  BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_2;
             END;
    WHEN(3)  DO;
             DCL DECFIXED_FIELD_3  DEC FIXED(3)  BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_3;
             END;
    WHEN(4)  DO;
             DCL DECFIXED_FIELD_4  DEC FIXED(4)  BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_4;
             END;
    WHEN(5)  DO;
             DCL DECFIXED_FIELD_5  DEC FIXED(5)  BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_5;
             END;
    WHEN(6)  DO;
             DCL DECFIXED_FIELD_6  DEC FIXED(6)  BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_6;
             END;
    WHEN(7)  DO;
             DCL DECFIXED_FIELD_7  DEC FIXED(7)  BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_7;
             END;
    WHEN(8)  DO;
             DCL DECFIXED_FIELD_8  DEC FIXED(8)  BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_8;
             END;
    WHEN(9)  DO;
             DCL DECFIXED_FIELD_9  DEC FIXED(9)  BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_9;
             END;
    WHEN(10) DO;
             DCL DECFIXED_FIELD_10 DEC FIXED(10) BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_10;
             END;
    WHEN(11) DO;
             DCL DECFIXED_FIELD_11 DEC FIXED(11) BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_11;
             END;
    WHEN(12) DO;
             DCL DECFIXED_FIELD_12 DEC FIXED(12) BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_12;
             END;
    WHEN(13) DO;
             DCL DECFIXED_FIELD_13 DEC FIXED(13) BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_13;
             END;
    WHEN(14) DO;
             DCL DECFIXED_FIELD_14 DEC FIXED(14) BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_14;
             END;
    WHEN(15) DO;
             DCL DECFIXED_FIELD_15 DEC FIXED(15) BASED(DECFIXED_PTR);
             SFARRAY.DEC_FIELD(SF_TOKEN) = DECFIXED_FIELD_15;
             END;
    OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI725                                    */
             /* MESSAGE: INVALID LENGTH OF DECIMAL-FIXED-FIELD      */
             /*          DEFINED IN STRUCTURE TABLE                 */
             /* MESSAGECLASS: STRUCTURE ERROR MESSAGE               */
             /* EXPLANATION: THE INTERPRETER FOUND AN INVALID       */
             /*              LENGTH OF AN FIELD DECLARED AS         */
             /*              DECIMAL FIXED (ANY OTHER VALUE LESS    */
             /*              THAN 1 OR GREATER THAN 15 IS           */
             /*              CONSIDERED TO BE INVALID AS DEFINED    */
             /*              IN THE REFERENCE MANUAL)               */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: ASSIGN_DECFIXED_VALUE                    */
             /* USER RESPONSE: NONE                                 */
             /* PROGRAMMER RESPONSE: CHANGE THE LENGTH OF THE       */
             /*              FIELD DECLARATION IN THE STRUCTURE     */
             /*              DEFINITION                             */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('725',VARTABLE.VARIABLE_NAME(VARIABLE) !! ',' !!
                         SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(925);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
          END;
 END;
 PUT SKIP LIST('NOW LEAVING ASSIGN_DEC');
 PUT SKIP LIST('DEC_FIXED IS NOW',SFARRAY.DEC_FIELD(SF_TOKEN));
0END ASSIGN_DECFIXED_VALUE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE CALCULATES THE RIGHT SIDE OF AN       */
 /*            ASSIGNMENT STATEMENT                                 */
 /*******************************************************************/
0CALCULATE_RIGHT: PROCEDURE;
 TOKEN=1;
 EXPRESSION_TOKEN=TOKENS_IN_STATEMENT-3;
0DO UNTIL(EXPRESSION_TOKEN=1);
   IF SFARRAY.VAR_TYPE.PARENTHESIS(TOKEN)='00'B THEN DO;
       /*************************************************************/
       /* FIRST TOKEN WAS NOT A PARENTHESIS, SO IT MUST BE A        */
       /* VARIABLE (OPERATOR IS NOT ALLOWED AS THE FIRST TOKEN      */
       /* AFTER THE ASSIGNMENT CHARACTER '=')                       */
       /*************************************************************/
     IF (TOKENS_IN_STATEMENT = 4)  THEN DO;
        /**********************************************************/
        /* THIS IS OK IF THERE IS ONLY ONE TOKEN AFTER THE        */
        /* ASSIGNMENT OPERATOR (E.G. FOO = BAR;)                  */
        /**********************************************************/
        IF ((SFARRAY.DEC_FIXED(1)='1'B) &
            (SFARRAY.CONSTANT(1)^='1'B) &
            (SFARRAY.USER_VARIABLE(1)^='1'B))
           THEN DO;
           /*********************************************************/
           /* DO SOME MULTIPLICATION IF THE ONLY FIELD ON THE RIGHT */
           /* SIDE OF THE ASSIGNMENT IS A DECIMAL-FIXED-FIELD.      */
           /* THIS IS NECESSARY DUE TO THE WAY OF INTERNAL HANDLING */
           /* OF FIELD LENGTHS IN THE INTERPRETER...                */
           /*********************************************************/
           PUT SKIP DATA(SFARRAY(1));
           TARGET = SFARRAY.DEC_FIELD(1)/(10**SFARRAY.SCALE(1));
           PUT SKIP LIST('TARGET=',TARGET);
           SFARRAY(1)='';
           SFARRAY.DEC_FIXED(1)='1'B;
           SFARRAY.DIGITS(1)=15;
           SFARRAY.SCALE(1)=3;
           SFARRAY.DEC_FIELD(1)=TARGET;
           END;
        END;
     ELSE DO;
       IF (SFARRAY.VAR_TYPE.OPERATOR(TOKEN+1)='0000'B) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI726                                    */
             /* MESSAGE: VARIABLE FOLLOWED BY NON-OPERATOR IN LINE  */
             /*          XXXXXX                                     */
             /* MESSAGECLASS: CALCULATION ERROR MESSAGE             */
             /* EXPLANATION: THE INTERPRETER FOUND AN INVALID       */
             /*              TYPE OF TOKEN AS THE SECOND TOKEN      */
             /*              AFTER THE ASSIGNMENT TOKEN (A VARIABLE */
             /*              BEING THE FIRST TOKEN AFTER THE        */
             /*              ASSIGNMENT TOKEN).                     */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: CALCULATE_RIGHT                          */
             /* USER RESPONSE: CHECK THE RULE IN ERROR FOR          */
             /*                A SYNTAX ERROR                       */
             /* PROGRAMMER RESPONSE: TRACE THE PROGRAM FOR THE      */
             /*              CONTENTS OF THE SFARRAY TABLE OF       */
             /*              TOKENS                                 */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('726',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(926);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
          END;
       ELSE DO;
          FIRST_OP_TOKEN  = TOKEN;
          SECOND_OP_TOKEN = TOKEN + 2;
0         /*******************************************************/
          /*   HERE WE LOOK AT THE OPERATOR BIT SWITCHES TO      */
          /*   SEE WHICH TYPE OF OPERATION WAS REQUESTED...      */
          /*******************************************************/
0         /*******************************************************/
          /*   THE ACTUAL PROCESSING IS AS FOLLOWS:              */
          /*   - CALL A PROCEDURE WHICH PERFORMS THE OPERATION   */
          /*   - SAVE THE RESULT IN ANOTHER FIELD                */
          /*   - COMPRESS THE SFARRAY (I.E. SHIFT THE TOKENS     */
          /*       OF THE EXPRESSION TWO ENTRIES TO THE LEFT     */
          /*       IN ORDER TO DISCARD THE OPERATION EXECUTED    */
          /*       PREVIOUSLY - IT TOOK THREE TOKENS AND IS      */
          /*       WITH ONE SINGLE TOKEN WHICH HOLDS THE RESULT  */
          /*       OF THE OPERATION)                             */
          /*   THE COMPRESSION OF THE SFARRAY WILL BE REPEATED   */
          /*   UNTIL THERE IS ONLY ONE SINGLE RESULT TOKEN ON    */
          /*   THE RIGHT SIDE OF THE ASSIGNMENT STATEMENT...     */
          /*******************************************************/
0         SELECT(SFARRAY.VAR_TYPE.OPERATOR(TOKEN+1));
                WHEN('1000') DO;
                    CALL MULTIPLY_OPERATION;
                    TARGET = MUL_TARGET;
                    CALL COMPRESS_SFARRAY;
                    END;
                WHEN('0100') DO;
                    CALL DIVIDE_OPERATION;
                    TARGET = DIV_TARGET;
                    CALL COMPRESS_SFARRAY;
                    END;
                WHEN('0010') DO;
                    CALL SUBTRACT_OPERATION;
                    TARGET = SUB_TARGET;
                    CALL COMPRESS_SFARRAY;
                    END;
                WHEN('0001') DO;
                    CALL ADD_OPERATION;
                    TARGET = ADD_TARGET;
                    CALL COMPRESS_SFARRAY;
                    END;
                OTHERWISE;
          END;
          END;
     END;
   END;
0END;
0END CALCULATE_RIGHT;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE COMPRESSES THE SFARRAY BY SHIFTING    */
 /*            ALL FURTHER ELEMENTS TWO ELEMENTS TO THE LEFT SIDE   */
 /*******************************************************************/
0COMPRESS_SFARRAY: PROCEDURE;
0/*******************************************************************/
 /* FIRST SET THE CALCULATED ARRAY ELEMENT (IS ALWAYS THE FIRST     */
 /* ELEMENT IF THERE ARE NO PARENTHESES)                            */
 /*******************************************************************/
0SFARRAY(1)='';
 SFARRAY.DEC_FIXED(1)      = '1'B;
 SFARRAY.TEMP_FIELD(1)     = '1'B;
 SFARRAY.DEC_FIELD(1)      = TARGET;
 SFARRAY.DIGITS(1)         = 15;
 SFARRAY.SCALE(1)          = 3;
0/*******************************************************************/
 /* NOW DO THE SHIFT TO THE LEFT                                    */
 /*******************************************************************/
0DO SHIFT = 2 TO EXPRESSION_TOKEN-2;
    SFARRAY(SHIFT)=SFARRAY(SHIFT+2), BY NAME;
 END;
 EXPRESSION_TOKEN=EXPRESSION_TOKEN-2;
0END COMPRESS_SFARRAY;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE PROCESSES A SINGLE ADD OPERATION      */
 /*  PARAMETERS: FIRST_OP_TOKEN... IS THE INDEX WHERE TO FIND       */
 /*                    THE DATA INFORMATION ABOUT THE FIRST OPERAND */
 /*              SECOND_OP_TOKEN... IS THE INDEX WHERE TO FIND      */
 /*                    THE DATA INFORMATION ABOUT THE FIRST OPERAND */
 /*******************************************************************/
0ADD_OPERATION: PROCEDURE;
0/*******************************************************************/
 /*   FIRST WE LOOK WHETHER THE OPERAND TYPES ARE COMPATIBLE        */
 /*   (IT MAKES NO SENSE TO ADD CHARACTER FIELDS)...                */
 /*******************************************************************/
0SELECT;
       WHEN(SFARRAY.VAR_TYPE.DEC_FIXED(FIRST_OP_TOKEN)='1'B) DO;
           FIRST_OPERAND =
           SFARRAY.CALCULATION_FIELD.DEC_FIELD(FIRST_OP_TOKEN);
           END;
       WHEN(SFARRAY.VAR_TYPE.CHARACTER(FIRST_OP_TOKEN)='1'B) DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI727                                    */
             /* MESSAGE: FIRST OPERAND OF AN ADDITION IS A          */
             /*          CHAR-FIELD (LINE XXXXX)                    */
             /* MESSAGECLASS: RULE ERROR MESSAGE                    */
             /* EXPLANATION: THE FIRST OPERAND OF AN ADD-OPERATION  */
             /*              WAS FOUND TO BE A CHARACTER FIELD.     */
             /* SEVERITY: 4                                         */
             /* PROCEDURE: ADD_OPERATION                            */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              INITIALISATION OF A FIELD              */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS              */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('727',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(927);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
0            /*******************************************************/
             /*  FOR SOME TIME, WE USED THE FOLLOWING FEW LINES     */
             /*  OF CODE TO CONVERT NON-NUMERIC CHARACTERS TO ZERO  */
             /*  IN ORDER TO SUPPORT THE USE OF CHARACTER FIELDS    */
             /*  IN NUMERIC OPERATIONS. THE CODE HAS BEEN TAKEN     */
             /*  OUT BECAUSE BUILTIN-FUNCTIONS MAY BE USED NOW TO   */
             /*  CONVERT BETWEEN DIFFERENT VARIABLE TYPES IF        */
             /*  NECESSARY.                                         */
             /*-----------------------------------------------------*/
             /*DO N=1 TO SFARRAY.DIGITS(FIRST_OP_TOKEN);            */
             /*IF (VERIFY(SUBSTR(SFARRAY.CHAR_FIELD(FIRST_OP_TOKEN),*/
             /*    N,1),NUMERIC))>0                                 */
             /*THEN SUBSTR(SFARRAY.CHAR_FIELD(FIRST_OP_TOKEN),      */
             /*    N,1)='0';                                        */
             /*END;                                                 */
             /*FIRST_OPERAND =                                      */
             /*SFARRAY.CHAR_FIELD(FIRST_OP_TOKEN);                  */
             /*-----------------------------------------------------*/
             /*******************************************************/
           END;
0END;
 SELECT;
       WHEN(SFARRAY.VAR_TYPE.DEC_FIXED(SECOND_OP_TOKEN)='1'B) DO;
           SECOND_OPERAND =
           SFARRAY.CALCULATION_FIELD.DEC_FIELD(SECOND_OP_TOKEN);
           END;
       WHEN(SFARRAY.VAR_TYPE.CHARACTER(SECOND_OP_TOKEN)='1'B) DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI728                                    */
             /* MESSAGE: SECOND OPERAND OF AN ADD-OPERATION IS A    */
             /*          CHARACTER-FIELD                            */
             /* MESSAGECLASS: CALCULATION WARNING MESSAGE           */
             /* EXPLANATION: THE SECOND OPERAND OF AN ADD-OPERATION */
             /*              WAS FOUND TO BE A CHARACTER FIELD.     */
             /* SEVERITY: 4                                         */
             /* PROCEDURE: ADD_OPERATION                            */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              INITIALISATION OF A FIELD              */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS              */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('728',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(928);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
0            /********************************************************/
             /*  FOR SOME TIME, WE USED THE FOLLOWING FEW LINES      */
             /*  OF CODE TO CONVERT NON-NUMERIC CHARACTERS TO ZERO   */
             /*  IN ORDER TO SUPPORT THE USE OF CHARACTER FIELDS     */
             /*  IN NUMERIC OPERATIONS. THE CODE HAS BEEN TAKEN      */
             /*  OUT BECAUSE BUILTIN-FUNCTIONS MAY BE USED NOW TO    */
             /*  CONVERT BETWEEN DIFFERENT VARIABLE TYPES IF         */
             /*  NECESSARY.                                          */
             /*------------------------------------------------------*/
             /*DO N=1 TO SFARRAY.DIGITS(SECOND_OP_TOKEN);            */
             /*IF (VERIFY(SUBSTR(SFARRAY.CHAR_FIELD(SECOND_OP_TOKEN),*/
             /*    N,1),NUMERIC))>0                                  */
             /*THEN SUBSTR(SFARRAY.CHAR_FIELD(SECOND_OP_TOKEN),      */
             /*    N,1)='0';                                         */
             /*END;                                                  */
             /*SECOND_OPERAND =                                      */
             /*SFARRAY.CHAR_FIELD(SECOND_OP_TOKEN);                  */
             /*------------------------------------------------------*/
             /********************************************************/
           END;
           OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI729                                    */
             /* MESSAGE: SFARRAY CONTAINS UNKNOWN TOKEN             */
             /* MESSAGECLASS: INTERPRETER INTERNAL ERROR            */
             /* EXPLANATION: THE INTERPRETER FOUND AN INVALID       */
             /*              TYPE OF TOKEN IN THE SFARRAY-STRUCTURE */
             /* SEVERITY: 12                                        */
             /* PROCEDURE: ADD_OPERATION                            */
             /* PROGRAMMER RESPONSE: TRACE THE RUNNING PROGRAM      */
             /*              TO CHECK THE CONTENT OF THE SFARRAY    */
             /*              STRUCTURE. ONE OF THE BIT SWITCHES     */
             /*              IN SFARRAY.VAR_TYPE MUST HAVE BEEN SET */
             /*              TO '1'.                                */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('729',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(929);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
           END;
 END;
0/*******************************************************/
 /*  HERE WE LOOK FOR THE MAXIMUM LENGTH OF DIGITS      */
 /*  OR SCALE IN BOTH OPERANDS                          */
 /*******************************************************/
0DIGITS_MAX = MAX(SFARRAY.DIGITS(FIRST_OP_TOKEN),
                  SFARRAY.DIGITS(SECOND_OP_TOKEN));
0SCALE_MAX = MAX(SFARRAY.SCALE(FIRST_OP_TOKEN),
                 SFARRAY.SCALE(SECOND_OP_TOKEN));
 UPSK('A SCALE_MAX ',SCALE_MAX);
0IF (DIGITS_MAX < 1) ! (DIGITS_MAX > 15) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI730                                    */
             /* MESSAGE: XXX DIGITS IN VARIABLE (LINE XXXXX)        */
             /* MESSAGECLASS: CALCULATION ERROR MESSAGE             */
             /* EXPLANATION: THE NUMBER OF DIGITS OF A VARIABLE WAS */
             /*              FOUND TO BE GREATER THAN 15. THIS MAY  */
             /*              BE CAUSED BY AN ARITHMETIC OPERATION   */
             /*              USING A CHARACTER VARIABLE DEFINED TO  */
             /*              HAVE MORE THAN 15 CHARACTERS...        */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: ADD_OPERATION                            */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS (E.G. TOO   */
             /*              MANY DIGITS ENTERED INTO A FIELD)      */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /*              OR LIMIT THE CHARACTER FIELD LENGTH    */
             /*              TO A NUMBER LESS THAN 16               */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('730',DIGITS_MAX !! ',' !!
                         SUBSTR(LINECHAR,7,3) !! ',' !!
                         SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(930);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
    END;
 UPSK('B SCALE_MAX ',SCALE_MAX);
0IF (SCALE_MAX < 0) ! (SCALE_MAX > 5) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI731                                    */
             /* MESSAGE: SCALE IS *V IN VARIABLE (LINE XXXXX)       */
             /*          4                                          */
             /* MESSAGECLASS: CALCULATION ERROR MESSAGE             */
             /* EXPLANATION: THE NUMBER OF SCALE OF A VARIABLE WAS  */
             /*              FOUND TO BE GREATER THAN 4 OR LESS     */
             /*              THAN 0.                                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: ADD_OPERATION                            */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS (E.G. TOO   */
             /*              MANY DIGITS ENTERED INTO A FIELD)      */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('731',SCALE_MAX !! ',' !!
                         SUBSTR(LINECHAR,7,3) !! ',' !!
                         SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(931);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
    END;
0/********************************************************************/
 /*  DO SOME CALCULATIONS NECESSARY FOR HANDLING THE INTERPRETER     */
 /*  INTERNAL PRECISION OF VARIABLES.                                */
 /********************************************************************/
 IF ((SFARRAY.CONSTANT(FIRST_OP_TOKEN)='1'B) !
    (SFARRAY.TEMP_FIELD(FIRST_OP_TOKEN)='1'B) !
    (SFARRAY.USER_VARIABLE(FIRST_OP_TOKEN)='1'B)) THEN
    HELP_TARGET_1 = FIRST_OPERAND;
 ELSE HELP_TARGET_1 =
     FIRST_OPERAND/(10**(SFARRAY.SCALE(FIRST_OP_TOKEN)));
 IF ((SFARRAY.CONSTANT(SECOND_OP_TOKEN)='1'B) !
    (SFARRAY.TEMP_FIELD(SECOND_OP_TOKEN)='1'B) !
    (SFARRAY.USER_VARIABLE(SECOND_OP_TOKEN)='1'B)) THEN
    HELP_TARGET_2 = SECOND_OPERAND;
 ELSE HELP_TARGET_2 =
     SECOND_OPERAND/(10**(SFARRAY.SCALE(SECOND_OP_TOKEN)));
 UPSK('C SCALE_MAX ',SCALE_MAX);
0SELECT(SCALE_MAX);
       WHEN(0) DO;
           ADD_TARGET = ROUND(ADD(HELP_TARGET_1,HELP_TARGET_2,15,1),0);
           END;
       WHEN(1) DO;
           ADD_TARGET = ROUND(ADD(HELP_TARGET_1,HELP_TARGET_2,15,2),1);
           END;
       WHEN(2) DO;
           ADD_TARGET = ROUND(ADD(HELP_TARGET_1,HELP_TARGET_2,15,3),2);
           END;
       WHEN(3) DO;
           ADD_TARGET = ROUND(ADD(HELP_TARGET_1,HELP_TARGET_2,15,4),3);
           END;
       WHEN(4) DO;
           ADD_TARGET = ROUND(ADD(HELP_TARGET_1,HELP_TARGET_2,15,5),4);
           END;
       WHEN(5) DO;
           ADD_TARGET = ROUND(ADD(HELP_TARGET_1,HELP_TARGET_2,15,5),5);
           END;
           OTHERWISE;
  END;
0END ADD_OPERATION;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE PROCESSES A SINGLE SUBTRACT OPERATION */
 /*  PARAMETERS: FIRST_OP_TOKEN... IS THE INDEX WHERE TO FIND       */
 /*                    THE DATA INFORMATION ABOUT THE FIRST OPERAND */
 /*              SECOND_OP_TOKEN... IS THE INDEX WHERE TO FIND      */
 /*                    THE DATA INFORMATION ABOUT THE FIRST OPERAND */
 /*******************************************************************/
0SUBTRACT_OPERATION: PROCEDURE;
0/*******************************************************************/
 /*   FIRST WE LOOK WHETHER THE OPERAND TYPES ARE COMPATIBLE        */
 /*   (IT MAKES NO SENSE TO SUBTRACT CHARACTER FIELDS)...           */
 /*******************************************************************/
0SELECT;
       WHEN(SFARRAY.VAR_TYPE.DEC_FIXED(FIRST_OP_TOKEN)='1'B) DO;
           FIRST_OPERAND =
           SFARRAY.CALCULATION_FIELD.DEC_FIELD(FIRST_OP_TOKEN);
           END;
       WHEN(SFARRAY.VAR_TYPE.CHARACTER(FIRST_OP_TOKEN)='1'B) DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI732                                    */
             /* MESSAGE: FIRST OPERAND OF A SUBTRACT-OPERATION IS A */
             /*          CHARACTER-FIELD                            */
             /* MESSAGECLASS: CALCULATION WARNING MESSAGE           */
             /* EXPLANATION: THE FIRST OPERAND OF AN A SUBTRACT-OP  */
             /*              WAS FOUND TO BE A CHARACTER FIELD.     */
             /*              AS DEFINED, IT IS ALLOWED TO CALCULATE */
             /*              USING CHARACTER-FIELDS, BUT A WARNING  */
             /*              MESSAGE IS GENERATED. IF THERE IS AN   */
             /*              INVALID VALUE IN THE CHARACTER FIELD   */
             /*              (E.G. AN ALPHABETIC CHARACTER OR A     */
             /*              SPECIAL CHARACTER) THE INTERPRETER     */
             /*              WILL NOT BE ABLE TO PROCESS FURTHER    */
             /*              CORRECTLY, BUT THERE WILL BE A DATA    */
             /*              EXCEPTION OR AN EQUIVALENT ERROR.      */
             /* SEVERITY: 4                                         */
             /* PROCEDURE: SUBTRACT_OPERATION                       */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS             */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS              */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('732',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(932);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
0            /*******************************************************/
             /*  FOR SOME TIME, WE USED THE FOLLOWING FEW LINES     */
             /*  OF CODE TO CONVERT NON-NUMERIC CHARACTERS TO ZERO  */
             /*  IN ORDER TO SUPPORT THE USE OF CHARACTER FIELDS    */
             /*  IN NUMERIC OPERATIONS. THE CODE HAS BEEN TAKEN     */
             /*  OUT BECAUSE BUILTIN-FUNCTIONS MAY BE USED NOW TO   */
             /*  CONVERT BETWEEN DIFFERENT VARIABLE TYPES IF        */
             /*  NECESSARY.                                         */
             /*-----------------------------------------------------*/
             /*DO N=1 TO SFARRAY.DIGITS(FIRST_OP_TOKEN);            */
             /*IF (VERIFY(SUBSTR(SFARRAY.CHAR_FIELD(FIRST_OP_TOKEN),*/
             /*   N,1),NUMERIC))>0                                  */
             /*THEN SUBSTR(SFARRAY.CHAR_FIELD(FIRST_OP_TOKEN),      */
             /*   N,1)='0';                                         */
             /*END;                                                 */
             /*FIRST_OPERAND =                                      */
             /*SFARRAY.CHAR_FIELD(FIRST_OP_TOKEN);                  */
0            /*******************************************************/
            END;
0END;  /* END SELECT TYPE OF SFARRAY.VAR_TYPE */
0SELECT;
       WHEN(SFARRAY.VAR_TYPE.DEC_FIXED(SECOND_OP_TOKEN)='1'B) DO;
           SECOND_OPERAND =
           SFARRAY.CALCULATION_FIELD.DEC_FIELD(SECOND_OP_TOKEN);
           END;
       WHEN(SFARRAY.VAR_TYPE.BIN_FIXED(SECOND_OP_TOKEN)='1'B) DO;
           SECOND_OPERAND =
           DECIMAL (SFARRAY.BIN_FIELD(SECOND_OP_TOKEN),15,4);
           END;
       WHEN(SFARRAY.VAR_TYPE.CHARACTER(SECOND_OP_TOKEN)='1'B) DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI733                                    */
             /* MESSAGE: SECOND OPERAND OF AN SUBTRACT_OPERATION IS */
             /*          A CHARACTER-FIELD                          */
             /* MESSAGECLASS: CALCULATION WARNING MESSAGE           */
             /* EXPLANATION: THE SECOND OPERAND OF A SUBTRACT-OP    */
             /*              WAS FOUND TO BE A CHARACTER FIELD.     */
             /*              AS DEFINED, IT IS ALLOWED TO CALCULATE */
             /*              USING CHARACTER-FIELDS, BUT A WARNING  */
             /*              MESSAGE IS GENERATED. IF THERE IS AN   */
             /*              INVALID VALUE IN THE CHARACTER FIELD   */
             /*              (E.G. AN ALPHABETIC CHARACTER OR A     */
             /*              SPECIAL CHARACTER) THE INTERPRETER     */
             /*              WILL NOT BE ABLE TO PROCESS FURTHER    */
             /*              CORRECTLY, BUT THERE WILL BE A DATA    */
             /*              EXCEPTION OR AN EQUIVALENT ERROR.      */
             /* SEVERITY: 4                                         */
             /* PROCEDURE: SUBTRACT_OPERATION                       */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS             */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS              */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('733',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(933);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
0            /********************************************************/
             /*  FOR SOME TIME, WE USED THE FOLLOWING FEW LINES      */
             /*  OF CODE TO CONVERT NON-NUMERIC CHARACTERS TO ZERO   */
             /*  IN ORDER TO SUPPORT THE USE OF CHARACTER FIELDS     */
             /*  IN NUMERIC OPERATIONS. THE CODE HAS BEEN TAKEN      */
             /*  OUT BECAUSE BUILTIN-FUNCTIONS MAY BE USED NOW TO    */
             /*  CONVERT BETWEEN DIFFERENT VARIABLE TYPES IF         */
             /*  NECESSARY.                                          */
             /*------------------------------------------------------*/
             /*DO N=1 TO SFARRAY.DIGITS(SECOND_OP_TOKEN);            */
             /*IF (VERIFY(SUBSTR(SFARRAY.CHAR_FIELD(SECOND_OP_TOKEN),*/
             /*    N,1),NUMERIC))>0                                  */
             /*THEN SUBSTR(SFARRAY.CHAR_FIELD(SECOND_OP_TOKEN),      */
             /*    N,1)='0';                                         */
             /*END;                                                  */
             /*SECOND_OPERAND =                                      */
             /*SFARRAY.CHAR_FIELD(SECOND_OP_TOKEN);                  */
             /*------------------------------------------------------*/
             /********************************************************/
           END;
           OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI729                                    */
             /* MESSAGE: SFARRAY CONTAINS UNKNOWN TOKEN             */
             /* MESSAGECLASS: INTERPRETER INTERNAL ERROR            */
             /* EXPLANATION: THE INTERPRETER FOUND AN INVALID       */
             /*              TYPE OF TOKEN IN THE SFARRAY-STRUCTURE */
             /* SEVERITY: 12                                        */
             /* PROCEDURE: SUBTRACT_OPERATION                       */
             /* PROGRAMMER RESPONSE: TRACE THE RUNNING PROGRAM      */
             /*              TO CHECK THE CONTENT OF THE SFARRAY    */
             /*              STRUCTURE. ONE OF THE BIT SWITCHES     */
             /*              IN SFARRAY.VAR_TYPE MUST HAVE BEEN SET */
             /*              TO '1'.                                */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('729',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(929);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
           END;
0END;
0/*******************************************************/
 /*  HERE WE LOOK FOR THE MAXIMUM LENGTH OF DIGITS      */
 /*  OR SCALE IN BOTH OPERANDS                          */
 /*******************************************************/
0DIGITS_MAX = MAX(SFARRAY.DIGITS(FIRST_OP_TOKEN),
                  SFARRAY.DIGITS(SECOND_OP_TOKEN));
0SCALE_MAX = MAX(SFARRAY.SCALE(FIRST_OP_TOKEN),
                 SFARRAY.SCALE(SECOND_OP_TOKEN));
 UPSK('D SCALE_MAX ',SCALE_MAX);
0IF (DIGITS_MAX < 1) ! (DIGITS_MAX > 15) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI730                                    */
             /* MESSAGE: XXX DIGITS IN VARIABLE (LINE XXXX)         */
             /* MESSAGECLASS: CALCULATION ERROR MESSAGE             */
             /* EXPLANATION: THE NUMBER OF DIGITS OF A VARIABLE WAS */
             /*              FOUND TO BE GREATER THAN 15. THIS MAY  */
             /*              BE CAUSED BY AN ARITHMETIC OPERATION   */
             /*              USING A CHARACTER VARIABLE DEFINED TO  */
             /*              HAVE MORE THAN 15 CHARACTERS...        */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SUBTRACT_OPERATION                       */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS (E.G. TOO   */
             /*              MANY DIGITS ENTERED INTO A FIELD)      */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /*              OR LIMIT THE CHARACTER FIELD LENGTH    */
             /*              TO A NUMBER LESS THAN 16               */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('730',DIGITS_MAX !! ',' !!
                         SUBSTR(LINECHAR,7,3) !! ',' !!
                         SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(930);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU      = '1'B;
                GOTO ABEND;
             END;
    END;
 UPSK('E SCALE_MAX ',SCALE_MAX);
0IF (SCALE_MAX < 0) ! (SCALE_MAX > 5) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI731                                    */
             /* MESSAGE: SCALE IS XXX IN VARIABLE (LINE XXXX)       */
             /* MESSAGECLASS: CALCULATION ERROR MESSAGE             */
             /* EXPLANATION: THE NUMBER OF SCALE OF A VARIABLE WAS  */
             /*              FOUND TO BE GREATER THAN 4 OR LESS     */
             /*              THAN 0.                                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: SUBTRACT_OPERATION                       */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS (E.G. TOO   */
             /*              MANY DIGITS ENTERED INTO A FIELD)      */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('731',SCALE_MAX !! ',' !!
                         SUBSTR(LINECHAR,7,3) !! ',' !!
                         SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(931);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
    END;
0/********************************************************************/
 /* THE FOLLOWING TURNS THE SECOND OPERAND INTO A NEGATIVE          */
 /* NUMBER IN ORDER TO ALLOW FOR THE USE OF THE ADD BUILT-IN-FNCT   */
 /********************************************************************/
0SECOND_OPERAND=-SECOND_OPERAND;
0/********************************************************************/
 /* INTERPRETER INTERNAL COMPUTATIONS GAIN...                       */
 /********************************************************************/
0IF ((SFARRAY.USER_VARIABLE(FIRST_OP_TOKEN)='1'B) !
     (SFARRAY.TEMP_FIELD(FIRST_OP_TOKEN)='1'B) !
     (SFARRAY.CONSTANT(FIRST_OP_TOKEN)='1'B)) THEN
     HELP_TARGET_1 = FIRST_OPERAND;
 ELSE HELP_TARGET_1 =
     FIRST_OPERAND/(10**(SFARRAY.SCALE(FIRST_OP_TOKEN)));
 IF ((SFARRAY.USER_VARIABLE(SECOND_OP_TOKEN)='1'B) !
    (SFARRAY.TEMP_FIELD(SECOND_OP_TOKEN)='1'B) !
    (SFARRAY.CONSTANT(SECOND_OP_TOKEN)='1'B)) THEN
    HELP_TARGET_2 = SECOND_OPERAND;
 ELSE HELP_TARGET_2 =
    SECOND_OPERAND/(10**(SFARRAY.SCALE(SECOND_OP_TOKEN)));
0/********************************************************************/
 /* HERE FOLLOWS THE SAME PROCESSING AS FOR THE ADD-FUNCTION        */
 /* (THE ONLY DIFFERENCE BEING THE NEAGTIVE SIGN BEFORE THE         */
 /* SECOND OPERAND)                                                 */
 /********************************************************************/
 UPSK('F SCALE_MAX ',SCALE_MAX);
0SELECT(SCALE_MAX);
       WHEN(0) DO;
           SUB_TARGET = ADD(HELP_TARGET_1,HELP_TARGET_2,15,0);
           END;
       WHEN(1) DO;
           SUB_TARGET = ADD(HELP_TARGET_1,HELP_TARGET_2,15,1);
           END;
       WHEN(2) DO;
           SUB_TARGET = ADD(HELP_TARGET_1,HELP_TARGET_2,15,2);
           END;
       WHEN(3) DO;
           SUB_TARGET = ADD(HELP_TARGET_1,HELP_TARGET_2,15,3);
           END;
       WHEN(4) DO;
           SUB_TARGET = ADD(HELP_TARGET_1,HELP_TARGET_2,15,4);
           END;
       WHEN(5) DO;
           SUB_TARGET = ADD(HELP_TARGET_1,HELP_TARGET_2,15,5);
           END;
  END;
0END SUBTRACT_OPERATION;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE PROCESSES A SINGLE MULTIPLY OPERATION */
 /*  PARAMETERS: FIRST_OP_TOKEN, SECOND_OP_TOKEN                    */
 /*******************************************************************/
0MULTIPLY_OPERATION: PROCEDURE;
0/*******************************************************************/
 /*  CHANGES MADE TO SUPPORT LARGE NUMBERS...                       */
 /*******************************************************************/
 PUT SKIP LIST('NOW I TRY THE NEW MULTIPLY:');
 PUT SKIP LIST('PREVIOUSLY:');
 PUT DATA(SFARRAY(FIRST_OP_TOKEN));
 PUT DATA(SFARRAY(SECOND_OP_TOKEN));
 /*
 IF (SFARRAY.SCALE(FIRST_OP_TOKEN) >= 5) THEN DO;
    SFARRAY.CALCULATION_FIELD.DEC_FIELD(FIRST_OP_TOKEN) =
            SFARRAY.CALCULATION_FIELD.DEC_FIELD(FIRST_OP_TOKEN) * 100;
    SFARRAY.SCALE(FIRST_OP_TOKEN)=SFARRAY.SCALE(FIRST_OP_TOKEN)-2;
    END;
 IF (SFARRAY.SCALE(SECOND_OP_TOKEN) >= 5) THEN DO;
    SFARRAY.CALCULATION_FIELD.DEC_FIELD(SECOND_OP_TOKEN) =
            SFARRAY.CALCULATION_FIELD.DEC_FIELD(SECOND_OP_TOKEN) * 100;
    SFARRAY.SCALE(SECOND_OP_TOKEN)=SFARRAY.SCALE(SECOND_OP_TOKEN)-2;
    END;
 */
0SELECT;
       WHEN(SFARRAY.VAR_TYPE.DEC_FIXED(FIRST_OP_TOKEN)='1'B) DO;
           FIRST_OPERAND =
           SFARRAY.CALCULATION_FIELD.DEC_FIELD(FIRST_OP_TOKEN);
           END;
       WHEN(SFARRAY.VAR_TYPE.CHARACTER(FIRST_OP_TOKEN)='1'B) DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI737                                    */
             /* MESSAGE: FIRST OPERAND OF A MULTIPLY-OPERATION IS A */
             /*          CHARACTER-FIELD                            */
             /* MESSAGECLASS: CALCULATION WARNING MESSAGE           */
             /* EXPLANATION: THE FIRST OPERAND OF AN MULTIPLY-OP    */
             /*              WAS FOUND TO BE A CHARACTER FIELD.     */
             /*              AS DEFINED, IT IS ALLOWED TO CALCULATE */
             /*              USING CHARACTER-FIELDS, BUT A WARNING  */
             /*              MESSAGE IS GENERATED. IF THERE IS AN   */
             /*              INVALID VALUE IN THE CHARACTER FIELD   */
             /*              (E.G. AN ALPHABETIC CHARACTER OR A     */
             /*              SPECIAL CHARACTER) THE INTERPRETER     */
             /*              WILL NOT BE ABLE TO PROCESS FURTHER    */
             /*              CORRECTLY, BUT THERE WILL BE A DATA    */
             /*              EXCEPTION OR AN EQUIVALENT ERROR.      */
             /* SEVERITY: 4                                         */
             /* PROCEDURE: MULTIPLY_OPERATION                       */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS             */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS              */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('737',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(937);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
           END;
           OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI729                                    */
             /* MESSAGE: SFARRAY CONTAINS UNKNOWN TOKEN             */
             /* MESSAGECLASS: INTERPRETER INTERNAL ERROR            */
             /* EXPLANATION: THE INTERPRETER FOUND AN INVALID       */
             /*              TYPE OF TOKEN IN THE SFARRAY-STRUCTURE */
             /* SEVERITY: 12                                        */
             /* PROCEDURE: MULTIPLY_OPERATION                       */
             /* PROGRAMMER RESPONSE: TRACE THE RUNNING PROGRAM      */
             /*              TO CHECK THE CONTENT OF THE SFARRAY    */
             /*              STRUCTURE. ONE OF THE BIT SWITCHES     */
             /*              IN SFARRAY.VAR_TYPE MUST HAVE BEEN SET */
             /*              TO '1'.                                */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('729',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(929);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
           END;
0END;
 SELECT;
       WHEN(SFARRAY.VAR_TYPE.DEC_FIXED(SECOND_OP_TOKEN)='1'B) DO;
           SECOND_OPERAND =
           SFARRAY.CALCULATION_FIELD.DEC_FIELD(SECOND_OP_TOKEN);
           END;
       WHEN(SFARRAY.VAR_TYPE.CHARACTER(SECOND_OP_TOKEN)='1'B) DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI739                                    */
             /* MESSAGE: SECOND OPERAND OF A MULTIPLY-OP IS A       */
             /*          CHARACTER-FIELD                            */
             /* MESSAGECLASS: CALCULATION WARNING MESSAGE           */
             /* EXPLANATION: THE SECOND OPERAND OF AN MULTIPLY-OP   */
             /*              WAS FOUND TO BE A CHARACTER FIELD.     */
             /*              AS DEFINED, IT IS ALLOWED TO CALCULATE */
             /*              USING CHARACTER-FIELDS, BUT A WARNING  */
             /*              MESSAGE IS GENERATED. IF THERE IS AN   */
             /*              INVALID VALUE IN THE CHARACTER FIELD   */
             /*              (E.G. AN ALPHABETIC CHARACTER OR A     */
             /*              SPECIAL CHARACTER) THE INTERPRETER     */
             /*              WILL NOT BE ABLE TO PROCESS FURTHER    */
             /*              CORRECTLY, BUT THERE WILL BE A DATA    */
             /*              EXCEPTION OR AN EQUIVALENT ERROR.      */
             /* SEVERITY: 4                                         */
             /* PROCEDURE: MULTIPLY_OPERATION                       */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS             */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS              */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('739',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(939);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU     = '1'B;
                GOTO ABEND;
             END;
           END;
           OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI729                                    */
             /* MESSAGE: SFARRAY CONTAINS UNKNOWN TOKEN             */
             /* MESSAGECLASS: INTERPRETER INTERNAL ERROR            */
             /* EXPLANATION: THE INTERPRETER FOUND AN INVALID       */
             /*              TYPE OF TOKEN IN THE SFARRAY-STRUCTURE */
             /*              (NONE OF THE VAR_TYPE-BITS WAS SET)    */
             /* SEVERITY: 12                                        */
             /* PROCEDURE: MULTIPLY_OPERATION                       */
             /* PROGRAMMER RESPONSE: TRACE THE RUNNING PROGRAM      */
             /*              TO CHECK THE CONTENT OF THE SFARRAY    */
             /*              STRUCTURE. ONE OF THE BIT SWITCHES     */
             /*              IN SFARRAY.VAR_TYPE MUST HAVE BEEN SET */
             /*              TO '1'.                                */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('729',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(929);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU  = '1'B;
                GOTO ABEND;
             END;
           END;
0END;
0/*******************************************************************/
 /*  THE FOLLOWING PROCESSING IS ALMOST THE SAME AS FOR ALL         */
 /*  PREVIOUS FUNCTIONS...                                          */
 /*******************************************************************/
0DIGITS_MAX = MAX(SFARRAY.DIGITS(FIRST_OP_TOKEN),
                  SFARRAY.DIGITS(SECOND_OP_TOKEN));
0SCALE_MAX = MAX(SFARRAY.SCALE(FIRST_OP_TOKEN),
                 SFARRAY.SCALE(SECOND_OP_TOKEN));
 UPSK('G SCALE_MAX ',SCALE_MAX);
 PUT DATA(SFARRAY(FIRST_OP_TOKEN));
 PUT DATA(SFARRAY(SECOND_OP_TOKEN));
0IF (DIGITS_MAX < 1) ! (DIGITS_MAX > 15) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI730                                    */
             /* MESSAGE: XXX DIGITS IN VARIABLE (LINE XXX)          */
             /* MESSAGECLASS: CALCULATION ERROR MESSAGE             */
             /* EXPLANATION: THE NUMBER OF DIGITS OF A VARIABLE WAS */
             /*              FOUND TO BE GREATER THAN 15. THIS MAY  */
             /*              BE CAUSED BY AN ARITHMETIC OPERATION   */
             /*              USING A CHARACTER VARIABLE DEFINED TO  */
             /*              HAVE MORE THAN 15 CHARACTERS...        */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: MULTIPLY_OPERATION                       */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS (E.G. TOO   */
             /*              MANY DIGITS ENTERED INTO A FIELD)      */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /*              OR LIMIT THE CHARACTER FIELD LENGTH    */
             /*              TO A NUMBER LESS THAN 16               */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('730',DIGITS_MAX !! ',' !!
                         SUBSTR(LINECHAR,7,3) !! ',' !!
                         SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(930);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU  = '1'B;
                GOTO ABEND;
             END;
    END;
 UPSK('H SCALE_MAX ',SCALE_MAX);
0IF (SCALE_MAX < 0) ! (SCALE_MAX > 5) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI731                                    */
             /* MESSAGE: SCALE IS XXX IN VARIABLE (LINE XXX)        */
             /* MESSAGECLASS: CALCULATION ERROR MESSAGE             */
             /* EXPLANATION: THE NUMBER OF SCALE OF A VARIABLE WAS  */
             /*              FOUND TO BE GREATER THAN 4 OR LESS     */
             /*              THAN 0.                                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: MULTIPLY_OPERATION                       */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS (E.G. TOO   */
             /*              MANY DIGITS ENTERED INTO A FIELD)      */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('731',SCALE_MAX !! ',' !!
                         SUBSTR(LINECHAR,7,3) !! ',' !!
                         SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(931);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
    END;
 PUT SKIP LIST('FIRST_OPERAND=',FIRST_OPERAND);
 PUT SKIP LIST('SECOND_OPERAND=',SECOND_OPERAND);
 MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,15,2);
 /*
 UPSK('I SCALE_MAX ',SCALE_MAX);
 UPSK('I DIGITS_MAX ',DIGITS_MAX);
 SELECT(DIGITS_MAX);
   WHEN(1) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,1,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,1,1);
      END;
      END;
   WHEN(2) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,2,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,2,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,2,2);
      END;
      END;
   WHEN(3) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,3,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,3,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,3,2);
            WHEN(3)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,3,3);
      END;
      END;
   WHEN(4) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,4,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,4,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,4,2);
            WHEN(3)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,4,3);
            WHEN(4)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,4,4);
      END;
      END;
   WHEN(5) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,5,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,5,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,5,2);
            WHEN(3)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,5,3);
            WHEN(4)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,5,4);
            WHEN(5)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,5,5);
      END;
      END;
   WHEN(6) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,6,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,6,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,6,2);
            WHEN(3)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,6,3);
            WHEN(4)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,6,4);
            WHEN(5,6,7)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,6,5);
      END;
      END;
   WHEN(7) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,7,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,7,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,7,2);
            WHEN(3)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,7,3);
            WHEN(4)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,7,4);
            WHEN(5,6,7)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,7,5);
      END;
      END;
   WHEN(8) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,8,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,8,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,8,2);
            WHEN(3)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,8,3);
            WHEN(4)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,8,4);
            WHEN(5,6,7)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,8,5);
      END;
      END;
   WHEN(9) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,9,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,9,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,9,2);
            WHEN(3)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,9,3);
            WHEN(4)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,9,4);
            WHEN(5,6,7)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,9,5);
      END;
      END;
   WHEN(10) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,10,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,10,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,10,2);
            WHEN(3)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,10,3);
            WHEN(4)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,10,4);
            WHEN(5,6,7)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,10,5);
      END;
      END;
   WHEN(11) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,11,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,11,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,11,2);
            WHEN(3)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,11,3);
            WHEN(4)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,11,4);
            WHEN(5,6,7)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,11,5);
      END;
      END;
   WHEN(12) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,12,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,12,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,12,2);
            WHEN(3)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,12,3);
            WHEN(4)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,12,4);
            WHEN(5,6,7)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,12,5);
      END;
      END;
   WHEN(13) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,13,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,13,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,13,2);
            WHEN(3)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,13,3);
            WHEN(4)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,13,4);
            WHEN(5,6,7)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,13,5);
      END;
      END;
   WHEN(14) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,14,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,14,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,14,2);
            WHEN(3)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,14,3);
            WHEN(4)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,14,4);
            WHEN(5,6,7)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,14,5);
      END;
      END;
   WHEN(15) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,15,0);
            WHEN(1)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,15,1);
            WHEN(2)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,15,2);
            WHEN(3)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,15,3);
            WHEN(4)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,15,4);
            WHEN(5,6,7)
              MUL_TARGET = MULTIPLY(FIRST_OPERAND,SECOND_OPERAND,15,5);
      END;
      END;
0END;
 */
 PUT SKIP LIST('MUL_TARGET=',MUL_TARGET);
0/*******************************************************************/
 /*  THE FOLLOWING LINES ARE NECESSARY TO HANDLE THE INTERPRETER'S  */
 /*  INTERNAL REPRESENTATION OF PRECISION FOR VARIABLES...          */
 /*******************************************************************/
0SCALE_ADD = 0;
0IF ((SFARRAY.TEMP_FIELD(FIRST_OP_TOKEN)^='1'B) &
    (SFARRAY.USER_VARIABLE(FIRST_OP_TOKEN)^='1'B) &
    (SFARRAY.CONSTANT(FIRST_OP_TOKEN)^='1'B)) THEN
    SCALE_ADD = SCALE_ADD + SFARRAY.SCALE(FIRST_OP_TOKEN);
0IF ((SFARRAY.TEMP_FIELD(SECOND_OP_TOKEN)^='1'B) &
    (SFARRAY.USER_VARIABLE(SECOND_OP_TOKEN)^='1'B) &
    (SFARRAY.CONSTANT(SECOND_OP_TOKEN)^='1'B)) THEN
    SCALE_ADD = SCALE_ADD + SFARRAY.SCALE(SECOND_OP_TOKEN);
 HELP_TARGET = MUL_TARGET/(10**SCALE_ADD);
 MUL_TARGET = HELP_TARGET;
 PUT SKIP LIST('MUL_TARGET AFTER ROUND=',MUL_TARGET);
0END MULTIPLY_OPERATION;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE PROCESSES A SINGLE DIVIDE OPERATION   */
 /*  PARAMETERS: FIRST_OP_TOKEN, SECOND_OP_TOKEN                    */
 /*******************************************************************/
0DIVIDE_OPERATION: PROCEDURE;
0/*******************************************************************/
 /*  THE FOLLOWING CODE IS VERY SIMILIAR TO THE PROCEDURE LISTED    */
 /*  BEFORE THE ONLY DIFFERENCE BEING THE USE OF THE DIVIDE-        */
 /*  BUILT-IN-FUNCTION...                                           */
 /*******************************************************************/
0SELECT;
       WHEN(SFARRAY.VAR_TYPE.DEC_FIXED(FIRST_OP_TOKEN)='1'B) DO;
           FIRST_OPERAND =
           SFARRAY.CALCULATION_FIELD.DEC_FIELD(FIRST_OP_TOKEN);
           END;
       WHEN(SFARRAY.VAR_TYPE.CHARACTER(FIRST_OP_TOKEN)='1'B) DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI743                                    */
             /* MESSAGE: FIRST OPERAND OF A DIVIDE-OPERATION IS A   */
             /*          CHARACTER-FIELD                            */
             /* MESSAGECLASS: CALCULATION WARNING MESSAGE           */
             /* EXPLANATION: THE FIRST OPERAND OF AN DIVIDE-OP      */
             /*              WAS FOUND TO BE A CHARACTER FIELD.     */
             /*              AS DEFINED, IT IS ALLOWED TO CALCULATE */
             /*              USING CHARACTER-FIELDS, BUT A WARNING  */
             /*              MESSAGE IS GENERATED. IF THERE IS AN   */
             /*              INVALID VALUE IN THE CHARACTER FIELD   */
             /*              (E.G. AN ALPHABETIC CHARACTER OR A     */
             /*              SPECIAL CHARACTER) THE INTERPRETER     */
             /*              WILL NOT BE ABLE TO PROCESS FURTHER    */
             /*              CORRECTLY, BUT THERE WILL BE A DATA    */
             /*              EXCEPTION OR AN EQUIVALENT ERROR.      */
             /* SEVERITY: 4                                         */
             /* PROCEDURE: DIVIDE_OPERATION                         */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS             */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS              */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('743',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(943);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU  = '1'B;
                GOTO ABEND;
             END;
           END;
           OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI729                                    */
             /* MESSAGE: SFARRAY CONTAINS UNKNOWN TOKEN (LINE XXX)  */
             /* MESSAGECLASS: INTERPRETER INTERNAL ERROR            */
             /* EXPLANATION: THE INTERPRETER FOUND AN INVALID       */
             /*              TYPE OF TOKEN IN THE SFARRAY-STRUCTURE */
             /* SEVERITY: 12                                        */
             /* PROCEDURE: DIVIDE_OPERATION                         */
             /* PROGRAMMER RESPONSE: TRACE THE RUNNING PROGRAM      */
             /*              TO CHECK THE CONTENT OF THE SFARRAY    */
             /*              STRUCTURE. ONE OF THE BIT SWITCHES     */
             /*              IN SFARRAY.VAR_TYPE MUST HAVE BEEN SET */
             /*              TO '1'.                                */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('729',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(929);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU  = '1'B;
                GOTO ABEND;
             END;
           END;
0END;
 SELECT;
       WHEN(SFARRAY.VAR_TYPE.DEC_FIXED(SECOND_OP_TOKEN)='1'B) DO;
           SECOND_OPERAND =
           SFARRAY.CALCULATION_FIELD.DEC_FIELD(SECOND_OP_TOKEN);
           END;
       WHEN(SFARRAY.VAR_TYPE.BIN_FIXED(SECOND_OP_TOKEN)='1'B) DO;
           SECOND_OPERAND =
           DECIMAL (SFARRAY.BIN_FIELD(SECOND_OP_TOKEN),15,4);
           END;
       WHEN(SFARRAY.VAR_TYPE.CHARACTER(SECOND_OP_TOKEN)='1'B) DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI745                                    */
             /* MESSAGE: SECOND OPERAND OF A DIVIDE-OP IS A         */
             /*          CHARACTER-FIELD                            */
             /* MESSAGECLASS: CALCULATION WARNING MESSAGE           */
             /* EXPLANATION: THE SECOND OPERAND OF AN MULTIPLY-OP   */
             /*              WAS FOUND TO BE A CHARACTER FIELD.     */
             /*              AS DEFINED, IT IS ALLOWED TO CALCULATE */
             /*              USING CHARACTER-FIELDS, BUT A WARNING  */
             /*              MESSAGE IS GENERATED. IF THERE IS AN   */
             /*              INVALID VALUE IN THE CHARACTER FIELD   */
             /*              (E.G. AN ALPHABETIC CHARACTER OR A     */
             /*              SPECIAL CHARACTER) THE INTERPRETER     */
             /*              WILL NOT BE ABLE TO PROCESS FURTHER    */
             /*              CORRECTLY, BUT THERE WILL BE A DATA    */
             /*              EXCEPTION OR AN EQUIVALENT ERROR.      */
             /* SEVERITY: 4                                         */
             /* PROCEDURE: DIVIDE_OPERATION                         */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS             */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS              */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('745',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(945);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU  = '1'B;
                GOTO ABEND;
             END;
           END;
           OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI729                                    */
             /* MESSAGE: SFARRAY CONTAINS UNKNOWN TOKEN             */
             /* MESSAGECLASS: INTERPRETER INTERNAL ERROR            */
             /* EXPLANATION: THE INTERPRETER FOUND AN INVALID       */
             /*              TYPE OF TOKEN IN THE SFARRAY-STRUCTURE */
             /* SEVERITY: 12                                        */
             /* PROCEDURE: DIVIDE_OPERATION                         */
             /* PROGRAMMER RESPONSE: TRACE THE RUNNING PROGRAM      */
             /*              TO CHECK THE CONTENT OF THE SFARRAY    */
             /*              STRUCTURE. ONE OF THE BIT SWITCHES     */
             /*              IN SFARRAY.VAR_TYPE MUST HAVE BEEN SET */
             /*              TO '1'.                                */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('729',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(929);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU  = '1'B;
                GOTO ABEND;
             END;
           END;
 END;
0IF SECOND_OPERAND = 0 THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI747                                    */
             /* MESSAGE: SECOND OPERAND OF A DIVISION OPERATION     */
             /*          HAS A VALUE OF ZERO                        */
             /* MESSAGECLASS: CALCULATION ERROR MESSAGE             */
             /* EXPLANATION: THE INTERPRETER EVALUATED THE SECOND   */
             /*              OPERAND OF A DIVISION OPERATION TO     */
             /*              ZERO. THIS MAY ALSO BE A TEMPORARY     */
             /*              FIELD IN THE MIDDLE OF A COMPLEX       */
             /*              ARITHMETIC EXPRESSION.                 */
             /*              THE ERROR MAY BE CAUSED BY A DIVISION  */
             /*              USING AN UNINITIALIZED FIELD IN THE    */
             /*              RULES.                                 */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DIVIDE_OPERATION                         */
             /* USER RESPONSE: CHECK THE RULES FOR CORRECT          */
             /*              INITIALISATION OF THE SECOND OPERAND   */
             /*              IN A DIVISION OPERATION.               */
             /* PROGRAMMER RESPONSE: TRACE THE RUNNING PROGRAM      */
             /*              TO CHECK THE CONTENT OF THE FIELD      */
             /*              INVOLVED AS WELL AS THE WHOLE          */
             /*              ARITHMETIC EXPRESSION.                 */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*              FURTHER PROCESSING                     */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('747',SUBSTR(LINECHAR,7,3)
                              !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(947);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU  = '1'B;
                GOTO ABEND;
             END;
    END;
0DIGITS_MAX = MAX(SFARRAY.DIGITS(FIRST_OP_TOKEN),
                  SFARRAY.DIGITS(SECOND_OP_TOKEN));
0SCALE_MAX = MAX(SFARRAY.SCALE(FIRST_OP_TOKEN),
                 SFARRAY.SCALE(SECOND_OP_TOKEN));
 UPSK('J SCALE_MAX ',SCALE_MAX);
0IF (DIGITS_MAX < 1) ! (DIGITS_MAX > 15) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI730                                    */
             /* MESSAGE: XXX DIGITS IN VARIABLE (LINE XXX)          */
             /* MESSAGECLASS: CALCULATION ERROR MESSAGE             */
             /* EXPLANATION: THE NUMBER OF DIGITS OF A VARIABLE WAS */
             /*              FOUND TO BE GREATER THAN 15. THIS MAY  */
             /*              BE CAUSED BY AN ARITHMETIC OPERATION   */
             /*              USING A CHARACTER VARIABLE DEFINED TO  */
             /*              HAVE MORE THAN 15 CHARACTERS...        */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DIVIDE_OPERATION                         */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS (E.G. TOO   */
             /*              MANY DIGITS ENTERED INTO A FIELD)      */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /*              OR LIMIT THE CHARACTER FIELD LENGTH    */
             /*              TO A NUMBER LESS THAN 16               */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('730',DIGITS_MAX !! ',' !!
                         SUBSTR(LINECHAR,7,3) !! ',' !!
                         SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(930);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU  = '1'B;
                GOTO ABEND;
             END;
    END;
 UPSK('K SCALE_MAX ',SCALE_MAX);
0IF (SCALE_MAX < 0) ! (SCALE_MAX > 5) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI731                                    */
             /* MESSAGE: NUMBER OF SCALE FOUND TO BE GREATER THAN   */
             /*          4                                          */
             /* MESSAGECLASS: CALCULATION ERROR MESSAGE             */
             /* EXPLANATION: THE NUMBER OF SCALE OF A VARIABLE WAS  */
             /*              FOUND TO BE GREATER THAN 4 OR LESS     */
             /*              THAN 0.                                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DIVIDE_OPERATION                         */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              ENTRY IN ONE OF THE FIELDS (E.G. TOO   */
             /*              MANY DIGITS ENTERED INTO A FIELD)      */
             /* PROGRAMMER RESPONSE: CHANGE THE TYPE OF THE         */
             /*              VARIABLE INVOLVED IF NECESSARY         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('731',SCALE_MAX !! ',' !!
                         SUBSTR(LINECHAR,7,3) !! ',' !!
                         SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(931);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU  = '1'B;
                GOTO ABEND;
             END;
    END;
 UPSK('L SCALE_MAX ',SCALE_MAX);
 UPSK('L DIGITS_MAX ',DIGITS_MAX);
 SELECT(DIGITS_MAX);
   WHEN(1) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,1,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,1,1);
      END;
      END;
   WHEN(2) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,2,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,2,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,2,2);
      END;
      END;
   WHEN(3) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,3,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,3,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,3,2);
            WHEN(3)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,3,3);
      END;
      END;
   WHEN(4) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,4,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,4,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,4,2);
            WHEN(3)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,4,3);
            WHEN(4)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,4,4);
      END;
      END;
   WHEN(5) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,5,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,5,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,5,2);
            WHEN(3)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,5,3);
            WHEN(4)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,5,4);
            WHEN(5)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,5,5);
      END;
      END;
   WHEN(6) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,6,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,6,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,6,2);
            WHEN(3)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,6,3);
            WHEN(4)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,6,4);
            WHEN(5)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,6,5);
      END;
      END;
   WHEN(7) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,7,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,7,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,7,2);
            WHEN(3)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,7,3);
            WHEN(4)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,7,4);
            WHEN(5)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,7,5);
      END;
      END;
   WHEN(8) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,8,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,8,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,8,2);
            WHEN(3)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,8,3);
            WHEN(4)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,8,4);
            WHEN(5)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,8,5);
      END;
      END;
   WHEN(9) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,9,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,9,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,9,2);
            WHEN(3)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,9,3);
            WHEN(4)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,9,4);
            WHEN(5)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,9,5);
      END;
      END;
   WHEN(10) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,10,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,10,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,10,2);
            WHEN(3)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,10,3);
            WHEN(4)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,10,4);
            WHEN(5)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,10,5);
      END;
      END;
   WHEN(11) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,11,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,11,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,11,2);
            WHEN(3)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,11,3);
            WHEN(4)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,11,4);
            WHEN(5)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,11,5);
      END;
      END;
   WHEN(12) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,12,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,12,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,12,2);
            WHEN(3)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,12,3);
            WHEN(4)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,12,4);
            WHEN(5)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,12,5);
      END;
      END;
   WHEN(13) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,13,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,13,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,13,2);
            WHEN(3)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,13,3);
            WHEN(4)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,13,4);
            WHEN(5)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,13,5);
      END;
      END;
   WHEN(14) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,14,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,14,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,14,2);
            WHEN(3)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,14,3);
            WHEN(4)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,14,4);
            WHEN(5)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,14,5);
      END;
      END;
   WHEN(15) DO;
      SELECT(SCALE_MAX);
            WHEN(0)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,15,0);
            WHEN(1)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,15,1);
            WHEN(2)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,15,2);
            WHEN(3)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,15,3);
            WHEN(4)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,15,4);
            WHEN(5)
              DIV_TARGET = DIVIDE(FIRST_OPERAND,SECOND_OPERAND,15,5);
      END;
      END;
0END;
 SCALE_ADD = 0;
0IF ((SFARRAY.TEMP_FIELD(FIRST_OP_TOKEN)^='1'B) &
    (SFARRAY.USER_VARIABLE(FIRST_OP_TOKEN)^='1'B) &
    (SFARRAY.CONSTANT(FIRST_OP_TOKEN)^='1'B)) THEN
    SCALE_ADD = SCALE_ADD - SFARRAY.SCALE(FIRST_OP_TOKEN);
0IF ((SFARRAY.TEMP_FIELD(SECOND_OP_TOKEN)^='1'B) &
    (SFARRAY.USER_VARIABLE(SECOND_OP_TOKEN)^='1'B) &
    (SFARRAY.CONSTANT(SECOND_OP_TOKEN)^='1'B)) THEN
    SCALE_ADD = SCALE_ADD + SFARRAY.SCALE(SECOND_OP_TOKEN);
 HELP_TARGET = DIV_TARGET*(10**SCALE_ADD);
 MUL_TARGET = HELP_TARGET;
 DIV_TARGET = HELP_TARGET;
0END DIVIDE_OPERATION;
  /********************  STREAMLINING  ***************************/
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE PROCESSES A FORMAT STATEMENT          */
 /*******************************************************************/
0DO_FORMAT: PROCEDURE;
0/*******************************************************************/
 /*  A FORMAT STATEMENT HAS THE FOLLOWING SYNTAX:                   */
 /*      IDENTIFIER1 = FORMAT(IDENTIFIER2,PRECISION,SCALE);         */
 /*                                                                 */
 /*  PROCESSING OF THE FORMAT STATEMENT:                            */
 /*  1. DO AN ASSIGNMENT IDENTIFIER1 = IDENTIFIER2;                 */
 /*  2. CHANGE PRECISION AND SCALE IN THE USER_VAR_TABLE            */
 /*******************************************************************/
0TOKENS_IN_STATEMENT = 4;
0/*******************************************************************/
 /*  HERE WE ANALYSE THE FORMAT STATEMENT IN THE RULES:             */
 /*  WE LOOK FOR PARENTHESIS, COMMAS AND THE SEMICOLON AND          */
 /*  DECIDE WHETHER THE SYNTAX IS CORRECT...                        */
 /*******************************************************************/
0FIRST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),'(');
 FIRST_COMMA = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),',');
 SECOND_COMMA=INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),FIRST_COMMA+1,31),
              ',');
 LAST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),')');
 NEXT_SEMICOLON = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),';');
 IF ((FIRST_PARENTHESIS=0) !
    (LAST_PARENTHESIS=0) !
    (FIRST_COMMA=0) !
    (SECOND_COMMA=FIRST_COMMA) !
    (NEXT_SEMICOLON=0)) THEN DO;
        /*******************************************************/
        /* ----------------     E R R O R     ---------------- */
        /* MSGCODE: QCHI750                                    */
        /* MESSAGE: FORMAT STATEMENT WITH INVALID SYNTAX       */
        /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
        /* EXPLANATION: THE INTERPRETER FOUND A 'FORMAT'       */
        /*              STATEMENT WHICH WAS HAS AN INVALID     */
        /*              SYNTAX.                                */
        /* SEVERITY: 8                                         */
        /* PROCEDURE: DO_FORMAT                                */
        /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
        /*              SYNTAX IN THE FORMAT STATEMENT         */
        /*              (E.G. PARENTHESIS DO NOT MATCH,        */
        /*              NOT ENOUGH COMMAS, MISSING             */
        /*              SEMICOLONS)                            */
        /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
        /*                FURTHER PROCESSING                   */
        /* EXAMPLES: FORMAT)BLA.VLRXG,4,2);                    */
        /*           FORMAT(BLA.VLRXG,4,2)                     */
        /*           FORMAT(BLA.VLRXG,4 2)                     */
        /*           FORMAT(BLA.VLRXG,4,2;                     */
        /*                                                     */
        /*******************************************************/
    LINECHAR = RULEARRAY.LINENUMBER(I);
    IF SP.RUN_MODE = 'M' THEN DO;
       INTMSG ('750',SUBSTR(LINECHAR,7,3)
                     !! ',' !! SP.RULE_NAME);
    END;
    ELSE DO;
       QCHNOT(950);
       SP.EOP_FROM_RULE = '1'B;
       SP.ROLB_REQU     = '1'B;
       GOTO ABEND;
    END;
 END;
 ELSE DO;
0   /****************************************************************/
    /*  HERE WE TAKE THE PRECISION AND SCALE OUT OF THE FORMAT      */
    /*  FUNCTIONS PARAMETERS AS SPECIFIED IN THE RULE...            */
    /****************************************************************/
0   FORMAT_PRECISION = SUBSTR(RULEARRAY.CONTENT(I+2),
                       FIRST_COMMA+1,SECOND_COMMA-1);
    FORMAT_SCALE     = SUBSTR(RULEARRAY.CONTENT(I+2),
                       SECOND_COMMA+FIRST_COMMA+1,
                       LAST_PARENTHESIS-SECOND_COMMA-
                       FIRST_COMMA-1);
    VARIABLE_END_POSITION = VERIFY(SUBSTR(RULEARRAY.CONTENT(I+2),1,
          MAX_VARIABLENAME_LENGTH),ALPHANUMERIC);
0   /****************************************************************/
    /*  IF THERE IS A POINT IN THE VARIABLE, WE HAVE TO HANDLE      */
    /*  A DATABASE VARIABLE, OTHERWISE IT'S A USERVARIABLE...       */
    /****************************************************************/
0   POINTPOSITION=INDEX(RULEARRAY.CONTENT(I+2),'.');
    IF POINTPOSITION>0
       THEN RULEARRAY.DB_VARIABLE(I+2) = '1'B;
       ELSE RULEARRAY.USER_VARIABLE(I+2) = '1'B;
    RULEARRAY.CONTENT(I+2)=SUBSTR(RULEARRAY.CONTENT(I+2),8,
               FIRST_COMMA-FIRST_PARENTHESIS-1);
    IF ((RULEARRAY.DB_VARIABLE(I)='1'B) !
       (RULEARRAY.USER_VARIABLE(I)='1'B)) THEN
       DO;
0     /***************************************************************/
      /*  IN ANY CASE, WE ASSIGN THE VALUE AND SET THE NEW FORMAT    */
      /*  OF THE USERVARIABLE AS SPECIFIED IN THE RULE STATEMENT...  */
      /***************************************************************/
0      ASSIGNED_VARIABLE_NAME=RULEARRAY.CONTENT(I);
       CALL CALCULATE_ASSIGNMENT;
       CALL ASSIGN_CALCULATED_VALUE;
       USER_VARS.FORMAT.APPLY(USV_COUNT) = '1'B;
       USER_VARS.FORMAT.PRECISION(USV_COUNT)=FORMAT_PRECISION;
       USER_VARS.FORMAT.SCALE(USV_COUNT)=FORMAT_SCALE;
       END;
    ELSE DO;
          /*******************************************************/
          /* ----------------     E R R O R     ---------------- */
          /* MSGCODE: QCHI751                                    */
          /* MESSAGE: IDENTIFIER IN FORMAT STATEMENT WAS NEITHER */
          /*          A USER-VARIABLE NOR A DB_VARIABLE          */
          /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
          /* EXPLANATION: THE INTERPRETER FOUND A FORMAT-STMNT   */
          /*              WHERE THE IDENTIFIER WAS               */
          /*              NEITHER A DB-VARIABLE NOR              */
          /*              A USER-VARIABLE (E.G. A CONSTANT)      */
          /* SEVERITY: 8                                         */
          /* PROCEDURE: DO_FORMAT                                */
          /* USER RESPONSE: CHANGE THE RULES AND CORRECT THE     */
          /*                STATEMENT IN ERROR                   */
          /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
          /*                TRYING TO CORRECT THE ERROR          */
          /* EXAMPLE: JIM = FORMAT(23,4,2);                      */
          /*                                                     */
          /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('751',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(951);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
       END;
    END;
0END DO_FORMAT;
1DO_ZERO: PROCEDURE;
 TOKENS_IN_STATEMENT = 4;
 /*******************************************************************/
 /*  A ZERO FUNCTION    HAS THE FOLLOWING SYNTAX:                   */
 /*      IDENTIFIER1 = ZERO (IDENTIFIER2);                          */
 /*                                                                 */
 /*  PROCESSING OF THE ZERO STATEMENT:                              */
 /*  1. DO AN ASSIGNMENT IDENTIFIER1 = IDENTIFIER2;                 */
 /*  2. SET IDENTIFIER1 TO BLANK IF IDENTIFIER2 IS ZERO             */
 /*******************************************************************/
 /*  THE CODE ITSELF IS RATHER LIKE THE PREVIOUS FUNCTION...        */
 /*******************************************************************/
0FIRST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),'(');
 LAST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),')');
 NEXT_SEMICOLON = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),';');
 IF ((FIRST_PARENTHESIS=0) !
    (LAST_PARENTHESIS=0) !
    (NEXT_SEMICOLON=0)) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI767                                    */
             /* MESSAGE: ZERO FUNCTION    WITH INVALID SYNTAX       */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A 'ZERO'         */
             /*              FUNCTION WHICH HAD AN INVALID          */
             /*              SYNTAX.                                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_ZERO                                  */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              SYNTAX IN THE ZERO FUNCTION            */
             /*              (E.G. PARENTHESIS DO NOT MATCH,        */
             /*              MISSING SEMICOLON)                     */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES: VAR1 = ZERO)VAR2);                        */
             /*           VAR1 = ZERO(VAR2(;                        */
             /*           VAR1 = ZERO(VAR2;                         */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('767',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(967);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
    END;
 ELSE DO;
    VARIABLE_END_POSITION = VERIFY(SUBSTR(RULEARRAY.CONTENT(I+2),1,
          MAX_VARIABLENAME_LENGTH),ALPHANUMERIC);
    POINTPOSITION=INDEX(RULEARRAY.CONTENT(I+2),'.');
    IF POINTPOSITION>0
       THEN RULEARRAY.DB_VARIABLE(I+2) = '1'B;
       ELSE RULEARRAY.USER_VARIABLE(I+2) = '1'B;
    RULEARRAY.CONTENT(I+2)=SUBSTR(RULEARRAY.CONTENT(I+2),6,
          LAST_PARENTHESIS-6);
    IF ((RULEARRAY.DB_VARIABLE(I)='1'B) !
       (RULEARRAY.USER_VARIABLE(I)='1'B)) THEN
       DO;
       ASSIGNED_VARIABLE_NAME=RULEARRAY.CONTENT(I);
       CALL CALCULATE_ASSIGNMENT;
       TYPE_CONVERSION = '1'B;
       CALL ASSIGN_CALCULATED_VALUE;
       TYPE_CONVERSION = '0'B;
       IF SFARRAY.CALCULATION_FIELD.DEC_FIELD(1) = 0 THEN DO;
          USER_VARS.TYPE.DEC_FIXED(USV_COUNT) = '0'B;
          USER_VARS.TYPE.CHARACTER(USV_COUNT) = '1'B;
          USER_VARS.CONTENT.DEC_FIXED(USV_COUNT) = 0;
          USER_VARS.CONTENT.CHARACTER(USV_COUNT) = ' ';
          END;
       USER_VARS.FORMAT.APPLY(USV_COUNT) = '0'B;
       USER_VARS.FORMAT.PRECISION(USV_COUNT)=0;
       USER_VARS.FORMAT.SCALE(USV_COUNT)=0;
       USER_VARS.LENGTH.PRECISION(USV_COUNT)=1;
       USER_VARS.LENGTH.SCALE(USV_COUNT)=0;
       END;
    ELSE DO;
          /*******************************************************/
          /* ----------------     E R R O R     ---------------- */
          /* MSGCODE: QCHI768                                    */
          /* MESSAGE: INVALID IDENTIFIER IN ZERO (LINE XXXXX,    */
          /*          RULE XXXX)                                 */
          /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
          /* EXPLANATION: THE INTERPRETER FOUND A ZERO-FUNCTION  */
          /*              WHERE THE IDENTIFIER WAS               */
          /*              NEITHER A DB-VARIABLE NOR              */
          /*              A USER-VARIABLE (E.G. A CONSTANT)      */
          /* SEVERITY: 8                                         */
          /* PROCEDURE: DO_ZERO                                  */
          /* USER RESPONSE: CHANGE THE RULES AND CORRECT THE     */
          /*                STATEMENT IN ERROR                   */
          /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
          /*                TRYING TO CORRECT THE ERROR          */
          /* EXAMPLE: VAR = ZERO(23);                            */
          /*                                                     */
          /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('768',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(968);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
       END;
    END;
0END DO_ZERO;
1DO_CHARACTER: PROCEDURE;
 TOKENS_IN_STATEMENT = 4;
 /*******************************************************************/
 /*  A CHARACTER FUNCTION HAS THE FOLLOWING SYNTAX:                 */
 /*      USERVAR   =   CHARACTER (VARIABLE);                        */
 /*                  OR                                             */
 /*      USERVAR   =   CHARACTER (VARIABLE,N);                      */
 /*                                                                 */
 /*  PROCESSING OF THE CHARACTER STATEMENT:                         */
 /*  1. DO AN ASSIGNMENT USERVAR = VARIABLE;                        */
 /*  2. CHANGE THE TYPE OF USERVARIABLE TO CHAR                     */
 /*******************************************************************/
0FIRST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),'(');
 LAST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),')');
 NEXT_SEMICOLON = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),';');
 IF ((FIRST_PARENTHESIS=0) !
    (LAST_PARENTHESIS=0) !
    (NEXT_SEMICOLON=0)) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI769                                    */
             /* MESSAGE: CHARACTER FUNCT. WITH INVALID SYNTAX       */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A 'CHARACTER'    */
             /*              FUNCTION WHICH HAD AN INVALID          */
             /*              SYNTAX.                                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_CHARACTER                             */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              SYNTAX IN THE CHARACTER FUNCTION       */
             /*              (E.G. PARENTHESIS DO NOT MATCH,        */
             /*              MISSING SEMICOLON)                     */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES: VAR1 = CHARACTER)VAR2);                   */
             /*           VAR1 = CHARACTER(VAR2(;                   */
             /*           VAR1 = CHARACTER(VAR2;                    */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('769',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(969);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
    END;
 ELSE DO;
    VARIABLE_END_POSITION = VERIFY(SUBSTR(RULEARRAY.CONTENT(I+2),1,
          MAX_VARIABLENAME_LENGTH),ALPHANUMERIC);
    POINTPOSITION=INDEX(RULEARRAY.CONTENT(I+2),'.');
    FIRST_COMMA = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,25),',');
    IF (FIRST_COMMA > 0) THEN DO;
       COMMA_VERIFY = VERIFY(SUBSTR(RULEARRAY.CONTENT(I+2),
       FIRST_COMMA+1,1),DIGITS);
       IF (COMMA_VERIFY = 0) THEN DO;
          CHARACTER_LENGTH =
          SUBSTR(RULEARRAY.CONTENT(I+2),FIRST_COMMA+1,1);
          IF ((CHARACTER_LENGTH < 1) ! (CHARACTER_LENGTH > 5))
             THEN CHARACTER_LENGTH = -1;
          END;
       ELSE CHARACTER_LENGTH = -1;
       END;
    ELSE CHARACTER_LENGTH = -1;
    IF POINTPOSITION>0
       THEN RULEARRAY.DB_VARIABLE(I+2) = '1'B;
       ELSE RULEARRAY.USER_VARIABLE(I+2) = '1'B;
    IF (FIRST_COMMA = 0) THEN
       RULEARRAY.CONTENT(I+2)=SUBSTR(RULEARRAY.CONTENT(I+2),11,
       LAST_PARENTHESIS-11);
    ELSE
       RULEARRAY.CONTENT(I+2)=SUBSTR(RULEARRAY.CONTENT(I+2),11,
       FIRST_COMMA-11);
    IF ((RULEARRAY.DB_VARIABLE(I)='1'B) !
       (RULEARRAY.USER_VARIABLE(I)='1'B)) THEN
       DO;
       ASSIGNED_VARIABLE_NAME=RULEARRAY.CONTENT(I);
       CALL CALCULATE_ASSIGNMENT;
    /* CALL ASSIGN_CALCULATED_VALUE;  */
0      DO USV_COUNT = 1 TO USV_MAX;
          IF USER_VARS.NAME(USV_COUNT) = RULEARRAY.CONTENT(I)
             THEN LEAVE;
       END;
       IF USV_COUNT > USV_MAX THEN DO;
          USV_MAX = USV_MAX + 1;
          USER_VARS(USV_MAX)='';
          USER_VARS.NAME(USV_COUNT) = RULEARRAY.CONTENT(I);
       END;
       USER_VARS.TYPE.DEC_FIXED(USV_COUNT) = '0'B;
       USER_VARS.TYPE.CHARACTER(USV_COUNT) = '1'B;
       USER_VARS.CONTENT.DEC_FIXED(USV_COUNT) = 0;
       USER_VARS.CONTENT.CHARACTER(USV_COUNT) =
                 SFARRAY.CALCULATION_FIELD.DEC_FIELD(1);
       CHAR_STRING_LENGTH_V =
                   VERIFY(USER_VARS.CONTENT.CHARACTER(USV_COUNT),' ');
       CHAR_TEMP_CONTENT = SUBSTR(USER_VARS.CONTENT.CHARACTER(USV_COUNT)
                                 ,CHAR_STRING_LENGTH_V);
       CHAR_STRING_LENGTH_I = INDEX(CHAR_TEMP_CONTENT,' ');
       USER_VARS.LENGTH.PRECISION(USV_COUNT)=CHAR_STRING_LENGTH_V +
                                             CHAR_STRING_LENGTH_I - 2;
       USER_VARS.FORMAT.APPLY(USV_COUNT) = '0'B;
       USER_VARS.FORMAT.PRECISION(USV_COUNT)=0;
       USER_VARS.FORMAT.SCALE(USV_COUNT)=0;
       USER_VARS.LENGTH.SCALE(USV_COUNT)=0;
       END;
    ELSE DO;
          /*******************************************************/
          /* ----------------     E R R O R     ---------------- */
          /* MSGCODE: QCHI770                                    */
          /* MESSAGE: INVALID IDENTIFIER IN CHARACTER FUNCTION   */
          /*          (LINE XXXX, RULE XXXX)                     */
          /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
          /* EXPLANATION: THE INTERPRETER FOUND A CHARACTER      */
          /*              FUNCTION WHERE THE IDENTIFIER WAS      */
          /*              NEITHER A DB-VARIABLE NOR              */
          /*              A USER-VARIABLE (E.G. A CONSTANT)      */
          /* SEVERITY: 8                                         */
          /* PROCEDURE: DO_CHARACTER                             */
          /* USER RESPONSE: CHANGE THE RULES AND CORRECT THE     */
          /*                STATEMENT IN ERROR                   */
          /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
          /*                TRYING TO CORRECT THE ERROR          */
          /* EXAMPLE: VAR = CHARACTER(23);                       */
          /*                                                     */
          /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('770',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(970);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
       END;
    END;
0END DO_CHARACTER;
1DO_LCHARACTER: PROCEDURE;
 TOKENS_IN_STATEMENT = 4;
 /*******************************************************************/
 /*  A CHARACTER FUNCTION HAS THE FOLLOWING SYNTAX:                 */
 /*      USERVAR   =   LCHARACTER (VARIABLE);                       */
 /*                  OR                                             */
 /*      USERVAR   =   LCHARACTER (VARIABLE,N);                     */
 /*                                                                 */
 /*  PROCESSING OF THE LCHARACTER STATEMENT:                        */
 /*  1. DO AN ASSIGNMENT USERVAR = VARIABLE;                        */
 /*  2. CHANGE THE TYPE OF USERVARIABLE TO CHAR                     */
 /*  3. LEFT-ADJUST THE RESULT                                      */
 /*******************************************************************/
0FIRST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),'(');
 LAST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),')');
 NEXT_SEMICOLON = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),';');
 IF ((FIRST_PARENTHESIS=0) !
    (LAST_PARENTHESIS=0) !
    (NEXT_SEMICOLON=0)) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI776                                    */
             /* MESSAGE: LCHARACTER FUNCT. WITH INVALID SYNTAX      */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A 'LCHARACTER'   */
             /*              FUNCTION WHICH HAD AN INVALID          */
             /*              SYNTAX.                                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_LCHARACTER                            */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              SYNTAX IN THE LCHARACTER FUNCTION      */
             /*              (E.G. PARENTHESIS DO NOT MATCH,        */
             /*              MISSING SEMICOLON)                     */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES: VAR1 = LCHARACTER)VAR2);                  */
             /*           VAR1 = LCHARACTER(VAR2(;                  */
             /*           VAR1 = LCHARACTER(VAR2;                   */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('776',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(976);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
    END;
 ELSE DO;
    VARIABLE_END_POSITION = VERIFY(SUBSTR(RULEARRAY.CONTENT(I+2),1,
          MAX_VARIABLENAME_LENGTH),ALPHANUMERIC);
    POINTPOSITION=INDEX(RULEARRAY.CONTENT(I+2),'.');
    FIRST_COMMA = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,25),',');
    IF (FIRST_COMMA > 0) THEN DO;
       COMMA_VERIFY = VERIFY(SUBSTR(RULEARRAY.CONTENT(I+2),
       FIRST_COMMA+1,1),DIGITS);
       IF (COMMA_VERIFY = 0) THEN DO;
          CHARACTER_LENGTH =
          SUBSTR(RULEARRAY.CONTENT(I+2),FIRST_COMMA+1,1);
          IF ((CHARACTER_LENGTH < 1) ! (CHARACTER_LENGTH > 5))
             THEN CHARACTER_LENGTH = -1;
          END;
       ELSE CHARACTER_LENGTH = -1;
       END;
    ELSE CHARACTER_LENGTH = -1;
    IF POINTPOSITION>0
       THEN RULEARRAY.DB_VARIABLE(I+2) = '1'B;
       ELSE RULEARRAY.USER_VARIABLE(I+2) = '1'B;
    IF (FIRST_COMMA = 0) THEN
       RULEARRAY.CONTENT(I+2)=SUBSTR(RULEARRAY.CONTENT(I+2),12,
       LAST_PARENTHESIS-12);
    ELSE
       RULEARRAY.CONTENT(I+2)=SUBSTR(RULEARRAY.CONTENT(I+2),12,
       FIRST_COMMA-12);
    IF ((RULEARRAY.DB_VARIABLE(I)='1'B) !
       (RULEARRAY.USER_VARIABLE(I)='1'B)) THEN
       DO;
       ASSIGNED_VARIABLE_NAME=RULEARRAY.CONTENT(I);
       CALL CALCULATE_ASSIGNMENT;
   /*  CALL ASSIGN_CALCULATED_VALUE;         */
0      DO USV_COUNT = 1 TO USV_MAX;
          IF USER_VARS.NAME(USV_COUNT) = RULEARRAY.CONTENT(I)
             THEN LEAVE;
       END;
       IF USV_COUNT > USV_MAX THEN DO;
          USV_MAX = USV_MAX + 1;
          USER_VARS(USV_MAX)='';
          USER_VARS.NAME(USV_COUNT) = RULEARRAY.CONTENT(I);
       END;
       USER_VARS.TYPE.DEC_FIXED(USV_COUNT) = '0'B;
       USER_VARS.TYPE.CHARACTER(USV_COUNT) = '1'B;
       USER_VARS.CONTENT.DEC_FIXED(USV_COUNT) = 0;
       NON_BLANK_POSITION=
                 VERIFY(SFARRAY.CALCULATION_FIELD.DEC_FIELD(1),' ');
       USER_VARS.CONTENT.CHARACTER(USV_COUNT) =
                 SUBSTR(SFARRAY.CALCULATION_FIELD.DEC_FIELD(1),
                        NON_BLANK_POSITION);
       LCHAR_STRING_LENGTH =
            INDEX(USER_VARS.CONTENT.CHARACTER(USV_COUNT),' ');
       USER_VARS.FORMAT.APPLY(USV_COUNT) = '0'B;
       USER_VARS.FORMAT.PRECISION(USV_COUNT)=0;
       USER_VARS.FORMAT.SCALE(USV_COUNT)=0;
       USER_VARS.LENGTH.PRECISION(USV_COUNT)=LCHAR_STRING_LENGTH - 1;
       USER_VARS.LENGTH.SCALE(USV_COUNT)=0;
       END;
    ELSE DO;
          /*******************************************************/
          /* ----------------     E R R O R     ---------------- */
          /* MSGCODE: QCHI777                                    */
          /* MESSAGE: INVALID IDENTIFIER IN LCHARACTER FUNCTION  */
          /*          (LINE XXXX, RULE XXXX)                     */
          /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
          /* EXPLANATION: THE INTERPRETER FOUND A CHARACTER      */
          /*              FUNCTION WHERE THE IDENTIFIER WAS      */
          /*              NEITHER A DB-VARIABLE NOR              */
          /*              A USER-VARIABLE (E.G. A CONSTANT)      */
          /* SEVERITY: 8                                         */
          /* PROCEDURE: DO_LCHARACTER                            */
          /* USER RESPONSE: CHANGE THE RULES AND CORRECT THE     */
          /*                STATEMENT IN ERROR                   */
          /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
          /*                TRYING TO CORRECT THE ERROR          */
          /* EXAMPLE: VAR = CHARACTER(23);                       */
          /*                                                     */
          /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('777',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(977);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
       END;
    END;
0END DO_LCHARACTER;
1DO_DECIMAL: PROCEDURE;
 TOKENS_IN_STATEMENT = 4;
 /*******************************************************************/
 /*  A DECIMAL   FUNCTION HAS THE FOLLOWING SYNTAX:                 */
 /*      USERVAR   =   DECIMAL (VARIABLE);                          */
 /*                                                                 */
 /*  PROCESSING OF THE CHARACTER STATEMENT:                         */
 /*  1. DO AN ASSIGNMENT USERVAR = VARIABLE;                        */
 /*  2. CHANGE THE TYPE OF USERVARIABLE TO DECIMAL                  */
 /*******************************************************************/
0FIRST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),'(');
 LAST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),')');
 NEXT_SEMICOLON = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),';');
 IF ((FIRST_PARENTHESIS=0) !
    (LAST_PARENTHESIS=0) !
    (NEXT_SEMICOLON=0)) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI772                                    */
             /* MESSAGE: DECIMAL   FUNCT. WITH INVALID SYNTAX       */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A 'DECIMAL'      */
             /*              FUNCTION WHICH HAD AN INVALID          */
             /*              SYNTAX.                                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_DECIMAL                               */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              SYNTAX IN THE DECIMAL   FUNCTION       */
             /*              (E.G. PARENTHESIS DO NOT MATCH,        */
             /*              MISSING SEMICOLON)                     */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES: VAR1  = DECIMAL )VAR2);                   */
             /*           VAR1  = DECIMAL (VAR2(;                   */
             /*           VAR1  = DECIMAL (VAR2;                    */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('772',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(972);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
    END;
 ELSE DO;
    VARIABLE_END_POSITION = VERIFY(SUBSTR(RULEARRAY.CONTENT(I+2),1,
          MAX_VARIABLENAME_LENGTH),ALPHANUMERIC);
    POINTPOSITION=INDEX(RULEARRAY.CONTENT(I+2),'.');
    IF POINTPOSITION>0
       THEN RULEARRAY.DB_VARIABLE(I+2) = '1'B;
       ELSE RULEARRAY.USER_VARIABLE(I+2) = '1'B;
    RULEARRAY.CONTENT(I+2)=SUBSTR(RULEARRAY.CONTENT(I+2),9,
          LAST_PARENTHESIS-9);
    IF ((RULEARRAY.DB_VARIABLE(I)='1'B) !
       (RULEARRAY.USER_VARIABLE(I)='1'B)) THEN
       DO;
       ASSIGNED_VARIABLE_NAME=RULEARRAY.CONTENT(I);
       CALL CALCULATE_ASSIGNMENT;
   /*  CALL ASSIGN_CALCULATED_VALUE;   */
       IF (VERIFY(SFARRAY.CALCULATION_FIELD.CHAR_FIELD(1),
                  DEC_NUMERIC)>0)
          THEN DO;
          /*******************************************************/
          /* ----------------     E R R O R     ---------------- */
          /* MSGCODE: QCHI774                                    */
          /* MESSAGE: VARIABLE HAS NON-NUMERIC CONTENT IN DECIMAL*/
          /*          (LINE XXXX, RULE XXXX)                     */
          /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
          /* EXPLANATION: THE INTERPRETER FOUND A DECIMAL        */
          /*              FUNCTION WHERE THE VARIABLE SPECIFIED  */
          /*              HAD A NON-NUMERIC CONTENT              */
          /* SEVERITY: 8                                         */
          /* PROCEDURE: DO_DECIMAL                               */
          /* USER RESPONSE: CHANGE THE RULES AND CORRECT THE     */
          /*                STATEMENT IN ERROR (E.G. BY DELETING */
          /*                THE DECIMAL FUNCTION                 */
          /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
          /*                TRYING TO CORRECT THE ERROR          */
          /* EXAMPLE: VAR1 = 'A23';                              */
          /*          VAR2 = DECIMAL(VAR1);                      */
          /*                                                     */
          /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('774',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(974);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
          END;
       ELSE DO;
0         DO USV_COUNT = 1 TO USV_MAX;
             IF USER_VARS.NAME(USV_COUNT) = RULEARRAY.CONTENT(I)
                THEN LEAVE;
          END;
          IF USV_COUNT > USV_MAX THEN DO;
             USER_VARS(USV_COUNT)='';
             USV_MAX = USV_MAX + 1;
             USER_VARS(USV_MAX)='';
          END;
          USER_VARS.TYPE.DEC_FIXED(USV_COUNT) = '1'B;
          USER_VARS.TYPE.CHARACTER(USV_COUNT) = '0'B;
          USER_VARS.CONTENT.CHARACTER(USV_COUNT) = '';
          IF (SFARRAY.VAR_TYPE.CHARACTER(1) = '1'B) THEN DO;
             IF (VERIFY(SFARRAY.CALCULATION_FIELD.CHAR_FIELD(1),
                ' ') > 0) THEN DO;
                PUT SKIP LIST('NOW I CONVERT FROM CHAR TO DEC');
                USER_VARS.CONTENT.DEC_FIXED(USV_COUNT) =
                          SFARRAY.CALCULATION_FIELD.CHAR_FIELD(1);
                END;
             END;
          USER_VARS.FORMAT.APPLY(USV_COUNT) = '0'B;
          USER_VARS.FORMAT.PRECISION(USV_COUNT)=0;
          USER_VARS.FORMAT.SCALE(USV_COUNT)=0;
          USER_VARS.LENGTH.PRECISION(USV_COUNT)=15;
          USER_VARS.LENGTH.SCALE(USV_COUNT)=3;
          END;
       END;
    ELSE DO;
          /*******************************************************/
          /* ----------------     E R R O R     ---------------- */
          /* MSGCODE: QCHI773                                    */
          /* MESSAGE: INVALID IDENTIFIER IN DECIMAL   FUNCTION   */
          /*          (LINE XXXX, RULE XXXX)                     */
          /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
          /* EXPLANATION: THE INTERPRETER FOUND A DECIMAL        */
          /*              FUNCTION WHERE THE IDENTIFIER WAS      */
          /*              NEITHER A DB-VARIABLE NOR              */
          /*              A USER-VARIABLE (E.G. A CONSTANT)      */
          /* SEVERITY: 8                                         */
          /* PROCEDURE: DO_DECIMAL                               */
          /* USER RESPONSE: CHANGE THE RULES AND CORRECT THE     */
          /*                STATEMENT IN ERROR                   */
          /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
          /*                TRYING TO CORRECT THE ERROR          */
          /* EXAMPLE: VAR = DECIMAL('23');                       */
          /*                                                     */
          /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('773',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(973);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
       END;
    END;
0END DO_DECIMAL;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE PROCESSES A SUBSTRING STATEMENT       */
 /*******************************************************************/
0DO_SUBSTRING: PROCEDURE;
 TOKENS_IN_STATEMENT = 4;
 /*******************************************************************/
 /*                                                                 */
 /*  A SUBSTRING STATEMENT HAS THE FOLLOWING SYNTAX:                */
 /*      USERVARIABLE = SUBSTRING(IDENTIFIER2,STARTPOS,LENGTH);     */
 /*                                                                 */
 /*******************************************************************/
0FIRST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),'(');
 FIRST_COMMA = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),',');
 SECOND_COMMA=INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),FIRST_COMMA+1,31),
              ',');
 LAST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),')');
 NEXT_SEMICOLON = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),';');
 IF ((FIRST_PARENTHESIS=0) !
    (LAST_PARENTHESIS=0) !
    (FIRST_COMMA=0) !
    (SECOND_COMMA=FIRST_COMMA) !
    (NEXT_SEMICOLON=0)) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI754                                    */
             /* MESSAGE: SUBSTRING-FUNCTION HAS INVALID SYNTAX      */
             /*          (LINE XXXX)                                */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A 'SUBSTRING'    */
             /*              FUNCTION WHICH HAS AN INVALID          */
             /*              SYNTAX.                                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_SUBSTRING                             */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              SYNTAX IN THE SUBSTRING FUNCTION       */
             /*              (E.G. PARENTHESIS DO NOT MATCH,        */
             /*              NOT ENOUGH COMMAS, MISSING             */
             /*              SEMICOLONS)                            */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES: SUBSTRING)BLA.VLRXG,4,2);                 */
             /*           SUBSTRING(BLA.VLRXG,4,2)                  */
             /*           SUBSTRING(BLA.VLRXG,4 2)                  */
             /*           SUBSTRING(BLA.VLRXG,4,2;                  */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('754',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(954);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
    END;
 ELSE DO;
    SUBSTRING_STARTPOS = SUBSTR(RULEARRAY.CONTENT(I+2),
                         FIRST_COMMA+1,SECOND_COMMA-1);
    SUBSTRING_LENGTH = SUBSTR(RULEARRAY.CONTENT(I+2),
                       SECOND_COMMA+FIRST_COMMA+1,
                       LAST_PARENTHESIS-SECOND_COMMA-
                       FIRST_COMMA-1);
    VARIABLE_END_POSITION = VERIFY(SUBSTR(RULEARRAY.CONTENT(I+2),1,
          MAX_VARIABLENAME_LENGTH),ALPHANUMERIC);
    POINTPOSITION=INDEX(RULEARRAY.CONTENT(I+2),'.');
    IF POINTPOSITION>0
       THEN RULEARRAY.DB_VARIABLE(I+2) = '1'B;
       ELSE RULEARRAY.USER_VARIABLE(I+2) = '1'B;
    RULEARRAY.CONTENT(I+2)=SUBSTR(RULEARRAY.CONTENT(I+2),11,
               FIRST_COMMA-FIRST_PARENTHESIS-1);
    IF ((RULEARRAY.DB_VARIABLE(I)='1'B) !
       (RULEARRAY.USER_VARIABLE(I)='1'B)) THEN
       DO;
       ASSIGNED_VARIABLE_NAME=RULEARRAY.CONTENT(I);
       CALL CALCULATE_ASSIGNMENT;
       CALL ASSIGN_CALCULATED_VALUE;
       IF (USER_VARS.TYPE.CHARACTER(USV_COUNT) ^= '1'B)
          THEN DO;
          /*******************************************************/
          /* ----------------     E R R O R     ---------------- */
          /* MSGCODE: QCHI771                                    */
          /* MESSAGE: SUBSTRING APPLIED TO NON-CHARACTER VARIABLE*/
          /*          (LINE XXX, RULE XXXXXXX)                   */
          /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
          /* EXPLANATION: THE INTERPRETER FOUND A SUBSTR-STMNT   */
          /*              WHERE THE IDENTIFIER WAS               */
          /*              NOT A CHARACTER VARIABLE               */
          /* SEVERITY: 8                                         */
          /* PROCEDURE: DO_SUBSTRING                             */
          /* USER RESPONSE: CHANGE THE RULES AND CORRECT THE     */
          /*                STATEMENT IN ERROR                   */
          /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
          /*                TRYING TO CORRECT THE ERROR          */
          /* EXAMPLE: JIM = 23;                                  */
          /*          JIM = SUBSTRING(JIM,1,2);                  */
          /*                                                     */
          /*******************************************************/
          LINECHAR = RULEARRAY.LINENUMBER(I);
          IF SP.RUN_MODE = 'M' THEN DO;
             INTMSG ('771',SUBSTR(LINECHAR,7,3)
                        !! ',' !! SP.RULE_NAME);
          END;
          ELSE DO;
             QCHNOT(971);
             SP.EOP_FROM_RULE = '1'B;
             SP.ROLB_REQU = '1'B;
             GOTO ABEND;
          END;
          END;
       ELSE DO;
          USER_VARS.FORMAT.APPLY(USV_COUNT) = '0'B;
          USER_VARS.LENGTH.PRECISION(USV_COUNT)=SUBSTRING_LENGTH;
          USER_VARS.LENGTH.SCALE(USV_COUNT)=0;
          USER_VARS.CONTENT.CHARACTER(USV_COUNT) =
              SUBSTR(USER_VARS.CONTENT.CHARACTER(USV_COUNT),
              SUBSTRING_STARTPOS,SUBSTRING_LENGTH);
          I = I - 1;
          END;
       END;
    ELSE DO;
          /*******************************************************/
          /* ----------------     E R R O R     ---------------- */
          /* MSGCODE: QCHI755                                    */
          /* MESSAGE: INVALID IDENTIFIER XXXXXXX IN SUBSTRING-   */
          /*          STATEMENT (LINE XXXXXXX)                   */
          /* MESSAGECLASS: INTERPRETATION ERROR MESSAGE          */
          /* EXPLANATION: THE INTERPRETER FOUND A SUBSTR-STMNT   */
          /*              WHERE THE IDENTIFIER WAS               */
          /*              NEITHER A DB-VARIABLE NOR              */
          /*              A USER-VARIABLE (E.G. A CONSTANT)      */
          /* SEVERITY: 8                                         */
          /* PROCEDURE: DO_SUBSTRING                             */
          /* USER RESPONSE: CHANGE THE RULES AND CORRECT THE     */
          /*                STATEMENT IN ERROR                   */
          /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
          /*                TRYING TO CORRECT THE ERROR          */
          /* EXAMPLE: JIM = SUBSTRING(23,4,2);                   */
          /*                                                     */
          /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('755',SUBSTR(RULEARRAY.CONTENT(I),1,8) !! ','
                           !! SUBSTR(LINECHAR,7,3)
                           !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(955);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
       END;
    END;
0END DO_SUBSTRING;

1/*===================================================================*/
 /*  NAME    : DO_DATE                                                */
 /*  FUNCTION: THIS PROCEDURE PROCESSES A DATE FUNCTION               */
 /*----------:--------------------------------------------------------*/
 /*          : A DATE FUNCTION HAS THE FOLLOWING SYNTAX:              */
 /*          :     USERVARIABLE = DATE(DATABASEVARIABLE,FORMAT);      */
 /*          :                                                        */
 /*          : WHERE                                                  */
 /*          :--------------------------------------------------------*/
 /*          : -DATABASEVARIABLE-                                     */
 /*          :      DATABASE FIELD DEFINED AS DECIMAL FIXED 6,0 OR    */
 /*          :                                CHAR 10                 */
 /*          :--------------------------------------------------------*/
 /*          : -FORMAT-                                               */
 /*          :      ANY STRING CONTAINING THE FOUR DOUBLE-CHARACTERS  */
 /*          :      CC, YY, MM, DD                                    */
 /*          :      WHICH MAY BE ENCLOSED IN QUOTES                   */
 /*          :                                                        */
 /*          : E.G. CCYYMMDD                                          */
 /*          :      YYMMDD                                            */
 /*          :      DDMMYYCC                                          */
 /*          :      DDMMYY                                            */
 /*          :      MMDDYYCC                                          */
 /*          :      DD/MM/YYCC                                        */
 /*          :      DD.MM.YYCC                                        */
 /*          :      THURSDAY, DD.MM.YYCC                              */
 /*===================================================================*/
 DO_DATE: PROCEDURE;

 DCL SECOND_APOSTROPHE BIN FIXED(31) INIT(0);
 DCL FIRST_APOSTROPHE  BIN FIXED(31) INIT(0);
 TOKENS_IN_STATEMENT = 4;

 FIRST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,65),'(');
 FIRST_COMMA       = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,65),',');
 LAST_PARENTHESIS  = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,65),')');
 NEXT_SEMICOLON    = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,65),';');
 FIRST_APOSTROPHE  = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,65),
                     APOSTROPHE);
 /*--- MAYBE =0
 SECOND_APOSTROPHE = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),
                     FIRST_APOSTROPHE+1,65),APOSTROPHE);
 ---*/
 SECOND_APOSTROPHE = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),
                     FIRST_APOSTROPHE+1   ),APOSTROPHE);


 IF (( FIRST_PARENTHESIS = 0 ) !
     ( LAST_PARENTHESIS  = 0 ) !
     ( FIRST_COMMA       = 0 ) !
     ( NEXT_SEMICOLON    = 0 ) ) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI756                                    */
             /* MESSAGE: DATE FUNCTION HAS INVALID SYNTAX (LINE XX) */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A 'DATE'         */
             /*              FUNCTION WHICH HAS AN INVALID          */
             /*              SYNTAX.                                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_DATE                                  */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              SYNTAX IN THE DATE      FUNCTION       */
             /*              (E.G. PARENTHESIS DO NOT MATCH,        */
             /*              TOO MANY COMMAS, MISSING               */
             /*              SEMICOLON)                             */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES: DATE)BLA.VLRXG,4,2);                      */
             /*           DATE(BLA.VLRXG,2)                         */
             /*           DATE(BLA.VLRXG,4 2)                       */
             /*           DATE(BLA.VLRXG,4,2;                       */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('756',SUBSTR(LINECHAR,7,3)
                             !! ',' !! SP.RULE_NAME);
                RETURN;
             END;
             ELSE DO;
                QCHNOT(956);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
 END;

   DATE_FORMAT = SUBSTR(RULEARRAY.CONTENT(I+2),
                      FIRST_COMMA+2,LAST_PARENTHESIS-2);

   DATE_FORMAT = SUBSTR(RULEARRAY.CONTENT(I+2),
                      FIRST_APOSTROPHE+1,
                      SECOND_APOSTROPHE-1);

 POINTPOSITION=INDEX(RULEARRAY.CONTENT(I+2),'.');
 IF POINTPOSITION=0 THEN DO;
          /*******************************************************/
          /* ----------------     E R R O R     ---------------- */
          /* MSGCODE: QCHI757                                    */
          /* MESSAGE: DATE FUNCTION APPLIED TO USERVARIABLE      */
          /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
          /* EXPLANATION: THE INTERPRETER FOUND A 'DATE'         */
          /*              FUNCTION WHICH HAS AN INVALID          */
          /*              SYNTAX.                                */
          /* SEVERITY: 8                                         */
          /* PROCEDURE: DO_DATE                                  */
          /* USER RESPONSE: CHECK FOR THE CORRECTNESS OF THE     */
          /*              DATE FUNCTION. IT APPEARS THAT YOU     */
          /*              TRIED TO REFORMAT A USERVARIABLE       */
          /*              WHICH IS NOT ALLOWED.                  */
          /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
          /*                FURTHER PROCESSING                   */
          /* EXAMPLES: DATE(BILDATE,YYMMDD);                     */
          /*                                                     */
          /*******************************************************/
          LINECHAR = RULEARRAY.LINENUMBER(I);
          IF SP.RUN_MODE = 'M' THEN DO;
             INTMSG ('757',SUBSTR(LINECHAR,7,3)
                        !! ',' !! SP.RULE_NAME);
             RETURN;
          END;
          ELSE DO;
             QCHNOT(957);
             SP.EOP_FROM_RULE = '1'B;
             SP.ROLB_REQU = '1'B;
             GOTO ABEND;
          END;
 END;
 RULEARRAY.DB_VARIABLE(I+2) = '1'B;
 RULEARRAY.CONTENT(I+2)=SUBSTR(RULEARRAY.CONTENT(I+2),6,
           FIRST_COMMA-FIRST_PARENTHESIS-1);
 ASSIGNED_VARIABLE_NAME=RULEARRAY.CONTENT(I);

 TYPE_CONVERSION = '1'B;
 CALL CALCULATE_ASSIGNMENT;
 CALL ASSIGN_CALCULATED_VALUE;
 TYPE_CONVERSION = '0'B;

 /*----------------------------------------------------------------*/
 /* NOW DO THE REFORMATTING WITH THE USER_VARIABLE                 */
 /*----------------------------------------------------------------*/
 DCL  CC_POS         BIN FIXED ( 15  )           ;
 DCL  YY_POS         BIN FIXED ( 15  )           ;
 DCL  MM_POS         BIN FIXED ( 15  )           ;
 DCL  DD_POS         BIN FIXED ( 15  )           ;

 IF SFARRAY.CHARACTER(1) THEN DO;
    DATE_HELP_FIELD  = SFARRAY.CALCULATION_FIELD.CHAR_FIELD(1);
 END;
 ELSE DO;
    DATE_HELP_FIELD  = SFARRAY.CALCULATION_FIELD.DEC_FIELD(1);
 END;

 DD_POS = INDEX(DATE_FORMAT,'DD');
 MM_POS = INDEX(DATE_FORMAT,'MM');
 YY_POS = INDEX(DATE_FORMAT,'YY');
 CC_POS = INDEX(DATE_FORMAT,'CC');

 DATE_FIELD = DATE_FORMAT;

 /*----------------------------------------------------------------*/
 /* ITS A DATE IN DB2 CHARACTER FORMAT 1993-12-21                  */
 /*----------------------------------------------------------------*/
 IF SFARRAY.CHARACTER(1) THEN DO;
    IF CC_POS ^= 0 THEN
              SUBSTR(DATE_FIELD,CC_POS,2)=SUBSTR(DATE_HELP_FIELD, 1, 2);

    IF YY_POS ^= 0 THEN
              SUBSTR(DATE_FIELD,YY_POS,2)=SUBSTR(DATE_HELP_FIELD, 3, 2);

    IF MM_POS ^= 0 THEN
              SUBSTR(DATE_FIELD,MM_POS,2)=SUBSTR(DATE_HELP_FIELD, 6, 2);

    IF DD_POS ^= 0 THEN
              SUBSTR(DATE_FIELD,DD_POS,2)=SUBSTR(DATE_HELP_FIELD, 9, 2);
 END;
 /*----------------------------------------------------------------*/
 /* ITS A DATE IN DEC FIXED 6 FORMAT 931231                        */
 /*----------------------------------------------------------------*/
 IF SFARRAY.DEC_FIXED(1) THEN DO;
    IF YY_POS ^= 0 THEN
              SUBSTR(DATE_FIELD,YY_POS,2)=SUBSTR(DATE_HELP_FIELD, 7, 2);

    IF MM_POS ^= 0 THEN
              SUBSTR(DATE_FIELD,MM_POS,2)=SUBSTR(DATE_HELP_FIELD, 9, 2);

    IF DD_POS ^= 0 THEN
              SUBSTR(DATE_FIELD,DD_POS,2)=SUBSTR(DATE_HELP_FIELD,11, 2);
 END;

 USER_VARS.TYPE.DEC_FIXED(USV_COUNT)    = '0'B;
 USER_VARS.TYPE.CHARACTER(USV_COUNT)    = '1'B;
 USER_VARS.CONTENT.CHARACTER(USV_COUNT) = DATE_FIELD;

 END DO_DATE;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE PROCESSES A CONCAT FUNCTION           */
 /*******************************************************************/
0DO_CONCAT: PROCEDURE;
 DCL FIRST_DIGITS  BIN FIXED(15) INIT(0);
 DCL SECOND_DIGITS BIN FIXED(15) INIT(0);
 TOKENS_IN_STATEMENT = 4;
 /*******************************************************************/
 /*                                                                 */
 /*  A CONCAT FUNCTION HAS THE FOLLOWING SYNTAX:                    */
 /*      USERVARIABLE = CONCAT(USERVARIABLE,USERVARIABLE);          */
 /*                                                                 */
 /*                                                                 */
 /*******************************************************************/
0FIRST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),'(');
 FIRST_COMMA = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),',');
 LAST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),')');
 NEXT_SEMICOLON = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),';');
 IF ((FIRST_PARENTHESIS=0) !
    (LAST_PARENTHESIS=0) !
    (FIRST_COMMA=0) !
    (NEXT_SEMICOLON=0)) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI761                                    */
             /* MESSAGE: CONCAT    FUNCTION WITH INVALID SYNTAX     */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A 'CONCAT'       */
             /*              FUNCTION WHICH HAS AN INVALID          */
             /*              SYNTAX.                                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_CONCAT                                */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              SYNTAX IN THE CONCAT    FUNCTION       */
             /*              (E.G. PARENTHESIS DO NOT MATCH,        */
             /*              TOO MANY COMMAS, MISSING               */
             /*              SEMICOLON)                             */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES: CONCAT)FIRSTVAR,SECOND);                  */
             /*           CONCAT(FIRSTVAR SECOND);                  */
             /*           CONCAT(FIRSTVAR, SECOND)                  */
             /*           CONCAT(FIRSTVAR, SECOND,);                */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('761',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(961);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
    END;
 ELSE DO;
    POINTPOSITION=INDEX(RULEARRAY.CONTENT(I+2),'.');
    IF POINTPOSITION^=0 THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI762                                    */
             /* MESSAGE: CONCAT FUNCTION APPLIED TO DBVARIABLE      */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A 'CONCAT'       */
             /*              FUNCTION WHICH HAS AN INVALID          */
             /*              SYNTAX.                                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_CONCAT                                */
             /* USER RESPONSE: CHECK FOR THE CORRECTNESS OF THE     */
             /*              CONCAT FUNCTION. IT APPEARS THAT YOU   */
             /*              TRIED TO CONCATENATE A DATABASE        */
             /*              VARIABLE WHICH IS NOT ALLOWED.         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES: CONCAT(BLA.IOPUCTY,USVAR);                */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('762',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(962);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
             END;
    ELSE DO;
      FIRST_USERVARIABLE_NAME = SUBSTR(RULEARRAY.CONTENT(I+2),8,
                FIRST_COMMA-FIRST_PARENTHESIS-1);
      SECOND_USERVARIABLE_NAME = SUBSTR(RULEARRAY.CONTENT(I+2),
                FIRST_COMMA+1,LAST_PARENTHESIS-FIRST_COMMA-1);
      RULEARRAY.USER_VARIABLE(I+2) = '1'B;
      RULEARRAY.CONTENT(I+2)=FIRST_USERVARIABLE_NAME;
      RULEARRAY.USER_VARIABLE(I+2) = '1'B;
      TOKENS_IN_STATEMENT = 4;
      CALL CALCULATE_ASSIGNMENT;
      FIRST_USERVARIABLE_NAME = SFARRAY.CALCULATION_FIELD.CHAR_FIELD(1);
      FIRST_DIGITS = SFARRAY.PRECISION.DIGITS(1);
      RULEARRAY.USER_VARIABLE(I+2) = '1'B;
      RULEARRAY.CONTENT(I+2)=SECOND_USERVARIABLE_NAME;
      RULEARRAY.USER_VARIABLE(I+2) = '1'B;
      TOKENS_IN_STATEMENT = 4;
      CALL CALCULATE_ASSIGNMENT;
      SECOND_USERVARIABLE_NAME=SFARRAY.CALCULATION_FIELD.CHAR_FIELD(1);
      SECOND_DIGITS = SFARRAY.PRECISION.DIGITS(1);
      FIRST_USERVARIABLE_NAME = SUBSTR(FIRST_USERVARIABLE_NAME,
                     1,FIRST_DIGITS) !!
                     SUBSTR(SECOND_USERVARIABLE_NAME,1,
                     SECOND_DIGITS);
      SFARRAY.CALCULATION_FIELD.CHAR_FIELD(1) = FIRST_USERVARIABLE_NAME;
      SFARRAY.CHARACTER(1) = '1'B;
      SFARRAY.USER_VARIABLE(1) = '1'B;
      SFARRAY.PRECISION.DIGITS(1) = FIRST_DIGITS + SECOND_DIGITS;
      CALL ASSIGN_CALCULATED_VALUE;
      END;
    END;
0END DO_CONCAT;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE PROCESSES A ROUND  FUNCTION           */
 /*******************************************************************/
0DO_ROUND: PROCEDURE;
 /*******************************************************************/
 /*                                                                 */
 /*  A CONCAT FUNCTION HAS THE FOLLOWING SYNTAX:                    */
 /*      USERVARIABLE = ROUND(USERVARIABLE,POSITION);               */
 /*                                                                 */
 /*                                                                 */
 /*  WHERE 'POSITION' IS THE NUMBER OF THE DIGIT CALCULATED FROM    */
 /*  THE DECIMAL POINT TO WHICH THE USERVARIABLE'S CONTENT          */
 /*  IS TO BE ROUNDED.                                              */
 /*                                                                 */
 /*                                                                 */
 /*  EXAMPLES:                                                      */
 /*  ---------                                                      */
 /*  RULE:       RUSV = ROUND (QTY,1);                              */
 /*  VALUE:      QTY = 25.55       --->   RUSV = 25.6               */
 /*  VALUE:      QTY = 25.54       --->   RUSV = 25.5               */
 /*  VALUE:      QTY = 25.5499     --->   RUSV = 25.5               */
 /*  VALUE:      QTY = 25.5        --->   RUSV = 25.5               */
 /*                                                                 */
 /*  RULE:       RUSV = ROUND (QTY,0);                              */
 /*  VALUE:      QTY = 25.55       --->   RUSV = 26.0               */
 /*  VALUE:      QTY = 25.4        --->   RUSV = 25.0               */
 /*  VALUE:      QTY = 25.499      --->   RUSV = 25.0               */
 /*  VALUE:      QTY = 25.5        --->   RUSV = 26.0               */
 /*                                                                 */
 /*******************************************************************/
0TOKENS_IN_STATEMENT = 4;
0FIRST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),'(');
 FIRST_COMMA = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),',');
 LAST_PARENTHESIS = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),')');
 NEXT_SEMICOLON = INDEX(SUBSTR(RULEARRAY.CONTENT(I+2),1,31),';');
 IF ((FIRST_PARENTHESIS=0) !
    (LAST_PARENTHESIS=0) !
    (FIRST_COMMA=0) !
    (NEXT_SEMICOLON=0)) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI763                                    */
             /* MESSAGE: ROUND     FUNCTION WITH INVALID SYNTAX     */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A 'ROUND'        */
             /*              FUNCTION WHICH HAS AN INVALID          */
             /*              SYNTAX.                                */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_ROUND                                 */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              SYNTAX IN THE ROUND     FUNCTION       */
             /*              (E.G. PARENTHESIS DO NOT MATCH,        */
             /*              TOO MANY COMMAS, MISSING               */
             /*              SEMICOLON)                             */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES: ROUND )FIRSTVAR,1);                       */
             /*           ROUND (FIRSTVAR 1);                       */
             /*           ROUND (FIRSTVAR; 1);                      */
             /*           ROUND (FIRSTVAR, 1,);                     */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('763',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(963);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
    END;
 ELSE DO;
    POINTPOSITION=INDEX(RULEARRAY.CONTENT(I+2),'.');
    IF POINTPOSITION^=0 THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI764                                    */
             /* MESSAGE: ROUND  FUNCTION APPLIED TO DBVARIABLE      */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A 'ROUND'        */
             /*              FUNCTION WHERE THE FIRST ARGUMENT      */
             /*              WAS A DATABASE VARIABLE.               */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_ROUND                                 */
             /* USER RESPONSE: CHECK FOR THE CORRECTNESS OF THE     */
             /*              ROUND  FUNCTION. IT APPEARS THAT YOU   */
             /*              TRIED TO ROUND       A DATABASE        */
             /*              VARIABLE WHICH IS NOT ALLOWED.         */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES:  ROUND(BLA.QAGRCOP,1);                    */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('764',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SP.RULE_NAME);
             END;
             ELSE DO;
                QCHNOT(964);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
             END;
    ELSE DO;
      ROUND_USERVARIABLE_NAME = SUBSTR(RULEARRAY.CONTENT(I+2),7,
                FIRST_COMMA-FIRST_PARENTHESIS-1);
      IF (VERIFY(SUBSTR(RULEARRAY.CONTENT(I+2),
             FIRST_COMMA+1,LAST_PARENTHESIS-FIRST_COMMA-1),
             NUMERIC) > 0) THEN DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI766                                    */
             /* MESSAGE: DIGIT NUMBER '*V' IN ROUND    (LINE *V,    */
             /*          RULE *V)                                   */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A 'ROUND'        */
             /*              FUNCTION WHERE THE DIGIT IDENTIFIER    */
             /*              WAS NOT NUMERIC.                       */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_ROUND                                 */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              DIGIT SPECIFIER IN THE ROUND FUNCTION  */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES: ROUND(ROUNDVAR,A);                        */
             /*           ROUND(ROUNDVAR,DIGIT);                    */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('766',SUBSTR(RULEARRAY.CONTENT(I+2),
                           FIRST_COMMA+1,LAST_PARENTHESIS-FIRST_COMMA-1)
                           !! ',' !! SUBSTR(LINECHAR,7,3)
                           !! ',' !! SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(966);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
          END;
      ROUND_DIGIT = SUBSTR(RULEARRAY.CONTENT(I+2),
                FIRST_COMMA+1,LAST_PARENTHESIS-FIRST_COMMA-1);
      RULEARRAY.USER_VARIABLE(I+2) = '1'B;
      RULEARRAY.CONTENT(I+2)=ROUND_USERVARIABLE_NAME;
      RULEARRAY.USER_VARIABLE(I+2) = '1'B;
      TOKENS_IN_STATEMENT = 4;
      CALL CALCULATE_ASSIGNMENT;
      ROUND_VALUE = SFARRAY.CALCULATION_FIELD.DEC_FIELD(1);
      SELECT (ROUND_DIGIT);
         WHEN(0)  ROUNDED_VALUE=ROUND(ROUND_VALUE,0);
         WHEN(+1) ROUNDED_VALUE=ROUND(ROUND_VALUE,1);
         WHEN(+2) ROUNDED_VALUE=ROUND(ROUND_VALUE,2);
         WHEN(+3) ROUNDED_VALUE=ROUND(ROUND_VALUE,3);
         OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI765                                    */
             /* MESSAGE: ROUND FUNCTION USED *V DIGITS (LINE *V,    */
             /*          RULE *V)                                   */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A 'ROUND'        */
             /*              FUNCTION WHICH HAS AN INVALID          */
             /*              SYNTAX: THE DIGIT SPECIFYING THE       */
             /*              POSITION TO BE ROUNDED WAS LESS THAN   */
             /*              0  OR MORE THAN +3.                    */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_ROUND                                 */
             /* USER RESPONSE: CHECK WHETHER THERE WAS AN INVALID   */
             /*              SYNTAX IN THE ROUND     FUNCTION       */
             /*              (DIGIT SPECIFIER INVALID)              */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES: ROUND(ROUNDVAR,-4);                       */
             /*           ROUND(ROUNDVAR,4);                        */
             /*                                                     */
             /*******************************************************/
             LINECHAR =  RULEARRAY.LINENUMBER(I);
             NUMCHAR =  ROUND_DIGIT;
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('765',SUBSTR(NUMCHAR,6,5)
                           !! ',' !! SUBSTR(LINECHAR,7,3)
                           !! ',' !! SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(965);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
          END;
      END;
      SFARRAY.CALCULATION_FIELD.DEC_FIELD(1)=ROUNDED_VALUE;
      CALL ASSIGN_CALCULATED_VALUE;
      END;
    END;
0END DO_ROUND;
1/*******************************************************************/
 /*  FUNCTION: THIS PROCEDURE PROCESSES A FUNCTION STATEMENT        */
 /*******************************************************************/
0DO_FUNCTION: PROCEDURE;
 IF RULEARRAY.USER_VARIABLE(I)='1'B THEN DO;
    SELECT (SUBSTR(RULEARRAY.CONTENT(I+2),1,4));
       WHEN('FORM') CALL DO_FORMAT;
       WHEN('SUBS') CALL DO_SUBSTRING;
       WHEN('DATE') CALL DO_DATE;
       WHEN('CONC') CALL DO_CONCAT;
       WHEN('ROUN') CALL DO_ROUND;
       WHEN('ZERO') CALL DO_ZERO;
       WHEN('CHAR') CALL DO_CHARACTER;
       WHEN('LCHA') CALL DO_LCHARACTER;
       WHEN('DECI') CALL DO_DECIMAL;
       OTHERWISE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI752                                    */
             /* MESSAGE: INVALID FUNCTION SPECIFIED IN RULE         */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A FUNCTION       */
             /*              WHICH IS NOT AMONG THE SUPPORTED LIST. */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_FUNCTION                              */
             /* USER RESPONSE: CHECK WHETHER THE FUNCTION WAS       */
             /*              SPELLED CORRECTLY WITHIN THE RULE.     */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES: JOHN      = FORMATT(BLA.VLRXG,4,2);       */
             /*           JIM       = SUBST(BLA.VLRXG,4,2);         */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('752',SUBSTR(RULEARRAY.CONTENT(I+2),1,7) !! ','
                           !! SUBSTR(LINECHAR,7,3)
                           !! ',' !! SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(952);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
          END;
    END;
    END;
 ELSE DO;
             /*******************************************************/
             /* ----------------     E R R O R     ---------------- */
             /* MSGCODE: QCHI753                                    */
             /* MESSAGE: FUNCTION ASSIGNED TO NON-USERVARIABLE XXXX */
             /*          (LINE XXX)                                 */
             /* MESSAGECLASS: SYNTAX ERROR MESSAGE                  */
             /* EXPLANATION: THE INTERPRETER FOUND A 'FORMAT' OR    */
             /*              'SUBSTRING' STATEMENT WHICH HAS AN     */
             /*              INVALID SYNTAX.                        */
             /* SEVERITY: 8                                         */
             /* PROCEDURE: DO_FUNCTION                              */
             /* USER RESPONSE: CHECK WHETHER THE VARIABLE ON THE    */
             /*              LEFT SIDE OF THE ASSIGNMENT CHARACTER  */
             /*              IS A USER-VARIABLE                     */
             /* SYSTEM ACTION: THE INTERPRETER RETURNS WITHOUT      */
             /*                FURTHER PROCESSING                   */
             /* EXAMPLES: BLA.VLRXG = FORMAT(BLA.VLRXG,4,2);        */
             /*           BLA.VLRXG = SUBSTRING(BLA.VLRXG,4,2);     */
             /*                                                     */
             /*******************************************************/
             LINECHAR = RULEARRAY.LINENUMBER(I);
             IF SP.RUN_MODE = 'M' THEN DO;
                INTMSG ('753',SUBSTR(LINECHAR,7,3)
                           !! ',' !! SUBSTR(SP.RULE_NAME,5,4));
             END;
             ELSE DO;
                QCHNOT(953);
                SP.EOP_FROM_RULE = '1'B;
                SP.ROLB_REQU = '1'B;
                GOTO ABEND;
             END;
    END;
0END DO_FUNCTION;
-END QCHINTM;
